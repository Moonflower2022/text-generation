def caesar_cipher_decrypt(ciphertext, key):
    plaintext = ""
    for char in ciphertext:
        if char.isalpha():
            char_code = ord(char.lower()) - 97
            char_code = (char_code - key) % 26
            plaintext += chr(char_code + 97)
        else:
            plaintext += char
    return plaintext
ciphertext = "Uryyb, jbeyq!"
key = 13
plaintext = caesar_cipher_decrypt(ciphertext, key)
print(plaintext)


def find_common_items(list1, list2):
    common_items = []
    for item in list1:
        if item in list2:
            common_items.append(item)
    return common_items


arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Sort the list in reverse order
arr.sort(reverse=True)

# Sort the list by even and odd numbers
arr.sort(key=lambda x: x % 2)

# Print the reversed list
print(arr)


def reverse_sentence(sentence):
    words = sentence.split()  # Split the sentence into a list of words
    reversed_words = [word[::-1] for word in words]  # Reverse each word
    reversed_sentence = " ".join(reversed_words)  # Join the reversed words back into a sentence
    return reversed_sentence

# Example usage
sentence = "Hello world!"
reversed_sentence = reverse_sentence(sentence)
print(reversed_sentence)  # Output: olleH !dlrow


def evaluate_string(string):
    for i in range(len(string) - 2):
        if string[i:i+3].isupper():
            return True
    return False

# Example usage:
print(evaluate_string("Hello"))  # False
print(evaluate_string("HeLLO"))  # True
print(evaluate_string("HeLLO WorLD"))  # True
print(evaluate_string("AbC"))  # True
print(evaluate_string("abc"))  # False


def find_second_largest(lst):
    largest = float('-inf')
    second_largest = float('-inf')
    
    for num in lst:
        if num > largest:
            second_largest = largest
            largest = num
        elif num > second_largest and num != largest:
            second_largest = num
    
    return second_largest

lst = [1, 5, 9, 12, 8]
print(find_second_largest(lst))


import json
import xml.etree.ElementTree as ET


def validate_json(json_data):
    # Check if required fields exist
    required_fields = ['name', 'age', 'email']
    for field in required_fields:
        if field not in json_data:
            raise ValueError(f"Required field '{field}' is missing.")

    # Check if values are valid
    if not isinstance(json_data['name'], str):
        raise ValueError("Field 'name' should be a string.")
    if not isinstance(json_data['age'], int) or json_data['age'] < 0:
        raise ValueError("Field 'age' should be a positive integer.")
    if not isinstance(json_data['email'], str) or '@' not in json_data['email']:
        raise ValueError("Field 'email' should be a valid email address.")


def json_to_xml(json_data):
    # Validate the JSON data
    validate_json(json_data)

    # Create the root element
    root = ET.Element('root')

    # Create the person element
    person = ET.SubElement(root, 'person')

    # Add name element
    name = ET.SubElement(person, 'name')
    name.text = json_data['name']

    # Add age element
    age = ET.SubElement(person, 'age')
    age.text = str(json_data['age'])

    # Add email element
    email = ET.SubElement(person, 'email')
    email.text = json_data['email']

    # Add additional nested object inside person
    additional = ET.SubElement(person, 'additional')
    # Add required fields for the additional object
    if 'field1' in json_data['additional']:
        field1 = ET.SubElement(additional, 'field1')
        field1.text = json_data['additional']['field1']
    else:
        raise ValueError("Required field 'field1' is missing in the additional object.")
    if 'field2' in json_data['additional']:
        field2 = ET.SubElement(additional, 'field2')
        field2.text = json_data['additional']['field2']
    else:
        raise ValueError("Required field 'field2' is missing in the additional object.")

    # Create the XML tree and return the XML string
    xml_tree = ET.ElementTree(root)
    return ET.tostring(root, encoding='utf-8', method='xml').decode('utf-8')


# Example JSON data
json_data = {
    "name": "John Doe",
    "age": 30,
    "email": "johndoe@example.com",
    "additional": {
        "field1": "Value 1",
        "field2": "Value 2"
    }
}

# Convert JSON to XML
xml_data = json_to_xml(json_data)
print(xml_data)


def decimal_to_binary(decimal):
    # Check if the input is a valid decimal number
    try:
        decimal = float(decimal)
    except ValueError:
        raise ValueError("Invalid decimal number")

    # Handle negative numbers separately
    if decimal < 0:
        decimal *= -1
        binary = "-"

    else:
        binary = ""

    # Convert the whole number part to binary
    whole = int(decimal)
    while whole > 0:
        binary = str(whole % 2) + binary
        whole = whole // 2

    # If the decimal number has a fractional part, convert it to binary
    fractional = decimal % 1
    if fractional > 0:
        binary += "."

        while fractional > 0:
            fractional *= 2
            bit = int(fractional)
            binary += str(bit)
            fractional -= bit

    return binary


import random
import string

# Create an empty dictionary
my_dict = {}

# Generate 10 key-value pairs
for _ in range(10):
    key = random.randint(1, 100)
    value = []
    num_strings = random.randint(3, 10)
    for _ in range(num_strings):
        string_length = random.randint(1, 10)
        random_string = ''.join(random.choice(string.ascii_lowercase) for _ in range(string_length))
        value.append(random_string)
    my_dict[key] = value

# Print the resulting dictionary
print(my_dict)


def search_list(lst, target):
    for i in range(len(lst)):
        if lst[i] == target:
            return i
    return -1

lst = [1, 2, 3]
target = 4
print(search_list(lst, target))


from collections import Counter
from math import factorial

def print_unique_permutations(input_str):
    char_counts = Counter(input_str)
    total_permutations = factorial(len(input_str))
    
    for perm_num in range(total_permutations):
        current_perm = []
        remaining_permutations = perm_num
        
        for char, count in char_counts.items():
            if count == 0:
                continue
            
            current_perm.append(char)
            char_counts[char] -= 1
            remaining_permutations //= count
        
            if remaining_permutations == 0:
                break
        
        print(''.join(current_perm))
        
        for char in current_perm:
            char_counts[char] += 1

# Example usage:
input_string = "aab"
print_unique_permutations(input_string)


def remove_duplicates(numbers):
    unique_numbers = list(set(numbers))
    unique_numbers.sort()
    return len(unique_numbers)

# Example usage
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
result = remove_duplicates(numbers)
print("Unique numbers:", result)


def find_max_min(arr):
    if not arr:
        return None, None
    
    # Initialize variables to store max and min values
    max_value = arr[0]
    min_value = arr[0]
    
    # Iterate through the array
    for num in arr:
        if num > max_value:
            max_value = num
        if num < min_value:
            min_value = num
    
    return min_value, max_value


# Test the program
arr = [4, 2, 9, 7, 5, 1, 3, 6, 8]
min_value, max_value = find_max_min(arr)
print("Minimum value:", min_value)
print("Maximum value:", max_value)


def print_triangle_pattern(height):
    for row in range(1, height + 1):
        line = ""
        line += str(row * 2)
        
        for i in range(1, row):
            line += str(row * 3 + i * 2)
        
        line += str(row * 2)
        
        print(line)


import datetime
# Set the starting time yesterday and ending time today
start_time = datetime.datetime(2021, 8, 12, 10, 17, 32)  # year, month, day, hour, minute, second
end_time = datetime.datetime(2021, 8, 13, 19, 56, 42) 
# Calculate the time difference
time_diff = end_time - start_time
# Convert the time difference to hours
total_hours = time_diff.total_seconds() / 3600
# Print the total number of hours
print("Total number of hours:", total_hours)


import random
idioms = {
 "the stakes are": "going up",
 "hit the": "road",
 "let the cat out of the": "bag",
 "spill the": "beans",
 "take the": "plunge"
}
idiom = random.choice(list(idioms.keys()))
sentence = idiom + " " + "___"
print(sentence)


import math
radius = 5
density = 3
surface_area = 4 * math.pi * radius ** 2
mass = density * (4/3) * math.pi * radius ** 3
print("Surface area: {:.2f} cmÂ²".format(surface_area))
print("Mass: {:.2f} g".format(mass))


import re

def extract_variable_types(code_snippet):
    # Regular expression pattern to match variable declarations
    pattern = r'(?<=\s)[a-zA-Z]+\s*=\s*([^;,\n]+)'

    # Find all matches of the pattern in the code snippet
    matches = re.findall(pattern, code_snippet)

    variable_types = []
    for match in matches:
        # Clean up the match by removing any leading/trailing spaces
        match = match.strip()

        # Check if the match represents an object or array
        if match.startswith('{') or match.startswith('['):
            # Extract the inner part of the object/array and recursively extract variable types
            inner_snippet = match[1:-1]
            inner_types = extract_variable_types(inner_snippet)
            variable_types.extend(inner_types)
        else:
            # Extract the type from the match (e.g., "int", "float", "string")
            variable_type = match.split()[0]
            variable_types.append(variable_type)

    return variable_types


class Node:
    def __init__(self, data=None, prev=None, next=None):
        self.data = data
        self.prev = prev
        self.next = next

def calculate_length_and_sum(head):
    length = 0
    total_sum = 0

    current = head
    while current:
        if current.data >= 0:
            total_sum += current.data
        length += 1
        current = current.next

    return length, total_sum

# Create the doubly linked list
node1 = Node(10)
node2 = Node(-20)
node3 = Node(30)
node4 = Node(-40)
node5 = Node(50)

node1.next = node2
node2.prev = node1
node2.next = node3
node3.prev = node2
node3.next = node4
node4.prev = node3
node4.next = node5
node5.prev = node4

length, total_sum = calculate_length_and_sum(node1)
print("Length:", length)
print("Sum:", total_sum)


def most_frequent_item(lst):
    max_count = 0
    max_item = None

    # iterate through the list
    for i in range(len(lst)):
        count = 0

        # count occurrences of the current item in the list
        for j in range(len(lst)):
            if lst[j] == lst[i]:
                count += 1

        # check if the current item has higher frequency than the current maximum
        if count > max_count:
            max_count = count
            max_item = lst[i]

    return max_item


class Student:
    def __init__(self, name):
        self.name = name
    
    def assign_tutor(self, tutor, subject):
        # Check if the student already has a tutor for the subject
        if not self.has_tutor_for_subject(subject):
            # Insert a new record in the StudentTutorSubject table
            insert_into_student_tutor_subject(self.student_id, tutor.tutor_id, subject.subject_id)
        else:
            raise Exception("Student already has a tutor for this subject")
    
    def has_tutor_for_subject(self, subject):
        # Query the StudentTutorSubject table to check if the student has a tutor for the subject
        result = query_student_tutor_subject(self.student_id, subject.subject_id)
        return result is not None


class Tutor:
    def __init__(self, name):
        self.name = name


class Subject:
    def __init__(self, name):
        self.name = name


def find_min_max_indices(lst):
    if not lst:
        return []

    min_value = max_value = lst[0]
    min_indices = [0]
    max_indices = [0]

    for i in range(1, len(lst)):
        if lst[i] < min_value:
            min_value = lst[i]
            min_indices = [i]
        elif lst[i] == min_value:
            min_indices.append(i)
        elif lst[i] > max_value:
            max_value = lst[i]
            max_indices = [i]
        elif lst[i] == max_value:
            max_indices.append(i)

    return min_value, min_indices, max_value, max_indices

# Example usage
lst = [4, 2, 7, 1, 2, 9, 5, 7]
min_value, min_indices, max_value, max_indices = find_min_max_indices(lst)
print("Min Value:", min_value)
print("Min Indices:", min_indices)
print("Max Value:", max_value)
print("Max Indices:", max_indices)


def char_indices(string):
    char_dict = {}
    for index, char in enumerate(string):
        if char in char_dict:
            char_dict[char].append(index)
        else:
            char_dict[char] = [index]
    return dict(sorted(char_dict.items()))


def find_missing_number(arr):
    n = len(arr)
    expected_sum = (n+1) * (n+2) // 2
    actual_sum = 0
    for num in arr:
        actual_sum += num
    missing_number = expected_sum - actual_sum
    return missing_number

arr = [1, 2, 2, 3, 3, 5, 6, 7, 7, 8]
missing_number = find_missing_number(arr)
print("The missing number is:", missing_number)


import datetime

def calculate_weekdays(start_date, end_date, holidays):
    # Step 1: Calculate the total number of days between the start and end dates
    total_days = (end_date - start_date).days + 1

    # Step 2: Determine the number of weekends within this period
    weekends = 0
    for i in range(total_days):
        date = start_date + datetime.timedelta(days=i)
        if date.weekday() >= 5:  # Saturday (5) or Sunday (6)
            weekends += 1

    # Step 3: Determine the number of holidays within this period
    holiday_count = 0
    for holiday in holidays:
        if start_date <= holiday <= end_date:
            holiday_count += 1

    # Step 4: Subtract the weekends and holidays from the total number of days
    weekdays = total_days - weekends - holiday_count

    # Step 5: Set the number of weekdays to the maximum allowed weekdays if it exceeds it
    weekdays = min(weekdays, 30)

    # Step 6: Return the number of weekdays as the result
    return weekdays


def check_occurrence(lst, number):
    count = 0
    for num in lst:
        if num == number:
            count += 1
            if count > 2:
                return True
    return False


def calculate_length(lst):
    count = 0
    for item in lst:
        count += 1
    return count


def count_occurrences(char, string):
    if string is None:
        raise ValueError("Input string cannot be None")

    count = 0
    quote_count = 0
    paren_count = 0

    for c in string:
        if c == "'":
            quote_count += 1
        elif c == "(":
            paren_count += 1
        elif c == ")":
            paren_count -= 1
        elif quote_count % 2 == 0 and paren_count == 0 and c == char:
            count += 1

    return count


def binary_search(arr, low, high, target):
    if low > high:
        return -1
    
    mid = (low + high) // 2
    
    if arr[mid] == target:
        return mid
    
    if arr[low] <= arr[mid]:
        if arr[low] <= target <= arr[mid]:
            return binary_search(arr, low, mid - 1, target)
        return binary_search(arr, mid + 1, high, target)
    
    if arr[mid] <= target <= arr[high]:
        return binary_search(arr, mid + 1, high, target)
    return binary_search(arr, low, mid - 1, target)


import re
import multiprocessing
from bs4 import BeautifulSoup
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_selection import SelectKBest, mutual_info_classif
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize

# Preprocessing function to clean email text
def preprocess_email_text(email_text):
    """
    This function takes in raw email text and performs several preprocessing steps:
    - Removing HTML tags using BeautifulSoup
    - Removing non-alphabetic characters using regex
    - Tokenizing the text into words
    - Removing English stop words
    """
    # Remove HTML tags
    soup = BeautifulSoup(email_text, "html.parser")
    email_text = soup.get_text()

    # Remove non-alphabetic characters
    email_text = re.sub(r'[^a-zA-Z]', ' ', email_text)

    # Tokenize the text
    words = word_tokenize(email_text)

    # Remove stop words
    stop_words = set(stopwords.words('english'))
    words = [word for word in words if word not in stop_words]

    return ' '.join(words)

# Function to train Naive Bayes model
def train_naive_bayes(X_train, y_train, n_features):
    """
    This function trains a Naive Bayes model on the training data.
    It uses mutual information for feature selection and a pipeline for efficiency.
    It uses multiprocessing to speed up the training process.
    """
    # Create a pipeline with feature extraction, feature selection, and classification
    pipeline = Pipeline([
        ('vect', CountVectorizer(preprocessor=preprocess_email_text)),
        ('select', SelectKBest(mutual_info_classif, k=n_features)),
        ('clf', MultinomialNB())
    ])

    # Use multiprocessing to speed up the training process
    with multiprocessing.Pool() as pool:
        pipeline.fit(X_train, y_train)

    return pipeline


words = ["hello", "WORLD", "foo", "bar", "Baz"]

# Filter out strings containing vowels
filtered_words = [word for word in words if not any(vowel in word.lower() for vowel in "aeiou")]

# Convert the strings to lowercase or uppercase based on their index
formatted_words = [filtered_words[i].lower() if i % 2 == 0 else filtered_words[i].upper() for i in range(len(filtered_words))]

# Join the formatted words into a single sentence
sentence = " ".join(formatted_words)

print(sentence)


import re
from collections import Counter

def create_word_frequency(sentence):
    # Remove punctuation marks and convert to lowercase
    sentence = re.sub(r'[^\w\s]', '', sentence.lower())
    
    # Exclude common English words
    common_words = ['the', 'is', 'and']
    
    # Split sentence into words
    words = sentence.split()
    
    # Combine consecutive words to get word combinations
    combinations = [f"{words[i]} {words[i+1]}" for i in range(len(words)-1)]
    
    # Count word frequencies
    word_freq = Counter(words + combinations)
    
    # Remove common words from the dictionary
    for word in common_words:
        del word_freq[word]
    
    # Sort the dictionary by word frequencies in descending order
    sorted_freq = dict(sorted(word_freq.items(), key=lambda x: x[1], reverse=True))
    
    return sorted_freq

# Example usage
sentence = "The quick brown fox jumps over the lazy dog. The dog is very lazy and the fox is very quick."
word_freq = create_word_frequency(sentence)
print(word_freq)


age = 17

if age >= 18:
    print("You are eligible to vote!")
else:
    print("Sorry, you are not eligible to vote yet.")


import json
# JSON data
data = '''
{
 "octopus": {
 "weight": 4.5
 },
 "wolf": {
 "weight": 40
 },
 "deer": {
 "weight": 200
 },
 "rhinoceros": {
 "weight": 2000
 }
}
'''
# Load JSON data
animals = json.loads(data)
# Sort animals based on weight
sorted_animals = sorted(animals.items(), key=lambda x: x[1]['weight'])
# Print sorted list of animals
for animal in sorted_animals:
 print(animal[0])


def fetch_elements(arr, n):
    # Ensure the array has at least 10 elements
    if len(arr) < 10:
        return "Array should have at least 10 elements"

    # Sort the array in ascending order
    arr.sort()

    # Initialize an empty list to store the fetched elements
    fetched_elements = []

    # Iterate through the sorted array
    for num in arr:
        # Ignore negative elements
        if num < 0:
            continue

        # Add the positive element to the fetched_elements list
        fetched_elements.append(num)

        # Break the loop if we have fetched enough elements
        if len(fetched_elements) == n:
            break

    return fetched_elements


def combinationSum2(candidates, target):
    def combine(candidates, target, start, path, res):
        if target == 0:
            res.append(path)
            return
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            if candidates[i] > target:
                break
            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)

    candidates.sort()
    res = []
    combine(candidates, target, 0, [], res)
    return res


def remove_numbers(document):
    result = ""
    for char in document:
        if not char.isdigit():
            result += char
    return result


def modify_strings(input_list):
    result = []

    for string in input_list:
        if string[0].isupper() and all(letter.lower() not in 'aeiou' for letter in string):
            result.append(string[::-1])

    result.sort()
    return result


import random
last_ten_names = []
def generate_grocery_delivery_app_name(words_list):
    global last_ten_names
    
    while True:
        word = random.choice(words_list)
        number = random.randint(1, 100)
        name = f"grocery-delivery-{word}-{number}"
        
        if name not in last_ten_names:
            last_ten_names.append(name)
            if len(last_ten_names) > 10:
                last_ten_names.pop(0)
            return name


import math

def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    sqrt_n = int(math.sqrt(n)) + 1
    for i in range(3, sqrt_n, 2):
        if n % i == 0:
            return False
    return True

def sort_numbers(numbers):
    primes = []
    non_primes = []
    for num in numbers:
        if is_prime(num):
            primes.append(num)
        else:
            non_primes.append(num)
    return sorted(primes, reverse=True) + sorted(non_primes, reverse=True)


# Assuming the original array is named 'original_array'
original_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# Create a new empty array to store the copied elements
copied_array = []

# Iterate through each element of the original array
for element in original_array:
    # Copy the element to the new array
    copied_array.append(element)

# Print the copied array to verify the result
print(copied_array)


def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def sum_of_primes(n):
    count = 0
    num = 2
    primes_sum = 0
    while count < n:
        if is_prime(num) and num % 2 == 0:
            primes_sum += num
            count += 1
        num += 1
    return primes_sum


import json
from difflib import SequenceMatcher


class SearchSystem:
    def __init__(self):
        self.keywords = {}

    def add(self, keyword, value):
        self.keywords[keyword] = value

    def search(self, *keywords):
        results = []
        for keyword in keywords:
            if keyword in self.keywords:
                results.append(self.keywords[keyword])
        return results

    def delete(self, keyword):
        if keyword in self.keywords:
            del self.keywords[keyword]

    def update(self, keyword, value):
        if keyword in self.keywords:
            self.keywords[keyword] = value

    def count(self):
        return len(self.keywords)

    def prefix_search(self, prefix):
        results = []
        for keyword in self.keywords.keys():
            if keyword.startswith(prefix):
                results.append(keyword)
        return results

    def top_searches(self, n):
        sorted_keywords = sorted(self.keywords, key=self.keywords.get, reverse=True)
        return sorted_keywords[:n]

    def clear(self):
        self.keywords.clear()

    def fuzzy_search(self, keyword):
        results = []
        for existing_keyword in self.keywords.keys():
            similarity = SequenceMatcher(None, existing_keyword, keyword).ratio()
            if similarity > 0.6:  # Adjust the threshold as needed
                results.append(existing_keyword)
        return results

    def save(self, filename):
        with open(filename, 'w') as file:
            json.dump(self.keywords, file)

    def load(self, filename):
        with open(filename, 'r') as file:
            self.keywords = json.load(file)


def calculate_average_age(ages):
    total_age = 0
    max_age = float('-inf')
    min_age = float('inf')
    outlier_count = 0

    for age in ages:
        total_age += age
        max_age = max(max_age, age)
        min_age = min(min_age, age)

    average_age = round(total_age / len(ages))

    for age in ages:
        if age > average_age + 10 or age < average_age - 10:
            outlier_count += 1

    return average_age, max_age, min_age, outlier_count


fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(index, fruit)


def find_max(arr):
    return max(arr, key=lambda x: -x)



def search_element(array, element):
    for i in range(len(array)):
        if array[i] == element:
            return i
    return -1


import sqlite3

def delete_row(connection):
    try:
        # Start a transaction
        connection.execute("BEGIN TRANSACTION")

        # Execute the complex query
        cursor = connection.execute("SELECT ...")

        # Fetch the row to be deleted
        row = cursor.fetchone()

        if row:
            # Delete the row using its primary key
            connection.execute("DELETE FROM table_name WHERE id=?", (row['id'],))

        # Commit the transaction
        connection.execute("COMMIT")

        # Close the cursor
        cursor.close()

    except sqlite3.Error as error:
        # Rollback the transaction in case of any exception
        connection.execute("ROLLBACK")

        # Display the error message
        print(f"Error: {error}")

    finally:
        # Close the database connection
        connection.close()

# Create a connection to the SQLite database
connection = sqlite3.connect("database.db")

# Call the function to delete the row
delete_row(connection)


def print_prime_numbers(start, end):
    # Create a list to store the prime numbers
    primes = []

    # Create a boolean array "is_prime[0..n]" and initialize
    # all entries it as true.
    is_prime = [True] * (end + 1)
    is_prime[0] = is_prime[1] = False

    # Start with the first prime number, 2
    p = 2

    while p * p <= end:
        # If is_prime[p] is not changed, then it is a prime
        if is_prime[p]:
            # Update all multiples of p as non-prime
            for i in range(p * p, end + 1, p):
                is_prime[i] = False

        p += 1

    # Print all prime numbers in the given range
    for p in range(start, end + 1):
        if is_prime[p]:
            primes.append(p)

    return primes

# Test the function
start = int(input("Enter the starting range: "))
end = int(input("Enter the ending range: "))

print("Prime numbers in the given range:")
print(print_prime_numbers(start, end))


def convert_to_string(integer):
    if integer < 0:
        raise ValueError("Integer cannot be negative.")
    
    string = str(integer)
    
    # Add leading zeros if necessary
    while len(string) < 8:
        string = "0" + string
    
    return string


import math

def calculate_circle_area(radius=None):
    if radius is None:
        return "Radius is not provided."
    elif radius <= 0:
        return "Radius should be a positive integer."
    else:
        area = math.pi * (radius ** 2)
        return round(area, 2)

# Test the function
print(calculate_circle_area(5))  # Output: 78.54
print(calculate_circle_area(0))  # Output: Radius should be a positive integer.
print(calculate_circle_area())   # Output: Radius is not provided.


import random

class Game:
    def __init__(self, players):
        self.players = players
        self.score = {player: {'wins': 0, 'losses': 0, 'ties': 0} for player in players}

    def play_round(self):
        player1 = self.get_player_choice(self.players[0])
        if player1 is None:
            return

        player2 = self.get_player_choice(self.players[1])
        if player2 is None:
            return

        result = self.get_round_result(player1, player2)
        self.update_score(result)

        print(f"{self.players[0]} chose {player1}.")
        print(f"{self.players[1]} chose {player2}.")
        print(f"Result: {result}\n")

    def get_player_choice(self, player):
        while True:
            choice = input(f"{player}, choose one: rock, paper, scissors, lizard, Spock (q to quit): ").lower()
            if choice == 'q':
                return None
            if choice in ['rock', 'paper', 'scissors', 'lizard', 'spock']:
                return choice
            print("Invalid choice. Please try again.")

    def get_round_result(self, player1, player2):
        if player1 == player2:
            return 'tie'
        if (player1 == 'rock' and (player2 == 'scissors' or player2 == 'lizard')) or \
           (player1 == 'paper' and (player2 == 'rock' or player2 == 'Spock')) or \
           (player1 == 'scissors' and (player2 == 'paper' or player2 == 'lizard')) or \
           (player1 == 'lizard' and (player2 == 'paper' or player2 == 'Spock')) or \
           (player1 == 'Spock' and (player2 == 'scissors' or player2 == 'rock')):
            return self.players[0]
        return self.players[1]

    def update_score(self, result):
        if result == 'tie':
            self.score[self.players[0]]['ties'] += 1
            self.score[self.players[1]]['ties'] += 1
        else:
            self.score[result]['wins'] += 1
            self.score[self.get_opponent(result)]['losses'] += 1

    def get_opponent(self, player):
        return self.players[0] if player == self.players[1] else self.players[1]

    def display_score(self):
        print("Score:")
        for player in self.players:
            print(f"{player}: {self.score[player]['wins']} wins, {self.score[player]['losses']} losses, {self.score[player]['ties']} ties")

    def play_game(self):
        while True:
            self.play_round()
            self.display_score()
            play_again = input("Do you want to play again? (y/n): ").lower()
            if play_again != 'y':
                break

players = ['Player 1', 'Player 2']
game = Game(players)
game.play_game()


import sys
import traceback

def debug_statement():
    """
    This function prints the error message and the line number where the error occurred.
    It uses the sys and traceback modules to extract the error information.
    It can handle nested function calls and accurately identify the line number within the correct function.
    """
    try:
        # This is where the code that could potentially raise an exception would go
        # For demonstration purposes, we'll just raise an exception manually
        raise Exception("This is a test exception")
    except Exception as e:
        # Extract the current execution frame
        current_frame = sys._getframe()
        
        # Extract the traceback from the exception
        tb = traceback.extract_tb(current_frame.tb)
        
        # The traceback contains a list of frames, we're interested in the last one (the most recent)
        last_frame = tb[-1]
        
        # Print the error message and the line number
        print(f"Error: {str(e)} occurred at line {last_frame.lineno} in function {last_frame.name}")

# Test the debug statement
debug_statement()


import json

def sort_keys(json_obj):
    def count_vowels(s):
        return sum(1 for char in s.lower() if char in 'aeiou')

    def count_consonants(s):
        return sum(1 for char in s.lower() if char.isalpha() and char not in 'aeiou')

    def sum_ascii(s):
        return sum(ord(char) for char in s)

    def recursive_sort(obj):
        if isinstance(obj, list):
            for i in range(len(obj)):
                if isinstance(obj[i], str):
                    obj[i] = (obj[i], len(obj[i]), count_vowels(obj[i]), count_consonants(obj[i]), sum_ascii(obj[i]))
            obj.sort(key=lambda x: (-x[1], x[0]))
        elif isinstance(obj, dict):
            for key in obj:
                if isinstance(obj[key], (list, dict)):
                    recursive_sort(obj[key])
                elif isinstance(obj[key], str):
                    obj[key] = (obj[key], len(obj[key]), count_vowels(obj[key]), count_consonants(obj[key]), sum_ascii(obj[key]))
            obj = {key: obj[key] for key in sorted(obj, key=lambda x: (-obj[x][1], x))}
            for key in obj:
                if isinstance(obj[key], tuple):
                    obj[key] = obj[key][0]
        return obj

    parsed_obj = json.loads(json_obj)
    return recursive_sort(parsed_obj)


def row_sums(arr):
    sums = []
    for row in arr:
        row_sum = 0
        for num in row:
            if num > 0:
                row_sum += num
        sums.append(row_sum)
    return sums


class Day:
    WEEKDAYS = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    WEEKENDS = ['Saturday', 'Sunday']
    PUBLIC_HOLIDAYS = ['New Year\'s Day', 'Independence Day', 'Christmas Day']
    
    def __init__(self, day_name):
        if day_name.capitalize() in self.WEEKDAYS or day_name.capitalize() in self.WEEKENDS:
            self.day_name = day_name.capitalize()
        else:
            raise ValueError('Invalid day name')
    
    def get_day_name(self):
        return self.day_name
    
    def is_weekend(self):
        return self.day_name in self.WEEKENDS
    
    def is_weekday(self):
        return self.day_name in self.WEEKDAYS
    
    def is_public_holiday(self):
        return self.day_name in self.PUBLIC_HOLIDAYS


def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_select(arr, low, high, k):
    if low == high:
        return arr[low]
    
    pivot_index = partition(arr, low, high)
    
    if k == pivot_index:
        return arr[pivot_index]
    elif k < pivot_index:
        return quick_select(arr, low, pivot_index - 1, k)
    else:
        return quick_select(arr, pivot_index + 1, high, k)

def find_kth_smallest(arr, k):
    if k < 1 or k > len(arr):
        return None
    
    return quick_select(arr, 0, len(arr) - 1, k - 1)


def print_first_three_distinct_positive_positions(array):
    count = 0
    distinct_positions = []
    for num in array:
        if num > 0 and num not in distinct_positions:
            distinct_positions.append(num)
            count += 1
            if count == 3:
                break

    if count < 3:
        print("Array does not have three distinct positive positions.")
    else:
        print(distinct_positions)

array = [1, 2, -3, 4, 2, -1, 5, 0]
print_first_three_distinct_positive_positions(array)


def get_list_length(lst, depth=1):
    count = 0
    
    for item in lst:
        if isinstance(item, list) and depth < 5:
            count += get_list_length(item, depth + 1)
        else:
            count += 1
    
    return count

# Test the program
my_list = [1, 2, 3, [4, 5, [6, 7, [8, 9]]]]
length = get_list_length(my_list)
print("Length of the list:", length)


def is_prime(n):
    # Check if n is a decimal or negative number
    if n <= 1 or n % 1 != 0:
        return False
    
    # Check if n is divisible by any number from 2 to sqrt(n)
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    
    # n is a prime number
    return True


def classify_concepts(concepts):
    positive_words = ['love', 'like', 'adore', 'happy', 'joy', 'smile']
    negative_words = ['hate', 'dislike', 'angry', 'sad', 'depressed', 'cry']
    neutral_words = ['peace', 'calm', 'serene', 'tranquil', 'balance', 'harmony']
    categories = []
    for concept in concepts:
        if concept.lower() in positive_words:
            categories.append((concept, 'positive'))
        elif concept.lower() in negative_words:
            categories.append((concept, 'negative'))
        elif concept.lower() in neutral_words:
            categories.append((concept, 'neutral'))
        else:
            categories.append((concept, 'unknown'))
    return categories


class VirtualMemory:
    def __init__(self, page_table_size, page_size):
        self.page_table_size = page_table_size
        self.page_size = page_size
        self.page_table = {}
        self.page_frames = []
    
    def translate_virtual_to_physical(self, virtual_address):
        page_number = virtual_address // self.page_size
        offset = virtual_address % self.page_size
        
        if page_number in self.page_table:
            page_frame_number = self.page_table[page_number]
        else:
            page_frame_number = self.handle_page_fault(page_number)
        
        physical_address = (page_frame_number * self.page_size) + offset
        return physical_address
    
    def handle_page_fault(self, page_number):
        if len(self.page_frames) < self.page_table_size:
            # If there are empty page frames, allocate a new one
            page_frame_number = len(self.page_frames)
            self.page_frames.append(page_frame_number)
        else:
            # Apply the page replacement algorithm (e.g., least recently used or random)
            page_frame_number = self.page_replacement_algorithm(page_number)
        
        # Update the page table
        self.page_table[page_number] = page_frame_number
        
        return page_frame_number
    
    def page_replacement_algorithm(self, page_number):
        # Perform the page replacement algorithm (e.g., least recently used or random)
        # and return the selected page frame number
        # ...
        pass


def is_greater(num1, num2):
    if isinstance(num1, int) and isinstance(num2, int):
        if num1 > num2:
            return True
        else:
            return False
    else:
        raise ValueError("Error: Invalid input. Please provide two integers as input.")


def count_unique_characters(input_string):
    unique_chars = set()
    is_quoted = False
    
    for char in input_string:
        if char == '"':
            is_quoted = not is_quoted
        elif not is_quoted:
            unique_chars.add(char)
    
    return len(unique_chars)


def sum_positive_even(arr):
    # Initialize the sum to 0
    sum = 0

    # Iterate through each element in the array
    for num in arr:
        # Check if the number is positive and even
        if num > 0 and num % 2 == 0:
            # Add the number to the sum
            sum += num

    # Return the sum
    return sum


class StreamingInterface:
    def __init__(self):
        self.numbers = []
        self.count = 0
        self.sum = 0
        self.max_number = float('-inf')
        self.min_number = float('inf')
        self.frequency = {}

    def add_number(self, number):
        if self.count == 10000:
            # Remove the oldest number from the data structure
            oldest_number = self.numbers.pop(0)
            self.count -= 1
            self.sum -= oldest_number
            self.frequency[oldest_number] -= 1
            if self.frequency[oldest_number] == 0:
                del self.frequency[oldest_number]

        self.numbers.append(number)
        self.count += 1
        self.sum += number
        self.max_number = max(self.max_number, number)
        self.min_number = min(self.min_number, number)
        self.frequency[number] = self.frequency.get(number, 0) + 1

    def get_sum(self):
        return self.sum

    def get_average(self):
        return self.sum / self.count

    def get_maximum(self):
        return self.max_number

    def get_minimum(self):
        return self.min_number

    def get_median(self):
        sorted_numbers = sorted(self.numbers)
        length = len(sorted_numbers)
        if length % 2 == 0:
            return (sorted_numbers[length // 2 - 1] + sorted_numbers[length // 2]) / 2
        else:
            return sorted_numbers[length // 2]

    def get_mode(self):
        max_frequency = max(self.frequency.values())
        mode = [number for number, freq in self.frequency.items() if freq == max_frequency]
        return mode[0] if mode else None

    def remove_all(self):
        self.numbers = []
        self.count = 0
        self.sum = 0
        self.max_number = float('-inf')
        self.min_number = float('inf')
        self.frequency = {}

    def is_present(self, number):
        return number in self.numbers

    def get_count(self, number):
        return self.frequency.get(number, 0)

    def get_numbers_in_ascending_order(self):
        return sorted(self.numbers)


def reverse_linked_list(head):
    # Check if the list is empty or has only one node
    if head is None or head.next is None:
        return head

    # Initialize three pointers: prev, curr, and next
    prev = None
    curr = head
    next_node = None

    # Traverse the list and reverse the pointers
    while curr is not None:
        next_node = curr.next
        curr.next = prev
        curr.prev = next_node
        prev = curr
        curr = next_node

    # Return the new head of the reversed list
    return prev


def sum_odd_numbers(n):
    # Base case: if n is 1, return 1 (the only odd number less than or equal to 1)
    if n == 1:
        return 1
    # Recursive case: if n is odd and not a multiple of 3, add it to the sum
    if n % 2 == 1 and n % 3 != 0:
        return n + sum_odd_numbers(n - 1)
    # Recursive case: if n is even or a multiple of 3, skip it and move to the next number
    else:
        return sum_odd_numbers(n - 1)


def generate_dictionary(a, b, c):
    # Check if the values are integers
    if not all(value.isdigit() for value in (a, b, c)):
        raise ValueError("All values must be integers")

    # Convert values to integers
    a, b, c = int(a), int(b), int(c)

    # Check if the values are prime numbers
    if not all(is_prime(value) for value in (a, b, c)):
        raise ValueError("All values must be prime numbers")

    # Check if the values are palindromic numbers
    if not all(is_palindrome(value) for value in (a, b, c)):
        raise ValueError("All values must be palindromic numbers")

    # Generate and return the dictionary
    return {'a': a, 'b': b, 'c': c}

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def is_palindrome(num):
    return str(num) == str(num)[::-1]


def retrieve_unique_elements(arr):
    freq_dict = {}

    # Step 1: Count the frequency of each element in the array
    for element in arr:
        if element in freq_dict:
            freq_dict[element] += 1
        else:
            freq_dict[element] = 1

    unique_elements = []

    # Step 2: Iterate through the dictionary and retrieve elements with frequency 1
    for key, value in freq_dict.items():
        if value == 1:
            unique_elements.append(key)

    return unique_elements


def is_prime(n):
    if n <= 1:
        return False
    elif n <= 3:
        return True
    elif n % 2 == 0:
        return False
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True


import cmath

def evaluate_quadratic_equation(a, b, c):
    try:
        # Check if coefficients are numeric
        a, b, c = float(a), float(b), float(c)
        
        # Check if coefficients are within range
        if abs(a) > 1e100 or abs(b) > 1e100 or abs(c) > 1e100:
            raise ValueError("Coefficients are too large or too small.")
        
        # Calculate discriminant
        discriminant = b**2 - 4*a*c
        
        # Calculate real and complex roots
        root1 = (-b + cmath.sqrt(discriminant)) / (2*a)
        root2 = (-b - cmath.sqrt(discriminant)) / (2*a)
        
        return round(root1.real, 15), round(root1.imag, 15), round(root2.real, 15), round(root2.imag, 15)
    
    except (ValueError, TypeError):
        return "Invalid input: coefficients must be numeric."
    
    except ZeroDivisionError:
        return "Invalid input: coefficient 'a' cannot be zero."


def get_name(data):
    # Step 1: Check if the key "name" exists in the JSON object
    if "name" in data:
        # Step 2: Retrieve the value of the key "name" from the nested "person" dictionary
        return data["person"]["name"]
    elif isinstance(data, dict):
        # Step 3: Check if the JSON object is nested
        for key in data:
            # Step 4: Recursively call the function to handle nested JSON objects
            result = get_name(data[key])
            if result is not None:
                return result
    # Step 5: Return None if the key "name" does not exist
    return None


def specialArray(nums):
    max_val = max(nums)
    for x in range(1, max_val + 1):
        count = sum([1 for num in nums if num >= x])
        if count == x:
            return x
    return -1


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def getDecimalValue(head: ListNode) -> int:
    num = 0
    while head:
        num = (num << 1) | head.val
        head = head.next
    return num


import requests
from bs4 import BeautifulSoup

def get_title_and_description(url):
    try:
        # Send a GET request to the URL
        response = requests.get(url)
        
        # Parse the HTML content using BeautifulSoup
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Get the title meta tag
        title_tag = soup.find('title')
        title = title_tag.string if title_tag else "N/A"
        
        # Get the description meta tag
        description_tag = soup.find('meta', attrs={'name': 'description'})
        description = description_tag['content'] if description_tag else "N/A"
        
        return title, description
    
    except Exception as e:
        print(f"An error occurred: {e}")
        return "N/A", "N/A"

# Test the function
url = "https://en.wikipedia.org/wiki/Artificial_intelligence"
title, description = get_title_and_description(url)
print(f"Title: {title}")
print(f"Description: {description}")


def gcd(a, b):
    """
    This function calculates the greatest common divisor (gcd) of two numbers using the Euclidean Algorithm.
    The Euclidean Algorithm is based on the principle that the gcd of two numbers a and b is the same as the gcd of b and a%b.
    It uses a while loop to repeatedly calculate the remainder until b becomes 0, at which point a is the gcd.
    The time complexity is O(log(min(a, b))) because each iteration approximately halves the size of the larger number.
    The space complexity is O(1) because no additional data structures are used.
    """
    while b != 0:
        a, b = b, a % b  # Swap a and b with b and a%b
    return a  # When b becomes 0, a is the gcd

print(gcd(5678934, 987231))  # Expected output: 13


def find_index(lst, element, index=0):
    if index == len(lst):
        return -1

    if lst[index] == element:
        return index

    if isinstance(lst[index], list):
        sublist_index = find_index(lst[index], element)
        if sublist_index != -1:
            return index

    return find_index(lst, element, index + 1)

my_list = [2, 5, [6, 8], 8, 10, [8, 12]]
element = [8]
index = find_index(my_list, element)
print(index)


import random
# List of animal-related words
animal_words = ["cat", "bird", "fish", "monkey", "elephant"]
# List of suffix options
suffix_options = ["-y", "-ish", "-esque"]
# Generate random word and suffix
random_word = random.choice(animal_words)
random_suffix = random.choice(suffix_options)
# Generate punchline
punchline = f"To get to the {random_word}{random_suffix}!"
# Print joke
print("Q: Why did the dog walk into the bar?")
print(f"A: {punchline}")


from typing import List, Union, Optional

class MedianCalculator:
    def __init__(self, numbers: List[Union[int, float]]):
        self.numbers = numbers

    def get_median(self) -> Optional[Union[int, float]]:
        numbers = [num for num in self.numbers if isinstance(num, (int, float))]
        numbers.sort()
        length = len(numbers)

        if length == 0:
            return None

        if length % 2 == 1:
            return numbers[length // 2]
        else:
            return (numbers[length // 2 - 1] + numbers[length // 2]) / 2


def are_anagrams(str1, str2):
    # Convert the strings to lowercase
    str1 = str1.lower()
    str2 = str2.lower()

    # Check if the lengths are different
    if len(str1) != len(str2):
        return False

    # Initialize the count arrays
    count1 = [0] * 26
    count2 = [0] * 26

    # Count the occurrences of each character in str1 and str2
    for i in range(len(str1)):
        count1[ord(str1[i]) - ord('a')] += 1
        count2[ord(str2[i]) - ord('a')] += 1

    # Compare the count arrays
    for i in range(26):
        if count1[i] != count2[i]:
            return False

    return True


def elements_in_a_not_in_b(a, b):
    result = []
    for element in a:
        if element not in b:
            result.append(element)
    result.sort()
    return result

a = [1, 3, 5, 7, 9]
b = [2, 4, 6, 8]
output = elements_in_a_not_in_b(a, b)
print(output)


def flatten(root):
    if not root:
        return
    flatten(root.left)
    flatten(root.right)
    if root.left:
        temp = root.right
        root.right = root.left
        root.left = None
        while root.right:
            root = root.right
        root.right = temp


attempts = 0
valid_input = False

while not valid_input:
    user_input = input("Enter a valid positive integer between 1 and 1000: ")
    attempts += 1

    if user_input.isdigit():
        number = int(user_input)
        if 1 <= number <= 1000:
            valid_input = True

if valid_input:
    print("Valid input! Number of attempts:", attempts)


def calculate_statistics(arr):
    # Check if input array is empty
    if not arr:
        return "Input array is empty."

    # Check if input array contains only positive integers
    if not all(isinstance(num, int) and num > 0 for num in arr):
        return "Input array must contain only positive integers."

    # Calculate mean
    mean = round(sum(arr) / len(arr), 2)

    # Calculate median
    sorted_arr = sorted(arr)
    mid = len(arr) // 2
    if len(arr) % 2 == 0:
        median = (sorted_arr[mid - 1] + sorted_arr[mid]) / 2
    else:
        median = sorted_arr[mid]

    # Calculate mode
    freq = {}
    max_freq = 0
    mode = []
    for num in arr:
        if num not in freq:
            freq[num] = 0
        freq[num] += 1
        if freq[num] > max_freq:
            max_freq = freq[num]
            mode = [num]
        elif freq[num] == max_freq:
            mode.append(num)

    # Return the result as a string
    return f"Mean: {mean}, Median: {median}, Mode: {', '.join(str(num) for num in mode)}"

# Example usage:
print(calculate_statistics([1, 2, 3, 4, 5]))  # Mean: 3.0, Median: 3, Mode: 1, 2, 3, 4, 5
print(calculate_statistics([1, 2, 3, 4, 4, 5, 5, 5]))  # Mean: 3.5, Median: 4, Mode: 5
print(calculate_statistics([1, 1, 2, 2, 3, 3, 4, 4]))  # Mean: 2.5, Median: 2.5, Mode: 1, 2, 3, 4
print(calculate_statistics([-1, 2, 3, 4, 5]))  # Input array must contain only positive integers.
print(calculate_statistics([]))  # Input array is empty.


import re

def count_word_occurrences(string, word):
    pattern = r'\b{}\b'.format(word)  # construct a regex pattern for whole word match
    matches = re.findall(pattern, string, re.IGNORECASE)  # find all matches using regex
    return len(matches)  # return the count of matches

# Example usage
string = "This is a programming task"
word = "is"
occurrences = count_word_occurrences(string, word)
print(occurrences)


def min_deletions(s):
    freq = collections.Counter(s)
    used = set()
    deletions = 0

    for count in freq.values():
        while count in used and count > 0:
            deletions += 1
            count -= 1
        used.add(count)

    return deletions


def recursive_function(n):
    if n == 0:
        return "Termination condition reached"
    elif n < 0:
        raise ValueError("Input must be a positive integer")
    else:
        try:
            return recursive_function(n - 1)
        except ValueError as error:
            return str(error)

def main_function(input_value):
    try:
        result = recursive_function(input_value)
        print("Result:", result)
    except Exception as error:
        print("An error occurred:", str(error))

# Testing with different data types
main_function(5)
main_function(0)
main_function(-3)
main_function("hello")
main_function([1, 2, 3])


employees = [
    {"name": "John", "age": 25, "salary": 35000},
    {"name": "Alice", "age": 35, "salary": 45000},
    {"name": "Bob", "age": 40, "salary": 50000},
    {"name": "Lisa", "age": 28, "salary": 42000},
    {"name": "Mike", "age": 32, "salary": 38000}
]

total_salary = 0

for employee in employees:
    salary = employee["salary"]
    age = employee["age"]
    
    if 40000 <= salary <= 50000 and 30 <= age <= 40:
        total_salary += salary

print("Total salary of employees meeting the conditions: ", total_salary)


def find_duplicates(arr):
    freq_dict = {}
    duplicates = []
    
    # Count the frequency of each element in the array
    for num in arr:
        if num in freq_dict:
            freq_dict[num] += 1
        else:
            freq_dict[num] = 1
    
    # Check which elements have a frequency greater than 1
    for num, freq in freq_dict.items():
        if freq > 1:
            duplicates.append(num)
    
    # Sort the duplicates in descending order
    duplicates.sort(reverse=True)
    
    return duplicates

# Test the code with the given example
arr = [1000000, 2, 400000, 2, 1000000, 500000]
print(find_duplicates(arr))


import http.client
from urllib.parse import urlparse

def make_http_request(url: str) -> str:
    try:
        # Parse the URL to extract the scheme, hostname, and path
        parsed_url = urlparse(url)
        scheme = parsed_url.scheme
        hostname = parsed_url.hostname
        path = parsed_url.path

        # Connect to the server
        if scheme == "https":
            conn = http.client.HTTPSConnection(hostname)
        else:
            conn = http.client.HTTPConnection(hostname)

        # Send an HTTP GET request
        conn.request("GET", path)

        # Get the response from the server
        response = conn.getresponse()

        # Check if the request was successful (status code 200)
        if response.status == 200:
            # Read and return the response body
            return response.read().decode("utf-8")
        else:
            # Return None if the request was not successful
            return None
    except Exception as e:
        # Return None if any exception occurred
        return None


def sum_of_points(s, answers):
    total_points = 0
    result = 0
    term = 1
    sign = "+"

    for char in s:
        if char.isdigit():
            number = int(char)
            if sign == "+":
                result += term
                term = number
            elif sign == "*":
                term *= number
        else:
            sign = char

    result += term

    for ans in answers:
        total_points += (ans == result)

    return total_points


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False  # Fixed return statement
    return True

def product_of_digits(num):
    product = 1
    for digit in str(num):
        product *= int(digit)
    return product

def find_prime_numbers(start, end):
    prime_products = []
    for num in range(start, end + 1):
        if is_prime(num):
            prime_products.append(product_of_digits(num))
    return prime_products

start_num = 1
end_num = 1000

prime_products = find_prime_numbers(start_num, end_num)
print(prime_products)


import re

def predict_next_word(pattern, sentence, max_distance):
    words = sentence.split()
    pattern_occurrences = [m.start() for m in re.finditer(pattern, sentence)]
    occurrences_within_distance = [occurrence for occurrence in pattern_occurrences if occurrence <= max_distance]
    
    if not occurrences_within_distance:
        return "Pattern not found in sentence."
    
    word_frequencies = {}
    for occurrence in occurrences_within_distance:
        next_word = words[occurrence + len(pattern) + 1]
        if next_word in word_frequencies:
            word_frequencies[next_word] += 1
        else:
            word_frequencies[next_word] = 1
    
    max_frequency = max(word_frequencies.values())
    predicted_words = [word for word, frequency in word_frequencies.items() if frequency == max_frequency]
    
    last_occurrence = max(occurrences_within_distance)
    closest_word = None
    closest_distance = float('inf')
    for word in predicted_words:
        distance = len(words) - last_occurrence - words[::-1].index(word)
        if distance < closest_distance:
            closest_distance = distance
            closest_word = word
    
    return closest_word

# Example usage:
pattern = "I am"
sentence = "I am feeling great. I am going to the park."
max_distance = 3

predicted_word = predict_next_word(pattern, sentence, max_distance)
print("Predicted word:", predicted_word)


def min_elements(nums, limit, goal):
    total_sum = sum(nums)
    diff = abs(goal - total_sum)
    return (diff + limit - 1) // limit


def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]

    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)

    return merge(left_half, right_half)

def merge(left_half, right_half):
    sorted_arr = []
    i = j = 0

    while i < len(left_half) and j < len(right_half):
        if left_half[i] <= right_half[j]:
            sorted_arr.append(left_half[i])
            i += 1
        else:
            sorted_arr.append(right_half[j])
            j += 1

    sorted_arr.extend(left_half[i:])
    sorted_arr.extend(right_half[j:])
    return sorted_arr

arr = [4, 2, 9, 10, 5]
sorted_arr = merge_sort(arr)
print(sorted_arr)


def delete_key(dictionary, key):
    if key not in dictionary:
        raise KeyError("Key not found in dictionary")
    count = 0
    for k in list(dictionary.keys()):
        if k == key:
            del dictionary[k]
            count += 1
    return count


from datetime import datetime, timedelta

def count_weekdays(date1, date2):
    # List of public holidays
    public_holidays = [
        datetime.strptime("1 May, 2020", "%d %B, %Y").date(),  # example public holiday
        # add more public holidays if needed
    ]
    
    # Convert input dates to datetime objects
    date1 = datetime.strptime(date1, "%d %B, %Y").date()
    date2 = datetime.strptime(date2, "%d %B, %Y").date()
    
    # Initialize count variable
    count = 0
    
    # Iterate through each date between date1 and date2
    current_date = date1
    while current_date <= date2:
        # Check if the date is a weekday and not a public holiday
        if current_date.weekday() < 5 and current_date not in public_holidays:
            count += 1
        
        # Move to the next date
        current_date += timedelta(days=1)
    
    return count

# Test the function
date1 = "27 April, 2020"
date2 = "8 May, 2020"
print(count_weekdays(date1, date2))  # Output: 10


def binary_search(arr, target):
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        
        if arr[mid] < target:
            low = mid + 1
        elif arr[mid] > target:
            high = mid - 1
        else:
            # Check if it's the first occurrence
            if mid == 0 or arr[mid-1] != target:
                return mid
            else:
                high = mid - 1
    
    return -1  # Target not found

# Example usage
arr = ['apple', 'banana', 'banana', 'cherry', 'date', 'date', 'date']
target = 'date'
index = binary_search(arr, target)

if index != -1:
    print(f"The first occurrence of {target} is at index {index}.")
else:
    print(f"{target} is not found in the array.")


import heapq

def modified_heapsort(arr):
    # Step 1: Build a min-heap using the input array
    heapq.heapify(arr)

    # Step 2: Create an empty result array
    result = []

    # Step 3: Extract minimum elements from the min-heap
    while arr:
        min_val = heapq.heappop(arr)
        result.append(min_val)

        # Check for duplicates and extract them as well
        while arr and arr[0] == min_val:
            result.append(heapq.heappop(arr))

    # Step 4: Return the result array
    return result


def calculate_volume(length, width, height):
    volume = length * width * height
    return round(volume, 2)

# Read input from user
length = int(input("Enter the length of the cuboid: "))
width = int(input("Enter the width of the cuboid: "))
height = int(input("Enter the height of the cuboid: "))

# Calculate and print the volume
volume = calculate_volume(length, width, height)
print("Volume =", volume)


def remove_duplicates(strings):
    unique_strings = []
    for string in strings:
        # Remove leading and trailing whitespace
        string = string.strip()
        # Convert string to lowercase for case-insensitive comparison
        string = string.lower()
        # Check if string is a palindrome
        if string == string[::-1]:
            continue
        # Check if string is already in unique_strings
        if string in unique_strings:
            continue
        # Add string to unique_strings
        unique_strings.append(string)
    return unique_strings


import numpy as np

def cosine_similarity(vector1, vector2):
    # Convert the vectors to numpy arrays
    vector1 = np.array(vector1)
    vector2 = np.array(vector2)

    # Compute the dot product of the vectors
    dot_product = np.dot(vector1, vector2)

    # Compute the magnitude of the vectors
    magnitude_vector1 = np.linalg.norm(vector1)
    magnitude_vector2 = np.linalg.norm(vector2)

    # Compute the cosine similarity
    cosine_similarity = dot_product / (magnitude_vector1 * magnitude_vector2)

    return cosine_similarity


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_first_n_primes(n):
    prime_count = 0
    num = 2
    sum_primes = 0
    while prime_count < n:
        if is_prime(num):
            sum_primes += num
            prime_count += 1
        num += 1
    return sum_primes

sum_of_primes = sum_first_n_primes(20)
print(sum_of_primes)


import random

array = [random.randint(0, 100) for _ in range(1000000)]


import math

def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_fibonacci(num):
    a, b = 0, 1
    while b < num:
        a, b = b, a + b
    return b == num

def calculate_difference(num1, num2):
    if is_prime(num1) and is_fibonacci(num2):
        if math.isqrt(num1)**2 == num1:  # Check if num1 is a perfect square
            difference = abs(num1 - num2)
        else:
            difference = -(num1 - num2)
        if difference % 3 == 0:
            return difference // 3
        else:
            return difference * 3
    else:
        return "The difference cannot be calculated."

# Example usage
print(calculate_difference(23, 13))  # Output: 10


from typing import Dict
from heapq import heappop, heappush

def rearrange_string(my_str: str) -> str:
    # Step 1: Count the frequency of each character
    freq_count = count_frequency(my_str)

    # Step 2: Create a priority queue
    pq = []

    # Step 3: Insert characters into the priority queue
    for char, freq in freq_count.items():
        heappush(pq, (freq, char))

    # Step 4: Initialize the rearranged string
    rearranged_str = ""

    # Step 5: Build the rearranged string
    while pq:
        freq1, char1 = heappop(pq)
        if rearranged_str and rearranged_str[-1] == char1:
            # If the last character in the rearranged string is the same as char1,
            # we need to pop another character from the priority queue
            freq2, char2 = heappop(pq)
            rearranged_str += char2
            freq2 -= 1
            if freq2 > 0:
                heappush(pq, (freq2, char2))
        rearranged_str += char1
        freq1 -= 1
        if freq1 > 0:
            heappush(pq, (freq1, char1))

    # Step 6: Return the rearranged string
    return rearranged_str

def count_frequency(s: str) -> Dict[str, int]:
    freq_count = {}
    for char in s:
        freq_count[char] = freq_count.get(char, 0) + 1
    return freq_count


def round_list(numbers):
    return [round(num, 4) for num in numbers]


def sum_greater_than_10_divisible_by_3(arr):
    # Initialize the sum
    total_sum = 0
    
    # Iterate through each row in the array
    for row in arr:
        # Iterate through each element in the row
        for num in row:
            # Check if the element is positive, greater than 10, and divisible by 3
            if num > 10 and num % 3 == 0:
                total_sum += num
    
    # Return the final sum
    return total_sum


def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def copy_smaller_primes(input_array, new_array, index):
    # Base cases
    if index == len(input_array) or len(new_array) == 5:
        return new_array
    
    # Recursive case
    if input_array[index] < 5 and is_prime(input_array[index]):
        new_array.append(input_array[index])
    
    return copy_smaller_primes(input_array, new_array, index + 1)

# Example usage
input_array = [2, 4, 3, 6, 1, 8, 7]
new_array = []
result = copy_smaller_primes(input_array, new_array, 0)
print(result)


count = 0

def increment():
    global count
    count += 1

def decrement():
    global count
    count -= 1

def print_count():
    global count
    print("Count:", count)

increment()
increment()
decrement()
print_count()  # Output: Count: 1


def min_operations(n):
    count = 1
    temp = 1

    while temp % n != 0:
        temp = (temp * 2) % n
        count += 1

    return count


import math

def find_prime_numbers(numbers):
    prime_numbers = []
    for num in numbers:
        if num > 100:
            is_prime = True
            for i in range(2, int(math.sqrt(num)) + 1):
                if num % i == 0:
                    is_prime = False
                    break
            if is_prime:
                prime_numbers.append(num)
    prime_numbers.sort()
    return prime_numbers


def insertion_sort(arr):
    n = len(arr)

    for i in range(1, n):
        key = arr[i]
        j = i - 1

        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1

        arr[j + 1] = key

    return arr


name = input("Enter your name: ")

greetings = {
    'John': 'Greetings, oh wise one!',
    'Jane': 'Greetings, oh mighty one!',
    'James': 'Greetings, oh great one!',
    'Mary': 'Greetings, oh fearless one!',
    'Michael': 'Greetings, oh courageous one!',
    'Melissa': 'Greetings, oh intelligent one!',
    'Matthew': 'Greetings, oh strong one!',
    'Megan': 'Greetings, oh noble one!',
    'Mark': 'Greetings, oh wise one!',
    'Mia': 'Greetings, oh powerful one!'
}

if name in greetings:
    print(greetings[name])
else:
    print("Hello " + name)


def sum_of_first_n_elements(arr, n):
    if n > len(arr):
        return 0
    else:
        return sum(arr[:n])

arr = [2, 4, 6, 8, 10]
n = 3
sum_of_first_n_elements(arr, n)


# List of strings
strings = ['Apple', 'BaNaNa', '1m0n', 'Cherry', 'dOg!', 'elephant', 'FruiT', 'grape']

# Set of special characters
special_characters = {'!', '@', '#', '$', '%'}

# List to store strings that meet the criteria
matching_strings = []

# Variable to keep track of the number of matching strings
count = 0

for string in strings:
    # Skip strings starting with a vowel
    if string[0].lower() in ['a', 'e', 'i', 'o', 'u']:
        continue
    
    # Check if the string contains a digit
    if any(char.isdigit() for char in string):
        break
    
    # Check if the string contains both uppercase and lowercase letters
    if any(char.islower() for char in string) and any(char.isupper() for char in string):
        # Check if the string contains at least one special character
        if any(char in special_characters for char in string):
            matching_strings.append(string)
            break
    
    # Increment the count of matching strings
    count += 1

# Display the number of strings that meet the criteria
print("Number of matching strings:", count)

# Display the list of strings that meet the criteria
print("Matching strings:", matching_strings)


def is_prime(n):
    """
    This function checks if a number is prime or not.
    It iterates from 2 to sqrt(n) and checks if n is divisible by any number in this range.
    If it is divisible, then n is not a prime number. Otherwise, it is a prime number.
    """
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    i = 3
    while i * i <= n:
        if n % i == 0:
            return False
        i += 2
    return True

def sum_of_primes(n):
    """
    This function calculates the sum of all prime numbers less than n.
    It iterates from 2 to n and checks if a number is prime or not using the is_prime function.
    If it is prime, then it adds the number to the sum.
    """
    sum = 0
    for i in range(2, n):
        if is_prime(i):
            sum += i
    return sum

def prime_factors(n):
    """
    This function finds the prime factors of n.
    It iterates from 2 to sqrt(n) and checks if n is divisible by any number in this range.
    If it is divisible, then the number is a prime factor of n.
    It also keeps track of the largest prime factor.
    """
    factors = []
    largest = 0
    while n % 2 == 0:
        factors.append(2)
        largest = 2
        n = n / 2
    for i in range(3, int(n**0.5)+1, 2):
        while n % i== 0:
            factors.append(i)
            largest = i
            n = n / i
    if n > 2:
        factors.append(n)
        largest = n
    return factors, largest

def prime_or_not(n):
    """
    This function determines whether a given number is prime or not.
    It also calculates the sum of all the prime numbers less than the given number.
    Additionally, it displays the prime factors of the number if it is not prime.
    """
    if is_prime(n):
        print(f"{n} is a prime number.")
        print(f"The sum of all prime numbers less than {n} is {sum_of_primes(n)}.")
    else:
        factors, largest = prime_factors(n)
        print(f"{n} is not a prime number.")
        print(f"The prime factors of {n} are {factors}.")
        print(f"The largest prime factor of {n} is {largest}.")


def count_unique_characters(string):
    # Convert the string to a character array
    characters = list(string)
    
    # Initialize count of non-unique characters
    non_unique_count = 0
    
    # Iterate through each character in the array
    for i in range(len(characters)):
        # Check if the character is already marked as non-unique
        if characters[i] == '':
            continue
        
        # Iterate through the rest of the array
        for j in range(i+1, len(characters)):
            # Check if the character is the same as any other character
            if characters[i] == characters[j]:
                # Mark the duplicate character as non-unique
                characters[j] = ''
                non_unique_count += 1
       
    # Count the number of unique characters
    unique_count = len(characters) - non_unique_count
    
    return unique_count


def validate_positive_integer_input(prompt):
    while True:
        try:
            value = int(input(prompt))
            if value > 0:
                return value
            else:
                print("Please enter a positive integer.")
        except ValueError:
            print("Please enter a valid integer.")

def print_multiplication_table(n, m, digits):
    # Print column labels
    print(" " * digits, end="\t")
    for j in range(1, m + 1):
        print(str(j).rjust(digits), end="\t")
    print()

    for i in range(1, n + 1):
        # Print row labels
        print(str(i).rjust(digits), end="\t")
        for j in range(1, m + 1):
            product = i * j
            print(str(product).rjust(digits), end="\t")
        print()

n = validate_positive_integer_input("Enter the value of n: ")
m = validate_positive_integer_input("Enter the value of m: ")
digits = validate_positive_integer_input("Enter the number of digits for each cell: ")

print("\nMultiplication Table:")
print_multiplication_table(n, m, digits)


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True


from collections import defaultdict

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def find_nodes_at_distance_k(root, target_val, k):
    if k < 0:
        return []

    parent_map = defaultdict(lambda: None)
    visited = set()
    target_node = initialize_parent_map(root, None, target_val, parent_map)

    result = []
    find_nodes_at_distance_k_helper(target_node, k, visited, parent_map, result)
    return result

def initialize_parent_map(node, parent, target_val, parent_map):
    if not node:
        return None
    if node.val == target_val:
        return node

    parent_map[node] = parent
    left = initialize_parent_map(node.left, node, target_val, parent_map)
    right = initialize_parent_map(node.right, node, target_val, parent_map)
    return left if left else right

def find_nodes_at_distance_k_helper(node, k, visited, parent_map, result):
    if not node or node in visited:
        return

    visited.add(node)
    if k == 0:
        result.append(node.val)
        return

    find_nodes_at_distance_k_helper(node.left, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(node.right, k-1, visited, parent_map, result)
    find_nodes_at_distance_k_helper(parent_map[node], k-1, visited, parent_map, result)


def convert_to_italics(sentence):
    # Split the sentence into individual words
    words = sentence.split()

    # Create an empty list to store the modified words
    modified_words = []

    # Iterate over each word in the sentence
    for word in words:
        # Check if the word is 'bold'
        if word.lower() == 'bold':
            # Convert the word to italics HTML tag
            modified_words.append('<i>' + word + '</i>')
        else:
            # Keep the word as is
            modified_words.append(word)

    # Join the modified words to form the updated sentence
    updated_sentence = ' '.join(modified_words)

    # Return the updated sentence
    return updated_sentence


# Test the function
sentence = "I am bold and I want to make the word 'bold' in italics as well"
updated_sentence = convert_to_italics(sentence)
print(updated_sentence)


def bubble_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n-1):
        
        # Last i elements are already in place
        for j in range(0, n-i-1):
            
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr


import math

def nthUglyNumber(n, a, b, c):
    left, right = 1, int(2e9)
    lcm_ab, lcm_ac, lcm_bc = a * b // math.gcd(a, b), a * c // math.gcd(a, c), b * c // math.gcd(b, c)
    lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)

    while left < right:
        mid = left + (right - left) // 2
        count = mid // a + mid // b + mid // c - mid // lcm_ab - mid // lcm_ac - mid // lcm_bc + mid // lcm_abc
        if count < n:
            left = mid + 1
        else:
            right = mid
    return left


def find_index(string_list, search_term):
    for i, string in enumerate(string_list):
        j = 0
        k = 0
        while j < len(string) and k < len(search_term):
            if search_term[k] == '*':
                # Handle wildcard case
                k += 1
                if k == len(search_term):
                    return i
                while j < len(string) and string[j] != search_term[k]:
                    j += 1
            elif string[j] == search_term[k]:
                # Handle exact match case
                j += 1
                k += 1
                if k == len(search_term):
                    return i
            else:
                # No match, reset to start of search term
                k = 0
                j += 1
    return -1


import datetime
import time

date_string = '1972-05-18 12:00 PM'

try:
    # Convert the date string to a datetime object
    date_obj = datetime.datetime.strptime(date_string, '%Y-%m-%d %I:%M %p')
    
    # Set the timezone to UTC
    utc_timezone = datetime.timezone.utc
    date_obj = date_obj.replace(tzinfo=utc_timezone)
    
    # Convert the datetime object to a UNIX timestamp
    unix_timestamp = int(date_obj.timestamp())
    
    print(unix_timestamp)

except ValueError as e:
    print(f"Error: {e}")


from bs4 import BeautifulSoup

def parse_html(html):
    result = {}
    soup = BeautifulSoup(html, 'html.parser')
    tags = soup.find_all()
    
    for tag in tags:
        tag_name = tag.name
        attributes = tag.attrs
        
        if tag_name not in result:
            result[tag_name] = {}
        
        for attr_name, attr_value in attributes.items():
            result[tag_name][attr_name] = attr_value
        
        if tag.find_all():
            nested_result = parse_html(str(tag))
            for nested_tag_name, nested_attributes in nested_result.items():
                nested_key = f'{tag_name}.{nested_tag_name}'
                result[nested_key] = nested_attributes
    
    return result


import json

def encrypt(value):
    # Custom encryption algorithm (you can replace this with your own)
    encrypted_value = value[::-1]  # reverse the string
    return encrypted_value

def decrypt(value):
    # Custom decryption algorithm (you need to implement the reverse process of encryption)
    decrypted_value = value[::-1]  # reverse the string back to original
    return decrypted_value

# Parameters to be encrypted
name = "John Doe"
age = 25

# Encrypt the parameters
encrypted_name = encrypt(name)
encrypted_age = encrypt(str(age))

# Construct the JSON object
json_object = {
    "encrypted_name": encrypted_name,
    "encrypted_age": encrypted_age
}

# Serialize the JSON object
json_string = json.dumps(json_object)
print(json_string)  # Output: {"encrypted_name": "eoD nhoJ", "encrypted_age": "52"}

# To decrypt the values
parsed_json = json.loads(json_string)
decrypted_name = decrypt(parsed_json["encrypted_name"])
decrypted_age = decrypt(parsed_json["encrypted_age"])

print(decrypted_name)  # Output: John Doe
print(decrypted_age)  # Output: 25


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True
def subtract_digits(a, b):
    return abs(sum(int(d) for d in str(a)) - sum(int(d) for d in str(b)))
def find_new_sequences(numbers):
    new_sequences = []
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            diff = subtract_digits(numbers[i], numbers[j])
            if is_prime(diff) and diff not in new_sequences:
                new_sequences.append(diff)
                if len(new_sequences) == 4:
                    return new_sequences
def main():
    original_sequence = [5, 7, 9, 11, 13, 15, 17, 19, 21]
    new_sequence = find_new_sequences(original_sequence)
    print("|Original Sequence| New Sequence |")
    print("|-----------------|--------------|")
    print(f"|{', '.join(str(n) for n in original_sequence)}| {', '.join(str(n) for n in new_sequence)}|")
if __name__ == '__main__':
    main()


def bubbleSort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr


import time

# Define the time difference between UTC and New York City's local time
time_difference = -4

# Get the current time in seconds since the epoch
current_time = time.time()

# Add the time difference to get New York City's local time in seconds since the epoch
new_york_time = current_time + (time_difference * 3600)

# Convert New York City's local time to a 24-hour format string
hours = int(new_york_time // 3600 % 24)
minutes = int(new_york_time // 60 % 60)
seconds = int(new_york_time % 60)
time_string = f"{hours:02}:{minutes:02}:{seconds:02}"

print("Current time in New York City:", time_string)


import re


def parseStringTo2DArray(input_string):
    result = []
    input_string = input_string.strip('[]')
    parts = input_string.split(", [")
    
    for part in parts:
        part = part.strip()
        
        if part[0] == '[' and part[-1] == ']':
            nested_array = parseStringTo2DArray(part)
            result.append(nested_array)
        else:
            elements = part.split(",")
            row = []
            
            for element in elements:
                element = element.strip()
                row.append(int(element))
            
            if len(result) > 0 and len(row) != len(result[0]):
                raise ValueError("Invalid input: Inconsistent number of elements in rows")
            
            result.append(row)
    
    return result

# Example usage
input_string = "[[1,2,3,4], [5,6,7,8], [9,10,11,12], [13,14,15,16]]"
result = parseStringTo2DArray(input_string)
print(result)


def count_vowels_and_consonants(string):
    vowels = "aeiouAEIOU"
    vowel_count = 0
    consonant_count = 0

    for char in string:
        if char.isalpha():
            if char in vowels:
                vowel_count += 1
            else:
                consonant_count += 1

    return vowel_count, consonant_count

my_str = "Hello World!"
vowels_count, consonants_count = count_vowels_and_consonants(my_str)

print("Number of vowels:", vowels_count)
print("Number of consonants:", consonants_count)


import re

def is_palindrome(s):
    # Remove non-alphanumeric characters using regex
    s = re.sub('[\W_]', '', s)
    
    # Convert to lowercase
    s = s.lower()
    
    # Check if the reversed string is equal to the original string
    return s == s[::-1]


class Point:
    def __init__(self, *coordinates):
        self.coordinates = coordinates

    def __add__(self, other):
        if len(self.coordinates) != len(other.coordinates):
            raise ValueError("Points must have the same number of dimensions.")

        sum_coordinates = []
        for coord1, coord2 in zip(self.coordinates, other.coordinates):
            sum_coordinates.append(coord1 + coord2)

        return Point(*sum_coordinates)


list = [1,2,3,4,5]

def calculate_sum(lst):
    total_sum = 0
    for num in lst:
        if not isinstance(num, int):
            raise TypeError("Invalid element in the list. Only integers are allowed.")
        if num < 0:
            raise ValueError("Invalid element in the list. Negative numbers are not allowed.")
        if num % 2 == 0:
            total_sum += num
    return total_sum

try:
    sum_of_even = calculate_sum(list)
    print("Sum of even numbers in the list:", sum_of_even)
except TypeError as te:
    print(te)
except ValueError as ve:
    print(ve)


def convert_seconds(seconds):
    year_seconds = 365.25 * 24 * 60 * 60  # Average seconds in a year accounting for leap years
    month_seconds = (365.25 * 24 * 60 * 60) / 12  # Average seconds in a month accounting for leap years
    week_seconds = 7 * 24 * 60 * 60  # Seconds in a week
    day_seconds = 24 * 60 * 60  # Seconds in a day
    hour_seconds = 60 * 60  # Seconds in an hour
    minute_seconds = 60  # Seconds in a minute

    years = seconds // year_seconds
    seconds %= year_seconds

    months = seconds // month_seconds
    seconds %= month_seconds

    weeks = seconds // week_seconds
    seconds %= week_seconds

    days = seconds // day_seconds
    seconds %= day_seconds

    hours = seconds // hour_seconds
    seconds %= hour_seconds

    minutes = seconds // minute_seconds
    seconds %= minute_seconds

    return f"{int(years)} years, {int(months)} months, {int(weeks)} weeks, {int(days)} days, {int(hours)} hours, {int(minutes)} minutes, {int(seconds)} seconds"


import random

def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

def generate_prime_numbers(n, start, end, allow_repetition):
    prime_numbers = []
    while len(prime_numbers) < n:
        number = random.randint(start, end)
        if is_prime(number) and (allow_repetition or number not in prime_numbers):
            prime_numbers.append(number)
    return prime_numbers

def custom_sort(prime_numbers, order):
    if order == "asc":
        for i in range(len(prime_numbers)):
            for j in range(i+1, len(prime_numbers)):
                if prime_numbers[i] > prime_numbers[j]:
                    prime_numbers[i], prime_numbers[j] = prime_numbers[j], prime_numbers[i]
    elif order == "desc":
        for i in range(len(prime_numbers)):
            for j in range(i+1, len(prime_numbers)):
                if prime_numbers[i] < prime_numbers[j]:
                    prime_numbers[i], prime_numbers[j] = prime_numbers[j], prime_numbers[i]
    return prime_numbers

def main():
    try:
        n = int(input("Enter the number of prime numbers to generate: "))
        start = int(input("Enter the starting number of the range: "))
        end = int(input("Enter the ending number of the range: "))
        allow_repetition = input("Allow repetition of numbers? (yes/no): ").lower() == "yes"
        order = input("Sort the generated list in ascending or descending order? (asc/desc): ").lower()

        if n <= 0 or start >= end:
            print("Invalid input. Please enter valid values.")
            return

        prime_numbers = generate_prime_numbers(n, start, end, allow_repetition)
        prime_numbers = custom_sort(prime_numbers, order)

        print("Generated prime numbers:", prime_numbers)

    except ValueError:
        print("Invalid input. Please enter integer values.")

if __name__ == "__main__":
    main()


class Car:
    def __init__(self, brand, model, year, color, speed):
        self.brand = brand
        self.model = model
        self.year = year
        self.color = color
        self.speed = speed

    def accelerate(self, amount):
        self.speed += amount

    def brake(self, amount):
        self.speed -= amount

    def get_speed(self):
        return self.speed

    def get_info(self):
        return f"Brand: {self.brand}, Model: {self.model}, Year: {self.year}, Color: {self.color}, Speed: {self.speed}"


class ElectricCar(Car):
    def __init__(self, brand, model, year, color, speed, battery_capacity, battery_level):
        super().__init__(brand, model, year, color, speed)
        self.battery_capacity = battery_capacity
        self.battery_level = battery_level

    def charge(self, amount):
        self.battery_level += amount

    def discharge(self, amount):
        self.battery_level -= amount

    def get_battery_level(self):
        return self.battery_level


# Create instances of Car and ElectricCar classes
car1 = Car("Toyota", "Camry", 2020, "Red", 0)
car2 = Car("Honda", "Accord", 2018, "Blue", 0)

electric_car1 = ElectricCar("Tesla", "Model S", 2021, "Black", 0, 100, 50)
electric_car2 = ElectricCar("Nissan", "Leaf", 2019, "White", 0, 80, 30)

# Test car methods
car1.accelerate(30)
car2.brake(10)

# Test electric car methods
electric_car1.accelerate(20)
electric_car1.charge(30)
electric_car2.brake(5)
electric_car2.discharge(10)

# Test get_info method
print(car1.get_info())
print(electric_car2.get_info())


import pandas as pd
import numpy as np


# Mapper function
def mapper(line):
    data = line.split(',')  # Assuming the dataset is comma-separated
    user_id = data[0]
    age = int(data[1])
    
    if age >= 18:
        yield None, age


def add_numbers(*args):
    if any(arg <= 0 for arg in args):
        raise ValueError("Parameters must be positive integers")

    if any(arg == 0 for arg in args):
        raise ValueError("Parameters cannot be zero")

    sum_result = sum(args)
    sum_result = round(sum_result, 2)

    if sum_result > 1000000:
        sum_result = "{:.2e}".format(sum_result)
    elif sum_result < 0:
        sum_result = str(sum_result)

    return float(sum_result)


import threading

class Account:
    def __init__(self, account_number):
        self.account_number = account_number
        self.balance = 0
        self.transaction_history = []
        self.lock = threading.Lock()
    
    def deposit(self, amount):
        with self.lock:
            self.balance += amount
            self.transaction_history.append(f"Deposit of {amount}")
    
    def withdraw(self, amount):
        with self.lock:
            if self.balance >= amount:
                self.balance -= amount
                self.transaction_history.append(f"Withdrawal of {amount}")
    
    def transfer(self, amount, recipient_account):
        with self.lock, recipient_account.lock:
            if self.balance >= amount:
                self.balance -= amount
                recipient_account.balance += amount
                self.transaction_history.append(f"Transfer of {amount} to account {recipient_account.account_number}")
                recipient_account.transaction_history.append(f"Transfer of {amount} from account {self.account_number}")
    
    def get_balance(self):
        return self.balance
    
    def get_transaction_history(self):
        return self.transaction_history

class Bank:
    def __init__(self):
        self.accounts = {}
        self.lock = threading.Lock()
    
    def create_account(self):
        with self.lock:
            account_number = generate_unique_account_number()
            account = Account(account_number)
            self.accounts[account_number] = account
            return account
    
    def get_account(self, account_number):
        return self.accounts.get(account_number)
    
    def generate_unique_account_number(self):
        # Use a cryptographically secure algorithm to generate a unique account number
        pass

# Usage example
bank = Bank()
account1 = bank.create_account()
account2 = bank.create_account()

account1.deposit(1000)
account2.deposit(500)

account1.transfer(500, account2)

print(account1.get_balance())  # Output: 500
print(account2.get_balance())  # Output: 1000

print(account1.get_transaction_history())  # Output: ['Deposit of 1000', 'Transfer of 500 to account 2']
print(account2.get_transaction_history())  # Output: ['Deposit of 500', 'Transfer of 500 from account 1']


numbers = [3, 1, 4, 2, 5]
numbers.sort()
print(numbers)  # Output: [1, 2, 3, 4, 5]


# Step 8: Validate input
def validateInput(num):
    if not isinstance(num, int) or num < 0:
        print("Error: Invalid input!")
        exit()

# Step 4: Define recursive function
def convertToHex(num):
    # Step 10: Handle special cases
    if num < 0:
        print("Error: Invalid input!")
        exit()
    if num == 0:
        return '0'
    
    hex_map = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F'}
    
    remainder = num % 16
    # Step 11: Convert remainder to hexadecimal character
    if remainder > 9:
        remainder = hex_map[remainder]
        
    hex_value = convertToHex(num // 16) + str(remainder)
    return hex_value

# Step 9: Validate input before conversion
num = 67
validateInput(num)

# Step 5: Call the convertToHex function
hex_value = convertToHex(num)

# Step 6: Print the hexadecimal value
print(hex_value)

# Step 12: Test the program with different inputs
num = -5
validateInput(num) # Should display "Error: Invalid input!"

num = 0
hex_value = convertToHex(num)
print(hex_value) # Should print "0"

num = 256
hex_value = convertToHex(num)
print(hex_value) # Should print "100"


def fibonacci_sum(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1

    fib_sum = 1
    fib_prev = 1

    for i in range(2, n):
        fib_next = fib_sum + fib_prev
        fib_sum += fib_next
        fib_prev = fib_next

    return fib_sum


import random

def generate_random_string(characters):
    vowels = ['e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
    vowel_count = sum(char in vowels for char in characters)
    
    if vowel_count == 0:
        raise ValueError("Input string must contain at least one vowel (excluding 'a')")
    
    length = vowel_count - 1
    random_string = ''
    
    while length > 0:
        char = random.choice(characters)
        if char != 'a' and char not in random_string:
            random_string += char
            length -= 1
    
    return random_string

characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
random_string = generate_random_string(characters)
print(random_string)


number = 15645

if 10000 <= number <= 20000 and all(number % i != 0 for i in range(2, int(number**0.5)+1)) and number % 3 == 0 and number % 5 == 0:
    print("The number is a prime number within the range of 10,000 to 20,000 and is divisible by both 3 and 5.")
else:
    print("The number does not meet all the given conditions.")


import pandas as pd
# create a sample DataFrame
employee_data = {'name': ['John', 'Jane', 'Mike', 'Emily', 'David'],
                 'department': ['Sales', 'Marketing', 'Sales', 'Marketing', 'Engineering'],
                 'birth_date': ['1990-05-10', '1988-02-20', '1992-09-15', '1991-11-30', '1989-07-05']}
df = pd.DataFrame(employee_data)
# convert birth_date column to datetime format
df['birth_date'] = pd.to_datetime(df['birth_date'])
# create a new column for birth year
df['birth_year'] = df['birth_date'].dt.year
# group employees by birth year and department
grouped = df.groupby(['birth_year', 'department'])['name'].apply(list)
# print the result
print(grouped)


import re

string = "happy happy"
find = "p"
replace = "s"
pattern = "py"

# Create a regular expression pattern
regex = re.compile(find + "(?!" + pattern + ")")

# Use the pattern to replace all occurrences of "p" that are not followed by "py"
edited_string = regex.sub(replace, string)

print(edited_string)


import datetime

def print_human_readable_date():
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    
    today = datetime.date.today()
    
    day_of_week = days[today.weekday()]
    month = months[today.month - 1]
    day = str(today.day).zfill(2)
    year = str(today.year)
    
    print("{}, {} {}, {}".format(day_of_week, month, day, year))

print_human_readable_date()


def reverse_vowels(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    vowel_list = []
    
    for char in string:
        if char.lower() in vowels:
            vowel_list.append(char)
    
    vowel_list.reverse()
    
    modified_string = ""
    for char in string:
        if char.lower() in vowels:
            modified_string += vowel_list[0]
            vowel_list.pop(0)
        else:
            modified_string += char
    
    return modified_string


input_string = input("Enter a string: ")
reversed_string = reverse_vowels(input_string)
print("Reversed string:", reversed_string)


def sum_of_primes(lst):
    primes = []
    for num in lst:
        if num > 100 and num < 1000:
            is_prime = True
            for i in range(2, int(num**0.5) + 1):
                if num % i == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(num)
    
    if len(primes) == 0:
        return 0
    else:
        return sum(primes), len(primes)


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

def delete_node(node):
    if node.prev is None:  # Node is the first node
        node.next.prev = None
    elif node.next is None:  # Node is the last node
        node.prev.next = None
    else:  # Node is any other node
        node.prev.next = node.next
        node.next.prev = node.prev
    del node

# Test the function
# Create a doubly linked list: 1 <-> 2 <-> 3 <-> 4
head = Node(1)
node2 = Node(2)
node3 = Node(3)
node4 = Node(4)

head.next = node2
node2.prev = head
node2.next = node3
node3.prev = node2
node3.next = node4
node4.prev = node3

# Delete the second node (2)
delete_node(node2)

# Print the updated linked list
current = head
while current is not None:
    print(current.data)
    current = current.next


def count_parameters(url):
    count = 0
    nestedCount = 0
    
    for char in url:
        if char == '?':
            nestedCount += 1
        elif char == '&' and nestedCount == 0:
            count += 1
        elif char == '[' and nestedCount == 0:
            count += 1
        elif char == ']' and nestedCount == 0:
            count -= 1
        elif char == '[' and nestedCount > 0:
            nestedCount += 1
        elif char == ']' and nestedCount > 0:
            nestedCount -= 1
            
    return count


# Seven-day forecast temperatures
temperatures = [32, 35, 28, 34, 30, 33, 31]

# Calculate average temperature
average_temp = sum(temperatures) / len(temperatures)

# Find the day with the highest temperature
max_temp = max(temperatures)
max_temp_day = temperatures.index(max_temp) + 1

# Find the day with the lowest temperature
min_temp = min(temperatures)
min_temp_day = temperatures.index(min_temp) + 1

# Print the results
print("Average temperature for today:", average_temp)
print("Day with the highest temperature:", max_temp_day)
print("Day with the lowest temperature:", min_temp_day)


def union(set1, set2):
    union = []
    for element in set1:
        if element not in union:
            union.append(element)
    for element in set2:
        if element not in union:
            union.append(element)
    return union


def get_array_size_in_bytes(array):
    n = len(array)
    size_in_bytes = n * 8
    return size_in_bytes


def sum_of_prime_numbers(n, m, x, y):
    primes = []  # list to store prime numbers
    num = m  # starting number
    
    while len(primes) < n:
        if num > x and num % y == 0:  # check if number is greater than x and divisible by y
            for i in range(2, num):
                if (num % i) == 0:  # check if number is divisible by any other number
                    break
            else:
                primes.append(num)  # if number is prime, add it to the list
        num += 1
    
    return sum(primes)  # return the sum of prime numbers


class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0


def tower_of_hanoi_iterative(n, source, destination, auxiliary):
    total_moves = pow(2, n) - 1
    forward = True if n % 2 == 0 else False

    moves_stack = Stack()
    moves_stack.push((n, source, destination, auxiliary))

    while not moves_stack.is_empty():
        disks, src, dest, aux = moves_stack.pop()

        if disks > 0:
            if forward:
                print_move(disks, src, dest)
            else:
                print_move(disks, dest, src)

            forward = not forward
            moves_stack.push((disks - 1, aux, dest, src))
            moves_stack.push((1, src, dest, aux))
            moves_stack.push((disks - 1, src, aux, dest))

    print("Total moves:", total_moves)


def print_move(disks, source, destination):
    print("Move disk", disks, "from", source, "to", destination)


# Example usage:
tower_of_hanoi_iterative(3, "A", "C", "B")


import requests
from bs4 import BeautifulSoup
from collections import Counter

# Make the HTTP request and get the content
url = "https://example.com"  # Replace with your desired URL
response = requests.get(url)
content = response.text

# Parse the HTML content and extract the top-level tags
soup = BeautifulSoup(content, "html.parser")
top_level_tags = [tag.name for tag in soup.find_all(recursive=False)]

# Count the occurrences of each top-level tag
tag_counts = Counter(top_level_tags)

# Filter tags with count less than 5
tag_counts = {tag: count for tag, count in tag_counts.items() if count >= 5}

# Sort the tags by count in descending order
sorted_tags = sorted(tag_counts.items(), key=lambda x: x[1], reverse=True)

# Display the tags and their respective counts
for tag, count in sorted_tags:
    print(f"{tag}: {count}")


def generate_permutations(nums):
    # Step 1: Sort the input list
    nums.sort()

    # Step 2: Create an empty list and set
    permutations = []
    visited = set()

    # Step 3: Initialize an empty stack
    stack = []

    # Step 4: Push the input list onto the stack
    stack.append((nums, 0))

    # Step 6: Generate permutations iteratively
    while stack:
        currentList, level = stack.pop()

        # Step 6.1: Check if a complete permutation is generated
        if level == len(currentList):
            # Step 6.1.1: Check if the permutation is not a duplicate
            permutation = tuple(currentList)
            if permutation not in visited:
                visited.add(permutation)
                permutations.append(list(permutation))
        else:
            # Step 6.2: Generate permutations by swapping elements
            for i in range(level, len(currentList)):
                # Swap elements at level and i
                currentList[level], currentList[i] = currentList[i], currentList[level]
                # Push the updated list and level onto the stack
                stack.append((list(currentList), level + 1))
                # Swap back elements at level and i to backtrack
                currentList[level], currentList[i] = currentList[i], currentList[level]

    # Step 7: Return the permutations sorted in lexicographic order
    return sorted(permutations)


def fibonacci(n):
    fib_sequence = [1, 1]  # Initialize with the first two numbers
    for i in range(2, n):
        fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
    return fib_sequence

# Print the first 10 Fibonacci numbers
fib_numbers = fibonacci(10)
for number in fib_numbers:
    print(number)


class Stack:
    """
    This class represents a stack data structure. It has methods for adding an item to the stack (push), 
    removing an item from the stack (pop), and checking if the stack is empty.
    """
    def __init__(self):
        """
        Initialize an empty stack.
        """
        self.stack = []

    def push(self, item):
        """
        Add an item to the top of the stack.
        """
        self.stack.append(item)

    def pop(self):
        """
        Remove and return the top item from the stack. If the stack is empty, raise an exception.
        """
        if not self.is_empty():
            return self.stack.pop()
        else:
            raise IndexError("Pop from empty stack")

    def is_empty(self):
        """
        Check if the stack is empty.
        """
        return len(self.stack) == 0


def findUniqueDuplicates(nums):
    # Create a dictionary to store the count of each number
    count = {}
    
    # Iterate over the input list and update the count for each number
    for num in nums:
        if num in count:
            count[num] += 1
        else:
            count[num] = 1
    
    # Create a list to store the unique duplicates
    unique_duplicates = []
    
    # Iterate over the count dictionary and add the numbers with count > 1 to the list
    for num, c in count.items():
        if c > 1:
            unique_duplicates.append(num)
    
    return unique_duplicates


import random

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def get_prime_factors(n):
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return list(set(factors))

while True:
    num = random.randint(0, 10000)
    if num % 7 == 0 and is_prime(num) and len(get_prime_factors(num)) >= 4:
        break

print("Random number:", num)


class MinHeap:
    def __init__(self):
        """
        Initialize an empty min heap.
        """
        self.heap = []

    def insert(self, val):
        """
        Insert an element into the heap.
        Time complexity: O(log n), where n is the number of elements in the heap.
        This is because in the worst case, we need to 'bubble up' the element to its correct position,
        which takes logarithmic time.
        """
        self.heap.append(val)  # add the new element to the end of the heap
        self._bubble_up(len(self.heap) - 1)  # 'bubble up' the element to its correct position

    def remove_min(self):
        """
        Remove and return the minimum element from the heap.
        Time complexity: O(log n), where n is the number of elements in the heap.
        This is because in the worst case, we need to 'bubble down' the new root element to its correct position,
        which takes logarithmic time.
        """
        if not self.heap:
            return None
        min_val = self.heap[0]  # the root of the heap is the minimum element
        self.heap[0] = self.heap[-1]  # replace the root with the last element in the heap
        self.heap.pop()  # remove the last element
        self._bubble_down(0)  # 'bubble down' the new root to its correct position
        return min_val

    def peek_min(self):
        """
        Return the minimum element from the heap without removing it.
        Time complexity: O(1), because the minimum element is always at the root of the heap.
        """
        return self.heap[0] if self.heap else None

    def update(self, old_val, new_val):
        """
        Change the value of a specific element in the heap.
        Time complexity: O(n), where n is the number of elements in the heap.
        This is because in the worst case, we need to find the element in the heap, which takes linear time.
        """
        if old_val not in self.heap:
            return
        index = self.heap.index(old_val)  # find the index of the element
        self.heap[index] = new_val  # update the value
        # 'bubble up' or 'bubble down' the element to its correct position
        self._bubble_up(index)
        self._bubble_down(index)

    def _bubble_up(self, index):
        """
        'Bubble up' the element at the given index to its correct position in the heap.
        """
        parent_index = (index - 1) // 2
        if index > 0 and self.heap[index] < self.heap[parent_index]:
            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]
            self._bubble_up(parent_index)

    def _bubble_down(self, index):
        """
        'Bubble down' the element at the given index to its correct position in the heap.
        """
        min_index = index
        left_child_index = 2 * index + 1
        right_child_index = 2 * index + 2
        if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[min_index]:
            min_index = left_child_index
        if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[min_index]:
            min_index = right_child_index
        if min_index != index:
            self.heap[index], self.heap[min_index] = self.heap[min_index], self.heap[index]
            self._bubble_down(min_index)


import re

def count_unique_words(passage):
    # Preprocessing: Remove line breaks and punctuation, convert to lowercase
    passage = passage.replace('\n', ' ')
    passage = re.sub(r'[^\w\s]', '', passage.lower())
    
    # Tokenize into words
    words = passage.split()
    
    # Count unique words
    unique_words = set(words)
    num_unique_words = len(unique_words)
    
    return num_unique_words

# Example usage:
passage = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit.
Nullam fermentum arcu in justo bibendum congue.
Pellentesque consequat nunc eu nunc viverra consectetur.
"""

num_unique_words = count_unique_words(passage)
print("Number of unique words:", num_unique_words)


def permuteUnique(s):
    def backtrack(start):
        if start == len(s) - 1:
            result.append(''.join(s))
            return
        seen = set()
        for i in range(start, len(s)):
            if s[i] in seen:
                continue
            seen.add(s[i])
            s[start], s[i] = s[i], s[start]
            backtrack(start + 1)
            s[start], s[i] = s[i], s[start]

    s = sorted(s)
    result = []
    backtrack(0)
    return result


# Test the code
input_str = "ABA"
print(permuteUnique(list(input_str)))


from collections import deque

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def level_order_reverse(root):
    if root is None:
        return

    queue = deque()
    queue.append(root)

    reversed_values = []
    average_values = []

    while queue:
        level_sum = 0
        level_count = 0
        level_nodes = []

        for _ in range(len(queue)):
            node = queue.popleft()
            level_nodes.append(node.value)
            level_sum += node.value
            level_count += 1

            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        reversed_values.append(level_nodes[::-1])
        average_values.append(level_sum / level_count)

    for i in range(len(reversed_values)):
        print("Level {}: {}".format(i+1, reversed_values[i]))
        print("Average Value: {}".format(average_values[i]))
        print()

# Test the algorithm
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

level_order_reverse(root)


def min_length_encoded(s: str, k: int) -> int:
    n = len(s)
    dp = [[0] * (k + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(k + 1):
            cnt = 1
            dp[i][j] = i - j
            l = i - 2
            while l >= 0 and i - 2 - l <= j:
                if s[l] == s[i - 1]:
                    cnt += 1
                else:
                    cnt = 1
                used = i - 2 - l
                new_aposition = i - 1 - cnt - used + 1
                if cnt >= 100:
                    new_aposition += 4
                elif cnt >= 10:
                    new_aposition += 3
                elif cnt >= 2:
                    new_aposition += 2
                else:
                    new_aposition += 1
                dp[i][j] = min(dp[i][j], new_aposition + dp[l][j - used])
                l -= 1

    return dp[n][k]


import itertools

# Define the possible outcomes of rolling a single die
dice_outcomes = [1, 2, 3, 4, 5, 6]

# Generate all possible outcomes of rolling three dice
all_outcomes = list(itertools.product(dice_outcomes, repeat=3))

# Calculate the product of each outcome and print it
for outcome in all_outcomes:
    product = outcome[0] * outcome[1] * outcome[2]
    print(f"Outcome: {outcome}, Product: {product}")


def rounded_product(array):
    product = 1

    for num in array:
        product *= num

    rounded_product = round(product)

    print("The rounded product of the array is:", rounded_product)


def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Flag to check if any swapping is done in this pass
        swapped = False
        
        # Last i elements are already in place
        for j in range(n - i - 1):
            # Swap adjacent elements if they are in the wrong order
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no swapping is done in this pass, the array is already sorted
        if not swapped:
            break

# Example usage
numbers = [5, 3, 8, 2, 1, 4]
bubble_sort(numbers)
print(numbers)


def delete_occurrences(str1, str2):
    # Convert the strings into lists of characters
    str1 = list(str1)
    str2 = list(str2)
    
    # Initialize pointers for str1 and str2
    i = 0
    j = 0
    
    # Loop through str1 and compare each character with str2
    while i < len(str1):
        # If the current characters match, increment both pointers
        if str1[i] == str2[j]:
            i += 1
            j += 1
            
            # If all characters in str2 have been matched, remove them from str1
            if j == len(str2):
                del str1[i - j : i]
                i -= j
                j = 0
        # If the current characters don't match, reset the pointer for str2
        else:
            i += 1
            j = 0
    
    # Convert the modified list back into a string and return it
    return ''.join(str1)


running_speed = 10 # km/h
cycling_speed = 30 # km/h
cycle_duration = 6 # minutes
rest_duration = 0.5 # minutes
for cycle in range(1, 6):
 print(f"Cycle {cycle}:")
 print(f" Running for 30 seconds at {running_speed} km/h")
 print(f" Rest for {rest_duration} minutes")
 print(f" Cycling for 30 seconds at {cycling_speed} km/h")
 print(f" Rest for {rest_duration} minutes")
 print(f" Total cycle duration: {cycle_duration} minutes")
 print()
print("Workout complete!")


infected_people = ["John", "Sara", "Mike"]
locations = {"John": ["Home", "Supermarket", "Office"], "Sara": ["Gym", "Office"], "Mike": ["Home", "Supermarket"]}
def contact_tracing(infected_people, locations):
    contacts = []
    for person in infected_people:
        for location in locations[person]:
            for other_person, other_locations in locations.items():
                if person != other_person and location in other_locations:
                    contacts.append(other_person)
    return set(contacts)
print(contact_tracing(infected_people, locations))


for num in range(100, -1, -1):
    print(num)


original_list = [1, 2, 3, 4, 5]  # Replace with your own list of integers

product_list = []  # Step 1

for i in range(len(original_list)):  # Step 2
    if i == len(original_list) - 1:  # Step 3
        continue
    product = original_list[i] * original_list[i+1]  # Step 4
    product_list.append(product)  # Step 5

print(product_list)  # Step 7


def reverse_string(s, i=0):
    if i == len(s) // 2:  # Base case: reached the middle of the string
        return s
    
    # Swap the characters at indices i and len(s)-i-1
    s = s[:i] + s[len(s)-i-1] + s[i+1:len(s)-i-1] + s[i] + s[len(s)-i:]
    
    return reverse_string(s, i+1)


def interpolation_search(arr, target):
    """
    This function implements the interpolation search algorithm to find the index of a given element in a sorted array.
    It first calculates the probable position of the target element based on the value of the element being searched and the values at the first and last indices of the array.
    If the target element is found at the probable position, it returns the index.
    If the target element is not found, it adjusts the search range based on whether the target is greater or smaller than the element at the probable position.
    If the target element is not present in the array, it returns -1.

    Args:
    arr: A sorted list of integers.
    target: An integer to be searched in the array.

    Returns:
    The index of the target element if it is present in the array, -1 otherwise.
    """
    
    low = 0  # Initialize the lower bound of the search range
    high = len(arr) - 1  # Initialize the upper bound of the search range

    while low <= high and target >= arr[low] and target <= arr[high]:
        # If the array contains only one element, return the low index
        if low == high:
            if arr[low] == target:
                return low
            return -1

        # Estimate the position of the target element
        pos = low + ((high - low) // (arr[high] - arr[low])) * (target - arr[low])

        # If the target element is found at the estimated position, return the position
        if arr[pos] == target:
            return pos

        # If the target element is larger, ignore the left half of the search range
        if arr[pos] < target:
            low = pos + 1

        # If the target element is smaller, ignore the right half of the search range
        else:
            high = pos - 1

    # If the target element is not present in the array, return -1
    return -1


from pyspark import SparkContext

# Create SparkContext
sc = SparkContext("local", "Array Count")

# Create RDD from array of integers
data = range(1, 1001)  # replace with your array of at least 1000 elements
rdd = sc.parallelize(data)

# Filter, map, and count positive integers greater than 10
filtered_rdd = rdd.filter(lambda x: x > 10)
count_rdd = filtered_rdd.countByValue()

# Sort in descending order
sorted_count_rdd = sc.parallelize(sorted(count_rdd.items(), key=lambda x: x[1], reverse=True))

# Print the sorted count
sorted_count_rdd.foreach(lambda x: print(x))


import random

def generate_random_number():
    num = 0
    while bin(num).count('1') != 4:
        num = random.randint(0, 15)
    return num

random_number = generate_random_number()
print(random_number)


def filter_keywords(text, keywords):
    # Convert the input text to lowercase for case-insensitive matching
    text_lower = text.lower()
    # Initialize an empty result string
    result = ""
    # Initialize a dictionary to keep track of removed keywords
    removed_keywords = {}
    
    # Iterate over each character in the text
    i = 0
    while i < len(text):
        # Check if the current character is a potential start of a keyword
        if text_lower[i] in {keyword[0].lower() for keyword in keywords}:
            # Iterate over each keyword
            for keyword in keywords:
                # Check if the current keyword matches the remaining text
                if text_lower[i:i+len(keyword)].startswith(keyword.lower()):
                    # Add the keyword to the removed_keywords dictionary
                    removed_keywords[keyword] = True
                    # Move the index to the end of the keyword
                    i += len(keyword)
                    break
            else:
                # If no keyword match was found, add the current character to the result string
                result += text[i]
                i += 1
        else:
            # If the current character is not the start of a keyword, add it to the result string
            result += text[i]
            i += 1
    
    # Remove the removed keywords from the result string
    for keyword in removed_keywords.keys():
        result = result.replace(keyword, "")
    
    return result


def reverse_linked_list(head):
    # Check if the list is empty or has only one node
    if head is None or head.next is None:
        return head

    # Initialize three pointers: prev, curr, and next
    prev = None
    curr = head
    next_node = None

    # Traverse the list and reverse the pointers
    while curr is not None:
        next_node = curr.next
        curr.next = prev
        curr.prev = next_node
        prev = curr
        curr = next_node

    # Return the new head of the reversed list
    return prev


import mysql.connector

# Establish a connection to the MySQL database
try:
    connection = mysql.connector.connect(
        host="localhost",
        user="root",
        password="password",
        database="mydb"
    )
    print("Connected to MySQL database!")
except mysql.connector.Error as error:
    print("Failed to connect to MySQL database:", error)
    exit(1)

# Retrieve the table data from the database
try:
    cursor = connection.cursor()
    cursor.execute("SELECT * FROM your_table_name")
    table_data = cursor.fetchall()
except mysql.connector.Error as error:
    print("Failed to retrieve table data:", error)
    exit(1)
finally:
    cursor.close()
    connection.close()

# Display the retrieved table data in a formatted manner
if len(table_data) > 0:
    num_columns = len(table_data[0])
    column_widths = [max(len(str(row[i])) for row in table_data) for i in range(num_columns)]

    # Print table header
    header = "|".join(str(column).ljust(column_widths[i]) for i, column in enumerate(cursor.column_names))
    print("-" * len(header))
    print(header)
    print("-" * len(header))

    # Print table rows
    for row in table_data:
        row_string = "|".join(str(row[i]).ljust(column_widths[i]) for i in range(num_columns))
        print(row_string)
else:
    print("No data found in the table.")


def is_prime(n):
    """
    Function to check if a number is prime.
    """
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    """
    Function to filter prime numbers from a list of integers.
    """
    prime_numbers = []
    prime_sum = 0
    for number in numbers:
        if is_prime(number):
            prime_numbers.append(number)
            prime_sum += number
    return prime_numbers, prime_sum

# Example usage
numbers = [2, 3, 4, 5, 6, 7, 8, 9, 10]
prime_numbers, prime_sum = get_prime_numbers(numbers)
print("Prime numbers:", prime_numbers)
print("Sum of prime numbers:", prime_sum)


import json
# Create a dictionary of attitudes
attitudes = {
    "John": ["happy", "confident", "optimistic"],
    "Jane": ["sad", "anxious", "pessimistic"],
    "Bob": ["angry", "frustrated", "hopeless"]
}
# Convert the dictionary to a JSON string
json_attitudes = json.dumps(attitudes)
# Print the JSON string
print(json_attitudes)


def f(x):
    if x < 0:
        return "Invalid input"
    else:
        return x * g(x) + 6

def g(x):
    if x < 0:
        return "Invalid input"
    else:
        return x * (x + 4) + 5


import random

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

primes = []
while len(primes) < 10:
    num = random.randint(500, 1000)
    if is_prime(num):
        primes.append(num)

prime_tuple = tuple(primes)
print(prime_tuple)


def add_period_if_vowel_end(input_string):
    """
    This function takes a string as input, removes any leading or trailing whitespace, and adds a period at the end if the string ends with a vowel.
    
    Approach:
    - First, the function strips the input string of any leading or trailing whitespace using the strip() method.
    - Then, it checks if the last character of the string is a vowel (a, e, i, o, u, A, E, I, O, U) using the endswith() method.
    - If the last character is a vowel, it adds a period at the end of the string.
    - Finally, it returns the modified string.
    
    Edge Cases:
    - If the input string is empty or contains only whitespace, the function will return an empty string.
    - If the input string ends with a punctuation mark, the function will not add a period.
    """
    
    # Remove leading and trailing whitespace
    input_string = input_string.strip()
    
    # Check if the last character is a vowel
    if input_string.endswith(('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')):
        # Add a period at the end
        input_string += '.'
    
    return input_string


def calculate_sum(a, b):
    result = a - b  # Erroneously subtracting instead of adding
    return result

num1 = 10
num2 = 5
sum = calculate_sum(num1, num2)
print(f"The sum of {num1} and {num2} is: {sum}")


def fibonacci(n):
    if n <= 0:
        return []

    fibonacci_sequence = [0, 1]  # Initialize with the first two Fibonacci numbers

    if n <= 2:
        return fibonacci_sequence[:n]

    for i in range(2, n):
        fibonacci_sequence.append(fibonacci_sequence[i-1] + fibonacci_sequence[i-2])
        
    return fibonacci_sequence


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_primes(n):
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes

primes = find_primes(10)
squares = [prime ** 2 for prime in primes]

for i, square in enumerate(squares, start=1):
    print(f"Square of prime {i}: {square}")


def create_dictionary(lst):
    dictionary = {}
    for i in range(len(lst)):
        dictionary[lst[i]] = [j for j in range(i+1)]
    return dictionary


def separate_numbers(lst):
    divisible_by_2 = []
    not_divisible_by_2 = []
    divisible_by_2_digit_sum_gt_10 = []
    divisible_by_2_digit_sum_lte_10 = []

    for num in lst:
        # Check divisibility by 2
        if num % 2 == 0:
            divisible_by_2.append(num)
            # Calculate digit sum
            digit_sum = 0
            while num > 0:
                digit_sum += num % 10
                num //= 10
            # Check digit sum condition
            if digit_sum > 10:
                divisible_by_2_digit_sum_gt_10.append(num)
            else:
                divisible_by_2_digit_sum_lte_10.append(num)
        else:
            not_divisible_by_2.append(num)

    return divisible_by_2, not_divisible_by_2, divisible_by_2_digit_sum_gt_10, divisible_by_2_digit_sum_lte_10

lst = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
result = separate_numbers(lst)
print(result)


def find_longest_string(strings):
    longest_string = None
    max_length = 0
    
    for string in strings:
        if len(string) > max_length:
            longest_string = string
            max_length = len(string)
    
    return longest_string


def transpose(matrix):
    # Base case: if the matrix is empty, return an empty matrix
    if not matrix:
        return []

    # Recursive case:
    # Transpose the submatrix starting from the second row
    sub_matrix = transpose(matrix[1:])

    # Swap elements in the first row with their corresponding elements in the column
    transposed_row = [matrix[0][i] for i in range(len(matrix[0]))]

    # Add the transposed row to the transposed submatrix
    transposed_matrix = [transposed_row] + sub_matrix

    return transposed_matrix


class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def add_node(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def compare_lists(self, other_list):
        current1 = self.head
        current2 = other_list.head

        while current1 and current2:
            if current1.value != current2.value:
                return False
            current1 = current1.next
            current2 = current2.next

        if current1 or current2:
            return False

        return True


import random

# Generate a list of 1 million unique random numbers between 1 and 1 billion
random_numbers = random.sample(range(1, 1000000001), 1000000)

# Bubble sort
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break

# Sort the array using bubble sort
bubble_sort(random_numbers)


import itertools

arr = [[1,2,3], [4,5,6], [7,8,9]]
flattened_arr = list(itertools.chain(*arr))
print(flattened_arr)


def constructRectangle(area: int) -> List[int]:
    width = int(area**0.5)
    while area % width != 0:
        width -= 1
    length = area // width
    return [length, width]


import math

def is_prime(n):
    # If the number is less than 2, it's not prime
    if n < 2:
        return False

    # Check if the number is divisible by any number up to its square root
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False

    return True


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

start = 1000
end = 2000
prime_numbers = []
product = 1

for num in range(start, end + 1):
    if is_prime(num):
        prime_numbers.append(num)
        product *= num

print("Prime numbers between", start, "and", end, "are:")
for prime in prime_numbers:
    print(prime)
print("Product of prime numbers:", product)

sum_of_digits = 0
for prime in prime_numbers:
    num = prime
    while num > 0:
        sum_of_digits += num % 10
        num //= 10

print("Sum of digits of prime numbers:", sum_of_digits)


class XMLNode:
    def __init__(self, name):
        self.name = name
        self.attributes = {}
        self.children = []
        self.text = None

def parse_xml(xml_data):
    stack = []
    current_node = None
    current_text = ""
    in_tag = False

    for char in xml_data:
        if char == '<':
            in_tag = True
            if current_text.strip():
                if current_node is None:
                    current_node = XMLNode("")
                current_node.text = current_text.strip()
                current_text = ""
        elif char == '>':
            in_tag = False
            if current_text.startswith('/'):  # closing tag
                current_text = current_text[1:]
                if not stack or current_node.name != current_text:
                    raise ValueError("Invalid XML: mismatched closing tag")
                current_node = stack.pop()
                if stack:
                    stack[-1].children.append(current_node)
                else:
                    return current_node
            else:  # opening tag
                node_name, attributes = parse_attributes(current_text)
                node = XMLNode(node_name)
                node.attributes = attributes
                if stack:
                    stack[-1].children.append(node)
                stack.append(node)
                current_node = node
                current_text = ""
        else:
            current_text += char

    if stack:
        raise ValueError("Invalid XML: missing closing tag")

    return None

def parse_attributes(tag_text):
    attributes = {}
    parts = tag_text.split(' ')
    node_name = parts[0]
    for part in parts[1:]:
        if '=' in part:
            key, value = part.split('=')
            key = key.strip()
            value = value.strip().strip('"')
            attributes[key] = value
    return node_name, attributes

def find_id_value(node):
    if node.name == 'id':
        return int(node.text)
    for child in node.children:
        result = find_id_value(child)
        if result is not None:
            return result
    return None

xml_data = '''
<root>
    <person>
        <name>John Doe</name>
        <age>30</age>
        <id>12345</id>
    </person>
    <person>
        <name>Jane Smith</name>
        <age>25</age>
        <id>67890</id>
    </person>
</root>
'''

try:
    root_node = parse_xml(xml_data)
    id_value = find_id_value(root_node)
    if id_value is not None:
        print("ID value:", id_value)
    else:
        print("No 'id' key found in XML data.")
except ValueError as e:
    print("Error:", str(e))


import base64

def reverse_base64_encode(text):
    """
    Function to encode a given body of text into base64 in reverse order.

    Approach:
    - First, the text is converted to bytes using the utf-8 encoding.
    - Then, it is encoded into base64.
    - The base64 encoded bytes are then decoded back into a string.
    - Finally, the string is reversed.

    Edge Cases:
    - If the input text is an empty string, the function will return an empty string as well.

    :param text: The text to be encoded.
    :type text: str
    :return: The reversed base64 encoding of the text.
    :rtype: str
    """
    # Convert the text to bytes
    text_bytes = text.encode('utf-8')
    
    # Encode the bytes into base64
    base64_bytes = base64.b64encode(text_bytes)
    
    # Decode the base64 bytes back into a string
    base64_string = base64_bytes.decode('utf-8')
    
    # Reverse the string
    reversed_base64_string = base64_string[::-1]
    
    return reversed_base64_string


from typing import List

def permuteUnique(nums: List[int]) -> List[List[int]]:
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
        for i in range(start, len(nums)):
            if i > start and nums[i] == nums[start]:
                continue
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]

    nums.sort()
    result = []
    backtrack(0)
    return result


import requests

def make_api_call(url):
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        return []

data = make_api_call("https://example.com/data_endpoint")

# Continue with the remaining operations on the retrieved data


import json
# JSON data
data = {
  "numbers": [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25
  ]
}
# Extract the numbers from the JSON data
numbers = data['numbers']
# Calculate the sum
sum = 0
for num in numbers:
    sum += num
# Print the sum
print(sum)


import math

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# filter the odd prime numbers
odd_prime_nums = [num for num in arr if num % 2 != 0 and is_prime(num)]

# calculate the sum of the odd prime numbers
sum_odd_prime = sum(odd_prime_nums)

# calculate the average of the resulting sum
average = sum_odd_prime / len(odd_prime_nums)

print("Odd prime numbers:", odd_prime_nums)
print("Sum of odd prime numbers:", sum_odd_prime)
print("Average of sum of odd prime numbers:", average)


def print_dict_alphabetical(dictionary):
    vowels = ['a', 'e', 'i', 'o', 'u']
    sorted_keys = sorted(dictionary.keys())
    for key in sorted_keys:
        if not key[0].lower() in vowels:
            print(f"{key}: {dictionary[key]}")


def get_value(dictionary, key):
    # Check if the given dictionary is a nested dictionary
    if isinstance(dictionary, dict):
        # Iterate through each key-value pair in the dictionary
        for k, v in dictionary.items():
            # Check if the key matches the given key
            if k == key:
                # If it does, return the value
                return v
            else:
                # If the value is another dictionary, recursively call the function
                if isinstance(v, dict):
                    result = get_value(v, key)
                    if result is not None:
                        return result
                # If the value is a list, iterate through each element and recursively call the function
                elif isinstance(v, list):
                    for item in v:
                        result = get_value(item, key)
                        if result is not None:
                            return result
    # If the given dictionary is not a nested dictionary, return None
    return None

# Example usage
nested_dict = {
    "foo": "bar",
    "baz": {
        "qux": "quux",
        "corge": {
            "qux": "grault"
        }
    },
    "qux": "qux"
}

result = get_value(nested_dict, "qux")
print(result)  # Output: "qux"


def calculate_average(*args):
    averages = []
    for param in args:
        total = 0
        count = 0
        for num in param:
            total += num
            count += 1
        average = total // count  # integer division
        if total % count >= count // 2:  # rounding to nearest whole number
            average += 1
        averages.append(average)
    return averages


def calculate_average(a_list):
    if not a_list:
        return None

    try:
        count = 0
        total_sum = 0

        for num in a_list:
            total_sum += float(num)
            count += 1

        average = total_sum / count
        rounded_average = round(average)

        return rounded_average

    except (ValueError, TypeError):
        return None


def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if len(arr[j]) < len(arr[j+1]):
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        
        if not swapped:
            break
    
    return arr

list1 = ["cat", "apple", "dog", "banana"]
bubble_sort(list1)
print(list1)


def transpose_array(arr):
    transposed_arr = []

    # Step 2: Check for empty or non-numeric array
    if len(arr) == 0 or any(not isinstance(element, (int, float)) for row in arr for element in row):
        return []

    # Step 3: Iterate through each row in the original array
    for i in range(len(arr)):
        row = arr[i]
        transposed_row = []

        # Step 4: Iterate through each element in the row
        for j in range(len(row)):
            element = row[j]

            # Step 5: Convert negative numbers to absolute values
            if element < 0:
                element = abs(element)

            # Step 6: Assign element at (i, j) to (j, i) in the transposed array
            transposed_row.append(element)

        transposed_arr.append(transposed_row)

    # Step 7: Remove duplicate elements from the transposed array
    transposed_arr = [list(set(row)) for row in transposed_arr]

    # Step 8: Return the transposed array
    return transposed_arr


# User's membership level
membership_level = "Gold"
total_amount = 100

# Calculate discount based on membership level
if membership_level == "Silver":
    discount = total_amount * 0.05
    print("5% discount applied.")
elif membership_level == "Gold":
    discount = total_amount * 0.1
    print("10% discount applied.")
elif membership_level == "Platinum":
    discount = total_amount * 0.15
    print("15% discount applied.")
else:
    discount = 0
    print("No discount applied.")

# Apply discount and calculate final amount to be paid
final_amount = total_amount - discount
print("Final amount to be paid:", final_amount)


import datetime
# Set up sleep schedule for a dog that needs 12 hours of sleep per day
sleep_time = datetime.time(22, 0)  # 10:00 PM
wake_time = datetime.time(10, 0)  # 10:00 AM
# Calculate the duration of sleep
sleep_duration = datetime.timedelta(hours=12)
# Set up the sleep schedule
today = datetime.date.today()
sleep_start = datetime.datetime.combine(today, sleep_time)
sleep_end = sleep_start + sleep_duration
# Print the sleep schedule
print(f"Sleep schedule for the dog:\n"
      f"Sleep time: {sleep_start}\n"
      f"Wake time: {sleep_end}")


def replace_substring(string, substrings, replacement):
    modified_substrings = []
    i = 0
    j = 0

    while i < len(string):
        if string[i] == substrings[0][j]:
            if string[i:i+len(substrings[0])] == substrings[0]:
                modified_substrings.append(replacement)
                i += len(substrings[0])
                j = 0
                continue
            elif string[i:i+len(substrings[1])] == substrings[1]:
                modified_substrings.append(replacement)
                i += len(substrings[1])
                j = 0
                continue

        modified_substrings.append(string[i])
        i += 1
        j = 0

    return ''.join(modified_substrings)


string = "Hello there"
substrings = ["el", "er"]
replacement = "XY"

result = replace_substring(string, substrings, replacement)
print(result)


def count_frequency(numbers):
    """
    This function takes a list of numbers as input and returns a dictionary with the frequency of each number.
    It raises a TypeError if the input is not a list or if the list contains non-numeric elements.
    The function has a time complexity of O(n), where n is the length of the input list.

    Approach:
    - First, check if the input is a list. If not, raise a TypeError.
    - Then, iterate over the list. For each number, check if it's already in the dictionary.
      If it is, increment its count. If it's not, add it to the dictionary with a count of 1.
    - Finally, return the dictionary.

    Edge cases:
    - If the list is empty, the function returns an empty dictionary.
    - If the list contains non-numeric elements, the function raises a TypeError.
    """

    # Check if the input is a list
    if not isinstance(numbers, list):
        raise TypeError("Input must be a list")

    # Initialize an empty dictionary to store the frequency of each number
    frequency_dict = {}

    # Iterate over the list
    for num in numbers:
        # Check if the current element is a number
        if not isinstance(num, (int, float)):
            raise TypeError("List must contain only numbers")

        # If the number is already in the dictionary, increment its count
        if num in frequency_dict:
            frequency_dict[num] += 1
        # If the number is not in the dictionary, add it with a count of 1
        else:
            frequency_dict[num] = 1

    # Return the dictionary with the frequency of each number
    return frequency_dict


import re

def get_unique_words(sentence):
    # Step 1: Remove punctuation marks
    sentence = re.sub(r'[^\w\s]', '', sentence)

    # Step 2: Convert to lowercase
    sentence = sentence.lower()

    # Step 3: Split into an array of words
    words = sentence.split()

    # Step 4: Initialize a set to store unique words
    unique_words = set()

    # Step 5: Add words to the set
    for word in words:
        unique_words.add(word)

    # Step 6: Convert the set back to an array
    unique_words_array = list(unique_words)

    return unique_words_array


import itertools

# ê° ììê³¼ ì ìê³¼ëª©ì dictionaryë¡ íí
courses = {
    1: [],
    2: [1],
    3: [2],
    4: [],
    5: [3]
}

# ëª¨ë  ê°ë¥í ì¡°í©ì ìì±íì¬ ì¡°ê±´ì ë§ì¡±íë ì¡°í©ì ì°¾ì
for comb in itertools.combinations(courses.keys(), 3):
    # ì¡°ê±´ 1: A ììì ìê°íë ¤ë©´ B ììì ìê°íì§ ììë ë¨
    if 1 in comb and 2 in comb:
        continue
    # ì¡°ê±´ 2: C ììì ìê°íë ¤ë©´ B ììì ìê°í´ì¼ í¨
    if 3 in comb and 2 not in comb:
        continue
    # ì¡°ê±´ 3: D ììì ìê°íì§ ìì¼ë©´ E ììì ìê°í  ì ìì
    if 4 not in comb and 5 in comb:
        continue
    # ì¡°ê±´ 4: E ììì ìê°íë ¤ë©´ C ììì ìê°í´ì¼ í¨
    if 5 in comb and 3 not in comb:
        continue
    # ëª¨ë  ì¡°ê±´ì ë§ì¡±íë ê²½ì° ì¡°í©ì í¬ê¸° ì¶ë ¥
    print(len(comb), comb)


sentence = "Welcome to the world of Python programming"
words = sentence.split()
word_lengths = {}
for word in words:
    word_lengths[word] = len(word)
print(word_lengths)


def findDuplicates(arr):
    counts = {}  # dictionary to store the count of each number
    duplicates = []  # list to store the duplicates

    # iterate through the array and count each number
    for num in arr:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1

    # iterate through the dictionary and add duplicates to the list
    for num, count in counts.items():
        if count > 1:
            duplicates.append(num)

    # sort the list in ascending order and return it
    duplicates.sort()
    return duplicates


import math

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

prime_squares = []
for i in range(10**6 + 1):
    if is_prime(i):
        prime_squares.append(i ** 2)

print(prime_squares)


def ambiguousCoordinates(s):
    def generateNumber(s):
        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):
            return []
        if len(s) > 1 and s[0] == '0':
            return ["0." + s[1:]]
        res = [s]
        if len(s) == 1 or s[-1] == '0':
            return res
        for i in range(1, len(s)):
            res.append(s[:i] + "." + s[i:])
        return res

    n = len(s)
    res = []
    
    for i in range(2, n - 1):
        first = generateNumber(s[1:i])
        second = generateNumber(s[i:n - 1])
        
        for f in first:
            for sec in second:
                res.append("(" + f + ", " + sec + ")")
    
    return res


def count_unique_words(text):
    # Convert the text to lowercase and remove leading/trailing spaces
    text = text.lower().strip()

    # Split the text into words using whitespace as the delimiter
    words = text.split()

    # Initialize an empty set to store unique words
    unique_words = set()

    # Iterate over each word and add it to the set
    for word in words:
        # Remove punctuation marks and special characters from the word
        word = ''.join(e for e in word if e.isalnum())
        # Add the word to the set
        unique_words.add(word)

    # Return the count of unique words
    return len(unique_words)


class Node:
    def __init__(self, data):
        self.data = data
        self.previous = None
        self.next = None

def merge_sort(head):
    if head is None or head.next is None:
        return head
    
    middle = get_middle(head)
    middle.next.previous = None
    right = middle.next
    middle.next = None
    
    left = merge_sort(head)
    right = merge_sort(right)
    
    return merge(left, right)

def get_middle(head):
    slow = head
    fast = head
    
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow

def merge(left, right):
    if left is None:
        return right
    if right is None:
        return left
    
    if left.data < right.data:
        result = left
        result.next = merge(left.next, right)
        result.next.previous = result
    else:
        result = right
        result.next = merge(left, right.next)
        result.next.previous = result
    
    return result

# Initialize the doubly linked list
head = Node(9)
node2 = Node(5)
node3 = Node(12)
node4 = Node(3)
node5 = Node(7)
node6 = Node(2)
node7 = Node(6)
node8 = Node(1)

head.next = node2
node2.previous = head
node2.next = node3
node3.previous = node2
node3.next = node4
node4.previous = node3
node4.next = node5
node5.previous = node4
node5.next = node6
node6.previous = node5
node6.next = node7
node7.previous = node6
node7.next = node8
node8.previous = node7

# Sort the doubly linked list using merge sort
head = merge_sort(head)

# Print the sorted doubly linked list
current = head
while current:
    print("Node {}: data = {}, previous = {}, next = {}".format(id(current), current.data, id(current.previous), id(current.next)))
    current = current.next


import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def sum_proper_divisors(num):
    sum_divisors = 0
    for i in range(1, int(math.sqrt(num)) + 1):
        if num % i == 0:
            if i != num and not is_prime(i):
                sum_divisors += i
            if i != num and i != num // i and not is_prime(num // i):
                sum_divisors += num // i
    return sum_divisors

# Test the function
print(sum_proper_divisors(12))  # Output: 16


def longest_common_substring(s1, s2):
    # Initialize a 2D array to store the lengths of longest common suffixes
    # dp[i][j] represents the length of longest common suffix of s1[:i] and s2[:j]
    dp = [[0] * (len(s2) + 1) for _ in range(len(s1) + 1)]
    
    # Variable to store the length of the longest common substring
    max_len = 0
    
    # Variable to store the ending index of the longest common substring
    end_index = 0
    
    # Iterate over the characters of the first string
    for i in range(1, len(s1) + 1):
        # Iterate over the characters of the second string
        for j in range(1, len(s2) + 1):
            # If the characters match
            if s1[i - 1] == s2[j - 1]:
                # Update the length of longest common suffix
                dp[i][j] = dp[i - 1][j - 1] + 1
                # Check if the length is greater than the current maximum
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    # Update the ending index of the longest common substring
                    end_index = i - 1
    
    # Extract the longest common substring from the first string
    longest_substring = s1[end_index - max_len + 1: end_index + 1]
    
    return longest_substring


import numpy as np

# Given matrix array
matrix_array = np.array([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]])

# Reshape the matrix array to have 5 rows and 7 columns
reshaped_array = np.reshape(matrix_array, (5, 7))

# Find the sum of each row and each column in the reshaped matrix
row_sums = np.sum(reshaped_array, axis=1)
column_sums = np.sum(reshaped_array, axis=0)

print("Reshaped Array:")
print(reshaped_array)
print("\nSum of each row:")
print(row_sums)
print("\nSum of each column:")
print(column_sums)


def find_first_occurrence(numbers):
    index = -1
    for i in range(len(numbers)):
        if numbers[i] == 7:
            index = i
            break
    if index == -1:
        return -1
    else:
        return index

# Testing the code with the given example
numbers = [1, 2, 3, 5, 4, 7, 9, 8, 7]
print(find_first_occurrence(numbers))


def find_longest_word(dictionary, characters):
    longest_word = ""
    
    for word in dictionary:
        if set(word).issubset(set(characters)):
            if len(word) > len(longest_word):
                longest_word = word
    
    return longest_word


import random
adjectives = ["juicy", "ripe", "sour", "tart", "sweet", "zesty"]
fruits = ["apple", "banana", "kiwi", "orange", "pear", "pineapple"]
def generate_pun():
    adj1 = random.choice(adjectives)
    adj2 = random.choice(adjectives)
    fruit1 = random.choice(fruits)
    fruit2 = random.choice(fruits)
    
    if adj1 != adj2 and fruit1 != fruit2:
        return f"Why did the {adj1} {fruit1} break up with the {adj2} {fruit2}? Because they couldn't find common peelings!"
    else:
        return generate_pun()
puns = []
for i in range(10):
    pun = generate_pun()
    puns.append(pun)
for pun in puns:
    print(pun)


import requests
import threading
import time

# Global variables
MAX_REQUESTS_PER_MINUTE = 10
SECTIONS = [
    # List of sections to scrape, each element contains a URL and section name
    {'url': 'http://example.com/section1', 'name': 'section1'},
    {'url': 'http://example.com/section2', 'name': 'section2'},
    # Add more sections as needed
]

# Rate limiting lock
rate_limit_lock = threading.Lock()
requests_made = 0
start_time = time.time()

# Worker function for each thread
def scrape_section(section):
    global requests_made
    
    # Rate limiting check
    with rate_limit_lock:
        elapsed_time = time.time() - start_time
        if elapsed_time < 60 and requests_made >= MAX_REQUESTS_PER_MINUTE:
            time.sleep(60 - elapsed_time)
            requests_made = 0
            start_time = time.time()
        
    # Download the HTML for the section
    response = requests.get(section['url'])
    html = response.text
    
    # Process the HTML as needed
    # ...

    # Increment the request count
    with rate_limit_lock:
        requests_made += 1

# Main function to start scraping
def scrape_website():
    threads = []
    
    # Create a thread for each section
    for section in SECTIONS:
        thread = threading.Thread(target=scrape_section, args=(section,))
        thread.start()
        threads.append(thread)
    
    # Wait for all threads to finish
    for thread in threads:
        thread.join()

# Start the web scraping
scrape_website()


def recursive_binary_search(arr, target, start, end):
    if start > end:
        return -1

    mid = (start + end) // 2

    if arr[mid] == target:
        left_occurrence = recursive_binary_search(arr, target, start, mid - 1)
        right_occurrence = recursive_binary_search(arr, target, mid + 1, end)

        if left_occurrence == -1 and right_occurrence == -1:
            return -1
        elif left_occurrence == -1:
            return right_occurrence
        else:
            return left_occurrence
    elif arr[mid] > target:
        return recursive_binary_search(arr, target, mid + 1, end)
    else:
        return recursive_binary_search(arr, target, start, mid - 1)


# Example usage
arr = [10, 9, 8, 7, 6, 6, 6, 5, 4, 3, 2, 1]
target = 6

second_occurrence_index = recursive_binary_search(arr, target, 0, len(arr) - 1)

if second_occurrence_index != -1:
    print(f"The second occurrence of {target} is at index {second_occurrence_index}.")
else:
    print(f"The second occurrence of {target} does not exist.")


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def sortedList(head):
    if not head or not head.next:
        return head

    prev = head
    cur = head.next

    while cur:
        if cur.val < prev.val:
            prev.next = cur.next
            cur.next = head
            head = cur
            cur = prev
        else:
            prev = cur
        cur = cur.next
    return head


def are_elements_equal(lst):
    if all(isinstance(elem, int) and elem > 0 for elem in lst):
        return all(elem == lst[0] for elem in lst)
    else:
        return False

# Test cases
print(are_elements_equal([1, 1, 1, 1]))  # True, all elements are equal
print(are_elements_equal([1, 2, 3, 4]))  # False, elements are not equal
print(are_elements_equal([1, 1, 1, -1]))  # False, list contains a negative integer
print(are_elements_equal([]))  # True, empty list is considered to have equal elements


def find_most_frequent_char(s, max_char=None, max_count=0):
    # Base case: if the string is empty, return the most frequent character and its count
    if len(s) == 0:
        return max_char, max_count
    
    # Recursive case:
    # Get the first character of the string
    current_char = s[0]
    # Count the number of occurrences of the current character in the string
    count = count_occurrences(s, current_char)
    
    # Update the most frequent character and its count if necessary
    if count > max_count:
        max_char = current_char
        max_count = count
    
    # Recursive call with the remaining part of the string
    return find_most_frequent_char(s[1:], max_char, max_count)

def count_occurrences(s, char):
    # Base case: if the string is empty, return 0
    if len(s) == 0:
        return 0
    
    # Recursive case:
    # If the first character of the string matches the character we are counting, increment the count by 1
    if s[0] == char:
        return 1 + count_occurrences(s[1:], char)
    else:
        # If the first character of the string does not match the character we are counting, move to the next character
        return count_occurrences(s[1:], char)


def generate_subsets(input_set):
    subsets = [[]]  # start with an empty subset
    
    for num in input_set:
        new_subsets = []
        for subset in subsets:
            new_subset = subset + [num]
            new_subsets.append(new_subset)
        subsets += new_subsets
    
    return subsets

input_set = {1, 2, 3}
subsets = generate_subsets(input_set)
print(subsets)


def top_3_polluted_bodies_of_water(data):
    """
    Returns the names of the top 3 bodies of water with the most severe water pollution,
    taking into account the population living in the vicinity of the body of water.
    """
    sorted_data = sorted(data, key=lambda x: (x['pollution_level'], -x['population']), reverse=True)
    return [d['name'] for d in sorted_data[:3]]


def convert_to_reverse_prime_number(arr):
    result = ""
    
    # Iterate through the input array in reverse order
    for num in reversed(arr):
        # Check if the number is prime
        is_prime = True
        if num > 1:
            for i in range(2, int(num/2) + 1):
                if (num % i) == 0:
                    is_prime = False
                    break
        
        # If the number is prime, convert it to a string and append it to the result string
        if is_prime:
            result += str(num)
    
    return result


my_list = [2, 3, 5, 7, 11]


for i in range(1, 101):
    if i % 2 == 0 and i % 3 != 0:
        print(i)


from collections import deque

def widthOfBinaryTree(root):
    if not root:
        return 0

    maxWidth = 0
    q = deque([(root, 1)])

    while q:
        levelSize = len(q)
        left, _ = q[0]
        right = left
        for _ in range(levelSize):
            node, pos = q.popleft()
            right = pos

            if node.left:
                q.append((node.left, 2 * pos))
            if node.right:
                q.append((node.right, 2 * pos + 1))
        
        maxWidth = max(maxWidth, right - left + 1)
    
    return maxWidth


class Shape:
    def __init__(self, shape_type, area, perimeter):
        self.shape_type = shape_type
        self.area = area
        self.perimeter = perimeter

    def calculate_area(self):
        pass

    def calculate_perimeter(self):
        pass

class Triangle(Shape):
    def __init__(self, base, height):
        super().__init__("triangle", 0, 0)
        self.base = base
        self.height = height

    def calculate_area(self):
        return 0.5 * self.base * self.height

    def calculate_perimeter(self):
        return 3 * self.base

class Rectangle(Shape):
    def __init__(self, length, width):
        super().__init__("rectangle", 0, 0)
        self.length = length
        self.width = width

    def calculate_area(self):
        return self.length * self.width

    def calculate_perimeter(self):
        return 2 * (self.length + self.width)

class Circle(Shape):
    def __init__(self, radius):
        super().__init__("circle", 0, 0)
        self.radius = radius

    def calculate_area(self):
        return 3.14 * self.radius ** 2

    def calculate_perimeter(self):
        return 2 * 3.14 * self.radius

class Square(Shape):
    def __init__(self, side):
        super().__init__("square", 0, 0)
        self.side = side

    def calculate_area(self):
        return self.side ** 2

    def calculate_perimeter(self):
        return 4 * self.side

class Pentagon(Shape):
    def __init__(self, side):
        super().__init__("pentagon", 0, 0)
        self.side = side

    def calculate_area(self):
        return 1.72 * self.side ** 2

    def calculate_perimeter(self):
        return 5 * self.side

def perform_operation(shapes, operation):
    if operation == "calculate total area":
        total_area = 0
        for shape in shapes:
            total_area += shape.calculate_area()
        return total_area
    elif operation == "calculate perimeter":
        total_perimeter = 0
        for shape in shapes:
            total_perimeter += shape.calculate_perimeter()
        return total_perimeter
    elif operation == "count number of triangles":
        count = 0
        for shape in shapes:
            if shape.shape_type == "triangle":
                count += 1
        return count
    elif operation == "count number of circles":
        count = 0
        for shape in shapes:
            if shape.shape_type == "circle":
                count += 1
        return count
    elif operation == "find shape with maximum area":
        max_area_shape = None
        max_area = 0
        for shape in shapes:
            area = shape.calculate_area()
            if area > max_area:
                max_area = area
                max_area_shape = shape
        return max_area_shape
    elif operation == "calculate average area":
        total_area = 0
        for shape in shapes:
            total_area += shape.calculate_area()
        average_area = total_area / len(shapes)
        return average_area
    else:
        return "Unsupported operation"

# Example usage
shapes = [
    Triangle(3, 4),
    Rectangle(5, 6),
    Circle(2),
    Square(4),
    Pentagon(3)
]

print(perform_operation(shapes, "calculate total area"))
print(perform_operation(shapes, "calculate perimeter"))
print(perform_operation(shapes, "count number of triangles"))
print(perform_operation(shapes, "count number of circles"))
print(perform_operation(shapes, "find shape with maximum area"))
print(perform_operation(shapes, "calculate average area"))


def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    return merge(left_half, right_half)

def merge(left_half, right_half):
    result = []
    i = j = 0
    
    while i < len(left_half) and j < len(right_half):
        if left_half[i] < right_half[j]:
            result.append(left_half[i])
            i += 1
        elif left_half[i] > right_half[j]:
            result.append(right_half[j])
            j += 1
        else:
            i += 1
            j += 1
    
    while i < len(left_half):
        result.append(left_half[i])
        i += 1
    
    while j < len(right_half):
        result.append(right_half[j])
        j += 1
    
    return result

def sort_list(arr):
    # Remove duplicates from the list
    arr = list(set(arr))
    
    # Sort the list using merge sort in descending order
    arr = merge_sort(arr)
    arr.reverse()
    
    return arr

# Test the program
arr = [4, 2, 7, 9, 2, 1, 4, 5, 7]
sorted_arr = sort_list(arr)
print(sorted_arr)


def rgb_to_hex(red, green, blue):
    # Check if the RGB values are within the valid range (0-255)
    if not (0 <= red <= 255) or not (0 <= green <= 255) or not (0 <= blue <= 255):
        raise ValueError("RGB values must be between 0 and 255")

    # Convert the RGB values to hexadecimal
    hex_value = "#{:02x}{:02x}{:02x}".format(red, green, blue)

    return hex_value


def insertion_sort(arr):
    comparisons = 0
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            comparisons += 1
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return comparisons

# Test the program
arr = [4, 2, 6, 8, 1]
comparisons = insertion_sort(arr)
print("Sorted array:", arr)
print("Number of comparisons:", comparisons)


import threading
import math

# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

# Function to search for the first prime number in a given range of the array
def search_prime(arr, start, end):
    for i in range(start, end):
        if is_prime(arr[i]):
            print("First prime number found at index:", i)
            return

# Function to divide the array into multiple ranges and run the search_prime function on each range using multiple threads
def search_primes_multithreaded(arr):
    num_threads = 4 # Number of threads to use
    chunk_size = math.ceil(len(arr) / num_threads) # Size of each range

    threads = []
    for i in range(num_threads):
        start = i * chunk_size
        end = start + chunk_size
        if end > len(arr):
            end = len(arr)
        thread = threading.Thread(target=search_prime, args=(arr, start, end))
        thread.start()
        threads.append(thread)

    # Wait for all threads to complete
    for thread in threads:
        thread.join()

# Example usage
numbers = [2, 4, 6, 8, 10, 3, 15, 17, 20, 25, 29, 30, 31, 35, 37]
search_primes_multithreaded(numbers)


def validateStackSequences(pushed, popped):
    stack = []
    popIndex = 0
    
    for pushValue in pushed:
        stack.append(pushValue)
        while stack and stack[-1] == popped[popIndex]:
            stack.pop()
            popIndex += 1
    
    return not stack


def get_day_of_week():
    # Prompt the user to enter a number representing a day of the week
    user_input = input("Enter a number representing a day of the week (1-7): ")
    
    # Validate user input
    if not user_input.isdigit() or int(user_input) < 1 or int(user_input) > 7:
        print("Invalid input. Please enter a number between 1 and 7.")
        return
    
    # Convert user input to an integer
    day_number = int(user_input)
    
    # Determine the corresponding day of the week in English
    if day_number == 1:
        day_english = "Monday"
    elif day_number == 2:
        day_english = "Tuesday"
    elif day_number == 3:
        day_english = "Wednesday"
    elif day_number == 4:
        day_english = "Thursday"
    elif day_number == 5:
        day_english = "Friday"
    elif day_number == 6:
        day_english = "Saturday"
    else:
        day_english = "Sunday"
    
    # Determine the corresponding day of the week in Spanish
    if day_number == 1:
        day_spanish = "Lunes"
    elif day_number == 2:
        day_spanish = "Martes"
    elif day_number == 3:
        day_spanish = "MiÃ©rcoles"
    elif day_number == 4:
        day_spanish = "Jueves"
    elif day_number == 5:
        day_spanish = "Viernes"
    elif day_number == 6:
        day_spanish = "SÃ¡bado"
    else:
        day_spanish = "Domingo"
    
    # Determine the corresponding day of the week in French
    if day_number == 1:
        day_french = "Lundi"
    elif day_number == 2:
        day_french = "Mardi"
    elif day_number == 3:
        day_french = "Mercredi"
    elif day_number == 4:
        day_french = "Jeudi"
    elif day_number == 5:
        day_french = "Vendredi"
    elif day_number == 6:
        day_french = "Samedi"
    else:
        day_french = "Dimanche"
    
    # Print the corresponding days in different languages
    print("In English:", day_english)
    print("En espaÃ±ol:", day_spanish)
    print("En franÃ§ais:", day_french)

# Call the function to start the program
get_day_of_week()


def calculate_compensation(injury_type, job_title, length_of_service, age, pre_existing_condition):
    # Assume that the monthly wage is 30,000 THB
    monthly_wage = 30000
    
    # Determine the compensation rate based on injury type
    if injury_type == "Death":
        compensation_rate = 60 * monthly_wage
    elif injury_type == "Permanent disability":
        compensation_rate = 100 * monthly_wage
    elif injury_type == "Total temporary disability":
        compensation_rate = 21 * monthly_wage  # 70% of daily wage for 30 days
    else:  # Partial temporary disability
        compensation_rate = 0.5 * (21 * monthly_wage)  # 50% of total compensation for total temporary disability
    
    # Adjust compensation based on job title and length of service
    if job_title == "Manager":
        compensation_rate *= 1.5
    elif job_title == "Supervisor":
        compensation_rate *= 1.25
    
    if length_of_service >= 5:
        compensation_rate *= 1.5
    elif length_of_service >= 2:
        compensation_rate *= 1.25
    
    # Adjust compensation based on age and pre-existing condition
    if age >= 60 or pre_existing_condition:
        compensation_rate *= 0.5
    
    return compensation_rate


def maxPoints(points):
    m, n = len(points), len(points[0])
    dp = [0] * n
    for row in points:
        next_dp = [0] * n
        for c1 in range(n):
            score = dp[c1] + row[c1] - c1
            for c2 in range(n):
                next_dp[c2] = max(next_dp[c2], score - row[c1] + c2)
        dp = next_dp
    return max(dp)


# Create a 3x3 identity matrix with non-zero diagonal elements
identity_matrix = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

# Set non-zero values on the diagonal
identity_matrix[0][0] = 1
identity_matrix[1][1] = 1
identity_matrix[2][2] = 1

# Print the resulting identity matrix
for row in identity_matrix:
    print(row)


from typing import List, Dict

def generate_histogram(data: List[int]) -> Dict[int, int]:
    """
    This function generates a histogram from a given list of integers.
    
    The function first checks if the input is a list and if all elements in the list are integers.
    If not, it raises a ValueError.
    
    Then, it iterates over the list, ignoring negative integers, and counts the frequency of each positive integer.
    The frequencies are stored in a dictionary, which is then returned.

    Args:
    data: A list of integers.

    Returns:
    A dictionary where the keys are the unique positive integers from the input list and the values are the frequencies of those integers.

    Raises:
    ValueError: If the input is not a list or if it contains non-integer elements.
    """
    
    # Check if input is a list
    if not isinstance(data, list):
        raise ValueError("Input data should be a list of integers")
    
    # Check if all elements in the list are integers
    for element in data:
        if not isinstance(element, int):
            raise ValueError("Input data should be a list of integers")
    
    # Initialize an empty dictionary to store the frequencies
    histogram = {}
    
    # Iterate over the list
    for num in data:
        # Ignore negative integers
        if num > 0:
            # If the integer is already in the dictionary, increment its frequency
            if num in histogram:
                histogram[num] += 1
            # If the integer is not in the dictionary, add it with a frequency of 1
            else:
                histogram[num] = 1
    
    return histogram


import math

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    primes = []
    for num in numbers:
        if is_prime(num):
            primes.append(num)
    return primes

# Example usage
input_list = [2, 3, 4, 5, 6, 7, 8, 9, 10]
output_list = get_prime_numbers(input_list)
print(output_list)  # Output: [2, 3, 5, 7]


import re

def replace_substring(main_string, start_substring, end_substring):
    # Construct the regular expression pattern
    pattern = r"(\b|\W)" + re.escape(start_substring) + r"(\b|\W)"
    
    # Replace all occurrences of the first substring with the second substring
    modified_string = re.sub(pattern, r"\1" + end_substring + r"\2", main_string)
    
    return modified_string


class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def height(node):
    if node is None:
        return 0
    return max(height(node.left), height(node.right)) + 1

def is_balanced(node):
    if node is None:
        return True
    left_height = height(node.left)
    right_height = height(node.right)
    if abs(left_height - right_height) <= 2:
        return is_balanced(node.left) and is_balanced(node.right)
    return False

def inorder_traversal(node, freq):
    if node is None:
        return
    inorder_traversal(node.left, freq)
    freq[node.value] = freq.get(node.value, 0) + 1
    inorder_traversal(node.right, freq)

def check_balanced_and_print(node):
    if is_balanced(node):
        freq = {}
        inorder_traversal(node, freq)
        print('Inorder traversal:', ', '.join(str(key) for key in sorted(freq.keys())))
        print('Node frequencies:', ', '.join(f'{key}: {value}' for key, value in sorted(freq.items())))
        return True
    return False

# Test the function
root = Node(5)
root.left = Node(3)
root.right = Node(8)
root.left.left = Node(2)
root.left.right = Node(4)

print(check_balanced_and_print(root))


import time
import requests
from threading import Lock

# Global variables for rate limiting and caching
RATE_LIMIT = 10  # Number of requests allowed per minute
CACHE_EXPIRATION = 60  # Cache expiration time in seconds
cache = {}  # Dictionary to store cached weather information
lock = Lock()  # Lock to synchronize access to the cache

def get_weather(city):
    # Check if weather information is available in cache
    if city in cache:
        cached_time, weather_info = cache[city]
        if time.time() - cached_time < CACHE_EXPIRATION:
            return weather_info

    # Wait for rate limit to reset if needed
    while get_weather.rate_limit <= 0:
        time.sleep(1)

    # Send HTTP request to get weather information
    try:
        response = requests.get(f'https://weather-api.com/{city}')
        if response.status_code == 200:
            weather_info = response.json()
            cache_weather(city, weather_info)
            with lock:
                get_weather.rate_limit -= 1
            return weather_info
        else:
            return f'Error: {response.status_code}'

    except requests.exceptions.RequestException as e:
        return f'Error: {str(e)}'

def cache_weather(city, weather_info):
    with lock:
        cache[city] = (time.time(), weather_info)

def run_concurrent_requests(cities):
    threads = []
    for city in cities:
        thread = Thread(target=get_weather, args=(city,))
        thread.start()
        threads.append(thread)

    for thread in threads:
        thread.join()

if __name__ == '__main__':
    # Example usage
    cities = ['London', 'New York', 'Paris']
    get_weather.rate_limit = RATE_LIMIT  # Initialize rate limit

    run_concurrent_requests(cities)


def filter_sort(nums):
    # Step 1: Filter odd numbers
    odds = []
    for num in nums:
        if num % 2 != 0:
            odds.append(num)
    
    # Step 2: Sort in descending order (using bubble sort algorithm)
    n = len(odds)
    for i in range(n-1):
        for j in range(n-i-1):
            if odds[j] < odds[j+1]:
                odds[j], odds[j+1] = odds[j+1], odds[j]
    
    # Step 3: Remove duplicates
    i = 0
    while i < len(odds)-1:
        if odds[i] == odds[i+1]:
            odds.pop(i+1)
        else:
            i += 1
    
    return odds


def distinct_numbers_in_subarrays(nums, k):
    counts = {}
    ans = []
    for i, num in enumerate(nums):
        counts[num] = counts.get(num, 0) + 1
        if i >= k:
            counts[nums[i - k]] -= 1
            if counts[nums[i - k]] == 0:
                del counts[nums[i - k]]
        if i >= k - 1:
            ans.append(len(counts))
    return ans


def least_ops_express_target(x, target):
    if x == target:
        return 0
    if target == 1:
        return 1
    if x > target:
        return min(2 * target - 1, 2 * (x - target))

    k = 0
    p = x
    while p < target:
        k += 1
        p *= x

    ans = float('inf')
    d = 1

    for i in range(k - 1, -1, -1):
        while p >= target + d * (1 - x):
            p -= d
            ans = min(ans, i + int(math.log2(target // d) + 1) + int(d == 1 and -1 or 0))
        d = d * x + 1

    return ans


for i in range(7, 19):
    if i != 13 and i % 2 != 0:
        print(i**2)


class EmptyListException(Exception):
    pass

def find_longest_string(strings):
    if not strings:
        raise EmptyListException("List is empty.")
    
    longest_strings = []
    max_sum = float('-inf')
    
    for string in strings:
        string_sum = sum(ord(char) for char in string)
        if string_sum > max_sum:
            longest_strings = [string]
            max_sum = string_sum
        elif string_sum == max_sum:
            longest_strings.append(string)
    
    if not longest_strings:
        raise EmptyListException("List contains only empty strings.")
    
    for longest_string in longest_strings:
        print(longest_string)


def reverse_string(s):
    return s[::-1]


n = 10

# Initialize the first two values
previous_value = 0
current_value = 1

# Print the initial two values
print(previous_value)
print(current_value)

# Loop 'n' times
for _ in range(n-2):
    # Calculate the sum of previous two values
    next_value = previous_value + current_value
    
    # Print the next value
    print(next_value)
    
    # Update the previous and current values
    previous_value = current_value
    current_value = next_value


def find_pairs(nums, target):
    pairs = []
    seen = set()
    
    for num in nums:
        complement = target - num
        if complement in seen:
            pair = [complement, num]
            pair.sort()
            pairs.append(pair)
        seen.add(num)
    
    return pairs


def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            # Check if it's the first occurrence
            while mid > 0 and arr[mid-1] == target:
                mid -= 1
            return mid
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1


num1 = 10
num2 = 15

if num1 > num2:
    maximum = num1
else:
    maximum = num2

print(maximum)


def check_even(arr):
    if not arr:
        return "The list is empty!"
    elif all(x < 0 for x in arr):
        return "The list contains only negative numbers!"
    else:
        return all(x % 2 == 0 for x in arr)


x = 5


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def is_fibonacci(n):
    a, b = 0, 1
    while a <= n:
        if a == n:
            return True
        a, b = b, a + b
    return False

def is_palindrome(n):
    n_str = str(n)
    return n_str == n_str[::-1]

table_limit = 313

# Finding the nearest prime Fibonacci number that is also a palindrome
n = table_limit
while True:
    if is_fibonacci(n) and is_palindrome(n) and is_prime(n):
        break
    n -= 1

# Printing the prime number table up to the limit
print("Prime number table up to", n)
print("----------------------------")
print("Prime Number\t\tPrime Number")
print("in Ascending Order\tin Descending Order")
print("----------------------------")

for i in range(2, n+1):
    if is_prime(i):
        print(f"{i}\t\t\t{n-i+2}")


def find_most_common_integer(lst):
    max_count = 0
    most_common = None
    
    for i in range(len(lst)):
        if lst[i] > 0:
            count = 0
            for j in range(i+1, len(lst)):
                if lst[j] == lst[i]:
                    count += 1
            if count > max_count:
                max_count = count
                most_common = lst[i]
    
    return most_common

# Example usage:
numbers = [1, 2, 3, 4, 2, 3, 1, 5, 6, 5, 3]
result = find_most_common_integer(numbers)
print(result)  # Output: 3


def max_consecutive_subarrays(arr, target_sum):
    count = 0
    max_count = 0

    # Iterate through each element in the array
    for i in range(len(arr)):
        current_sum = 0
        
        # Check if there are at least 3 elements remaining in the array
        if i + 2 < len(arr):
            # Calculate the sum of the next 3 elements
            current_sum = arr[i] + arr[i+1] + arr[i+2]
            
            # If the sum is equal to the target sum, increment the count
            if current_sum == target_sum:
                count += 1
                max_count = max(max_count, count)
            else:
                # If the sum is not equal to the target sum, reset the count
                count = 0
    
    return max_count


def to_hexadecimal(number):
    # Step 1: Extract integer and decimal parts
    integer_part = abs(int(number))
    decimal_part = abs(number) - integer_part

    # Step 2: Convert integer part to hexadecimal
    hex_integer = hex(integer_part)[2:]

    # Step 3: Convert decimal part to hexadecimal
    hex_decimal = ''
    while decimal_part > 0 and len(hex_decimal) <= 30:
        decimal_part *= 16
        digit = int(decimal_part)
        hex_decimal += hex(digit)[2:]
        decimal_part -= digit

    # Step 4: Combine hexadecimal representations
    hexadecimal = hex_integer + hex_decimal

    # Handle negative numbers
    if number < 0:
        hexadecimal = '-' + hexadecimal

    return hexadecimal.upper()


import random
import itertools
import multiprocessing as mp

# Define the cities and their coordinates
cities = {
    'A': (0, 0),
    'B': (1, 2),
    'C': (3, 1),
    'D': (5, 2),
    'E': (6, 0),
    'F': (4, -1)
}

# Define the parameters for the genetic algorithm
population_size = 100
num_generations = 100
num_processes = mp.cpu_count()

# Function to calculate the distance between two cities
def distance(city1, city2):
    x1, y1 = cities[city1]
    x2, y2 = cities[city2]
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

# Function to calculate the total distance of a route
def total_distance(route):
    return sum(distance(route[i], route[i+1]) for i in range(len(route)-1)) + distance(route[-1], route[0])

# Function to generate an initial population of routes
def generate_population(population_size):
    population = []
    cities_list = list(cities.keys())
    for _ in range(population_size):
        random.shuffle(cities_list)
        population.append(cities_list[:])
    return population

# Function to perform crossover between two routes
def crossover(route1, route2):
    start = random.randint(0, len(route1)-2)
    end = random.randint(start+1, len(route1)-1)
    offspring = [-1] * len(route1)
    offspring[start:end+1] = route1[start:end+1]
    remaining_cities = [city for city in route2 if city not in offspring]
    offspring[:start] = remaining_cities[:start]
    offspring[end+1:] = remaining_cities[start:]
    return offspring

# Function to perform mutation on a route
def mutate(route):
    index1 = random.randint(0, len(route)-1)
    index2 = random.randint(0, len(route)-1)
    route[index1], route[index2] = route[index2], route[index1]

# Function to evaluate the fitness of a route
def evaluate_fitness(route):
    return 1 / total_distance(route)

# Function to perform the genetic algorithm
def genetic_algorithm(num_generations, population_size):
    population = generate_population(population_size)
    pool = mp.Pool(num_processes)

    for _ in range(num_generations):
        fitness_scores = pool.map(evaluate_fitness, population)
        population_with_fitness = list(zip(population, fitness_scores))
        population_with_fitness.sort(key=lambda x: x[1], reverse=True)

        fittest_route = population_with_fitness[0][0]
        fittest_fitness = population_with_fitness[0][1]
        print("Generation:", _, "Fittest Route:", fittest_route, "Fitness:", fittest_fitness)

        if fittest_fitness >= 1:
            break

        selected_population = [route for route, _ in population_with_fitness[:population_size // 2]]
        offspring_population = []

        for _ in range(population_size // 2):
            parent1, parent2 = random.sample(selected_population, 2)
            offspring = crossover(parent1, parent2)
            mutate(offspring)
            offspring_population.append(offspring)

        population = selected_population + offspring_population

    pool.close()
    pool.join()

    return fittest_route

# Run the genetic algorithm
fittest_route = genetic_algorithm(num_generations, population_size)
print("Shortest Route:", fittest_route)
print("Total Distance:", total_distance(fittest_route))


def rgb_to_hex(red, green, blue):
    # Check if the RGB values are within the valid range (0-255)
    if not (0 <= red <= 255) or not (0 <= green <= 255) or not (0 <= blue <= 255):
        raise ValueError("RGB values must be between 0 and 255")

    # Convert the RGB values to hexadecimal
    hex_value = "#{:02x}{:02x}{:02x}".format(red, green, blue)

    return hex_value


sentence = "He's fooling around with his friends."
informal_words = {
 "fooling": "goofing",
 "'s": "is"
}
for word in informal_words:
 sentence = sentence.replace(word, informal_words[word])
print(sentence)


def timestamp_diff(timestamp1, timestamp2):
    diff = abs(timestamp1 - timestamp2)  # Calculate the absolute difference between the two timestamps
    diff_minutes = diff // 60  # Convert the difference from seconds to minutes
    return diff_minutes


import unicodedata

def count_occurrences(string, letter):
    # Normalize the string and convert both the string and letter to lowercase
    normalized_string = unicodedata.normalize('NFD', string).lower()
    normalized_letter = unicodedata.normalize('NFD', letter).lower()
    
    count = 0
    for char in normalized_string:
        if char == normalized_letter:
            count += 1
    
    return count


def bubble_sort_descending(arr):
    n = len(arr)
    iterations = min(n, 100)  # Limiting the maximum iterations to 100

    for i in range(iterations):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] < arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        if not swapped:
            break

    return arr


def remove_elements(lst):
    counts = {}
    
    for num in lst:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1
    
    result = []
    for num in lst:
        if counts[num] <= 5:
            result.append(num)
    
    return result

# Test the function
input_list = [1,2,3,1,1,1,2]
print(remove_elements(input_list))


import json

# Initialize the JSON object to store student records
student_records = {}

# Function to add a new student
def add_student(name, age, address, grades):
    # Generate a unique student ID
    student_id = len(student_records) + 1
    
    # Create a new student record
    student = {
        "name": name,
        "age": age,
        "address": address,
        "grades": grades
    }
    
    # Add the student to the JSON object
    student_records[student_id] = student
    
    return student_id

# Function to retrieve student details
def get_student_details(student_id):
    # Check if the student ID exists
    if student_id in student_records:
        return student_records[student_id]
    else:
        return "Student not found"

# Function to update student details
def update_student_details(student_id, name, age, address, grades):
    # Check if the student ID exists
    if student_id in student_records:
        # Update the student details
        student_records[student_id]["name"] = name
        student_records[student_id]["age"] = age
        student_records[student_id]["address"] = address
        student_records[student_id]["grades"] = grades
        return "Student details updated"
    else:
        return "Student not found"

# Function to delete a student
def delete_student(student_id):
    # Check if the student ID exists
    if student_id in student_records:
        # Remove the student from the JSON object
        del student_records[student_id]
        return "Student deleted"
    else:
        return "Student not found"

# Function to calculate average grade
def calculate_average_grade(student_id):
    # Check if the student ID exists
    if student_id in student_records:
        grades = student_records[student_id]["grades"]
        # Calculate the average grade
        average_grade = sum(grades) / len(grades)
        return average_grade
    else:
        return "Student not found"

# Function to list all students
def list_all_students():
    students_list = []
    # Iterate over the student records and add the student IDs and names to the list
    for student_id, student in student_records.items():
        students_list.append((student_id, student["name"]))
    return students_list

# Function to sort students by grade
def sort_students_by_grade():
    sorted_students = []
    # Iterate over the student records and add the student IDs to the list
    for student_id, student in sorted(student_records.items(), key=lambda x: sum(x[1]["grades"]), reverse=True):
        sorted_students.append(student_id)
    return sorted_students

# Example usage
student1_id = add_student("John Doe", 20, "123 Main St", [85, 90, 92])
student2_id = add_student("Jane Smith", 19, "456 Elm St", [78, 80, 87])

print(get_student_details(student1_id))
# Output: {'name': 'John Doe', 'age': 20, 'address': '123 Main St', 'grades': [85, 90, 92]}

update_student_details(student1_id, "John Doe Jr.", 21, "123 Main St", [90, 92, 95])
print(get_student_details(student1_id))
# Output: {'name': 'John Doe Jr.', 'age': 21, 'address': '123 Main St', 'grades': [90, 92, 95]}

delete_student(student2_id)
print(list_all_students())
# Output: [(1, 'John Doe Jr.')]


import requests

# API endpoint URL
url = 'https://api.twitter.com/1.1/statuses/user_timeline.json'

# Parameters for the API request
params = {
    'screen_name': 'twitterapi',
    'count': 10
}

# Send a GET request to the API endpoint with the parameters
response = requests.get(url, params=params)

# Check if the request was successful (status code 200)
if response.status_code == 200:
    # Extract the JSON data from the response
    data = response.json()
    # Process the data as needed
    for tweet in data:
        print(tweet['text'])
else:
    print('Error:', response.status_code)


def calculate_sum(row):
    sorted_row = sorted(set(row))
    row_sum = 0
    for element in sorted_row:
        row_sum += element
    return round(row_sum)

def sum_of_each_row(array):
    result = []
    for row in array:
        result.append(calculate_sum(row))
    return result

# Test the function with the given array
array = [[2, 5.5, 6], [-4, 1.3, 3], [5, -9, 0.7]]
print(sum_of_each_row(array))  # Output: [14, 0, -3]


import random
import string

def generate_random_string(n):
    characters = string.ascii_uppercase + string.ascii_lowercase + string.digits + string.punctuation
    random_string = ""

    for _ in range(n):
        random_index = random.randint(0, len(characters) - 1)
        random_string += characters[random_index]

    return random_string


def contains_in_order(array1, array2):
    # Initialize two pointers to keep track of the current positions in the arrays
    pointer1 = 0
    pointer2 = 0

    # Iterate through the first array
    while pointer1 < len(array1):
        # If the current element in the first array matches the current element in the second array,
        # move the second pointer forward
        if array1[pointer1] == array2[pointer2]:
            pointer2 += 1

            # If we have reached the end of the second array, it means that all the elements in the second array
            # were found in the first array in the correct order, so we return True
            if pointer2 == len(array2):
                return True

        # Move the first pointer forward
        pointer1 += 1

    # If we have reached the end of the first array without finding all the elements in the second array in the
    # correct order, we return False
    return False


import heapq

def trapRainWater(heightMap):
    m, n = len(heightMap), len(heightMap[0])
    pq = []
    visited = [[False] * n for _ in range(m)]

    for i in range(m):
        heapq.heappush(pq, (heightMap[i][0], i, 0))
        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))
        visited[i][0] = visited[i][n - 1] = True

    for i in range(1, n - 1):
        heapq.heappush(pq, (heightMap[0][i], 0, i))
        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))
        visited[0][i] = visited[m - 1][i] = True

    water, maxHeight = 0, 0
    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))

    while pq:
        h, r, c = heapq.heappop(pq)
        maxHeight = max(maxHeight, h)
        for dx, dy in dirs:
            x, y = r + dx, c + dy
            if x < 0 or x >= m or y < 0 or y >= n or visited[x][y]:
                continue
            if heightMap[x][y] < maxHeight:
                water += maxHeight - heightMap[x][y]
            heapq.heappush(pq, (heightMap[x][y], x, y))
            visited[x][y] = True

    return water


from datetime import datetime

def insert_product(product_data, connection):
    try:
        # Get the MongoDB database and collection
        db = connection['your_database_name']
        products_collection = db['products']

        # Check if the collection exists, create it if not
        if 'products' not in db.list_collection_names():
            db.create_collection('products')

        # Check if a product with the same name already exists
        existing_product = products_collection.find_one({'name': product_data['name']})

        if existing_product:
            # Update the existing product with the new data and set the updated_at field
            product_data['updated_at'] = datetime.now()
            products_collection.update_one({'name': product_data['name']}, {'$set': product_data})
        else:
            # Insert the product data into the collection and set the created_at and updated_at fields
            product_data['created_at'] = datetime.now()
            product_data['updated_at'] = datetime.now()
            products_collection.insert_one(product_data)

        return True
    except Exception as e:
        print(f"Error occurred: {e}")
        return False


def string_formatter(s):
    words = []
    word = ''
    for char in s:
        if char.isalpha():
            word += char.lower()
        elif word:
            words.append(word)
            word = ''
    if word:
        words.append(word)

    # Remove duplicates
    unique_words = []
    for word in words:
        if word not in unique_words:
            unique_words.append(word)

    # Sort words alphabetically
    sorted_words = sorted(unique_words)

    return sorted_words


fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(index, fruit)


import string

def check_string(input_string):
    if not input_string:
        raise ValueError("Input string cannot be empty")

    if len(input_string) > 1000000:
        raise ValueError("Input string is too large")

    uppercase_count = 0
    has_lowercase = False
    has_digit = False
    has_special = False

    for char in input_string:
        if char.isupper():
            uppercase_count += 1
        elif char.islower():
            has_lowercase = True
        elif char.isdigit():
            has_digit = True
        elif char in string.punctuation:
            has_special = True

    if not (has_lowercase and has_digit and has_special):
        return False

    return uppercase_count


import math

def filter_and_sum(numbers):
    filtered_numbers = []
    for num in numbers:
        if 100 < num < 1000:
            filtered_numbers.append(num)
    
    filtered_numbers.sort(reverse=True)
    
    sum_of_square_roots = 0
    for num in filtered_numbers:
        sum_of_square_roots += math.sqrt(num)
    
    return round(sum_of_square_roots, 10)


import re

def compute_sum(num1, num2):
    if not num1 or not num2:
        return None
    
    num1 = convert_to_number(num1)
    num2 = convert_to_number(num2)
    
    if num1 is None or num2 is None:
        return None
    
    return round(sum_recursive(num1, num2), 2)

def sum_recursive(num1, num2, carry=0, result=0, decimal_place=1):
    if num1 == 0 and num2 == 0 and carry == 0:
        return result
    
    digit1, num1 = num1 % 10, num1 // 10
    digit2, num2 = num2 % 10, num2 // 10
    
    total = digit1 + digit2 + carry
    carry = total // 10
    digit_sum = total % 10
    
    if decimal_place == 1:
        result += digit_sum
    else:
        result += digit_sum / decimal_place
        
    return sum_recursive(num1, num2, carry, result, decimal_place * 10)

def convert_to_number(num_str):
    try:
        num = int(num_str)
        if -100 <= num <= 100:
            return num
    except ValueError:
        pass
    
    try:
        num = float(num_str)
        if -100 <= num <= 100:
            return num
    except ValueError:
        pass
    
    return None

# Test Cases
print(compute_sum("12", "34"))  # Output: 46.00
print(compute_sum("-10", "10.5"))  # Output: 0.50
print(compute_sum("100", "1000"))  # Output: None (outside the range)
print(compute_sum("3,000", "5,000"))  # Output: None (invalid character)
print(compute_sum("0x10", "0b11"))  # Output: None (invalid number system)
print(compute_sum("1.23e-10", "0.000001"))  # Output: 0.00
print(compute_sum("1,000,000.12", "-100,000.50"))  # Output: 900000.62
print(compute_sum("1234567890", "9876543210"))  # Output: None (very large numbers)


def count_substring_occurrences(string, substring):
    if len(substring) == 0 or len(substring) > len(string):
        return -1

    string = string.strip()

    start = end = 0
    count = 0

    while end < len(string):
        if string[end:end + len(substring)] == substring:
            count += 1
            start = end + len(substring)
            end = start
        else:
            end += 1

    return count


import random
import time
import multiprocessing

# Game of Life class
class GameOfLife:
    def __init__(self, size, iterations):
        self.size = size
        self.iterations = iterations
        self.grid = [[0] * size for _ in range(size)]
        self.live_count = 0

    def initialize_grid(self, pattern):
        if pattern == "glider":
            self.add_glider()
        elif pattern == "random":
            self.randomize_grid()
        # Add more patterns as needed

    def add_glider(self):
        # Add glider pattern to the grid
        # ...

    def randomize_grid(self):
        # Randomize the initial state of the grid
        # ...

    def calculate_live_count(self):
        self.live_count = sum(sum(row) for row in self.grid)

    def update_grid(self):
        new_grid = [[0] * self.size for _ in range(self.size)]
        # Update the grid based on the Game of Life rules and additional rules
        # ...

    def simulate(self):
        for _ in range(self.iterations):
            self.update_grid()
            self.calculate_live_count()
            # Display the grid and live count
            # ...
            time.sleep(1)  # Adjust the delay as needed

    def save_grid(self, filename):
        # Save the final state of the grid to a file
        # ...

    def load_grid(self, filename):
        # Load a grid state from a file
        # ...

    def change_rules(self, new_rules):
        # Change the rules of the game dynamically
        # ...

    def manipulate_cell(self, x, y):
        # Manually manipulate the state of a cell
        # ...


# GUI class (using Tkinter)
class GUI:
    def __init__(self):
        # Initialize the GUI
        # ...

    def display_grid(self, grid):
        # Display the grid in the GUI
        # ...

    def interact(self):
        # Allow user interaction with the simulation (pausing, resuming, resetting, etc.)
        # ...


# Parallel simulation
def parallel_simulation(game_of_life):
    # Perform parallel simulation using multi-threading or multiprocessing
    # ...


# Example usage
if __name__ == "__main__":
    size = int(input("Enter the size of the grid: "))
    iterations = int(input("Enter the number of iterations: "))
    pattern = input("Enter the initial pattern (glider/random): ")
    game_of_life = GameOfLife(size, iterations)
    game_of_life.initialize_grid(pattern)

    # Run simulation in parallel
    processes = []
    for _ in range(multiprocessing.cpu_count()):
        process = multiprocessing.Process(target=parallel_simulation, args=(game_of_life,))
        process.start()
        processes.append(process)

    # Wait for all processes to finish
    for process in processes:
        process.join()

    # Save the final state of the grid
    filename = input("Enter the filename to save the final grid state: ")
    game_of_life.save_grid(filename)

    # Start the GUI
    gui = GUI()
    gui.display_grid(game_of_life.grid)
    gui.interact()


import re

string = "hello world"
substring = "lo"
pattern = r"(?=.*?hel)hel.*?lo.*?(?=wor.*?)(?=.*?wor)wor"

match = re.search(pattern, string)
if match:
    print("Substring found!")
else:
    print("Substring not found!")


import re

pattern = r"(.*ABC){2,}.*"
regex = re.compile(pattern)

# Test the regex on some sample strings
strings = ["AABBCC", "ABCABC", "ABCAAAABC", "ABC", "AAABBBCCC"]
for string in strings:
    match = regex.search(string)
    if match:
        print(f"{string} matches: {match.group()}")
    else:
        print(f"{string} does not match")


class BitwiseCalculator:
    @staticmethod
    def add(x, y):
        while y != 0:
            carry = x & y
            x = x ^ y
            y = carry << 1
        return x

    @staticmethod
    def subtract(x, y):
        while y != 0:
            borrow = (~x) & y
            x = x ^ y
            y = borrow << 1
        return x

    @staticmethod
    def multiply(x, y):
        result = 0
        while y != 0:
            if y & 1:
                result = BitwiseCalculator.add(result, x)
            x = x << 1
            y = y >> 1
        return result


def generate_sequence():
    sequence = [0, 1]
    for i in range(2, 10):
        sequence.append(sequence[i-1] + sequence[i-2])
    sequence[5] = "?"
    return sequence
print(generate_sequence())


def spiral_array(input_array):
    rows = len(input_array)
    cols = len(input_array[0])
    spiral = []
    
    top_row = 0
    bottom_row = rows - 1
    left_col = 0
    right_col = cols - 1
    
    while top_row <= bottom_row and left_col <= right_col:
        # Traverse the top row
        for i in range(left_col, right_col + 1):
            spiral.append(input_array[top_row][i])
        top_row += 1
        
        # Traverse the right column
        for i in range(top_row, bottom_row + 1):
            spiral.append(input_array[i][right_col])
        right_col -= 1
        
        # Check if there is still a row left to traverse
        if top_row <= bottom_row:
            # Traverse the bottom row
            for i in range(right_col, left_col - 1, -1):
                spiral.append(input_array[bottom_row][i])
            bottom_row -= 1
        
        # Check if there is still a column left to traverse
        if left_col <= right_col:
            # Traverse the left column
            for i in range(bottom_row, top_row - 1, -1):
                spiral.append(input_array[i][left_col])
            left_col += 1
    
    return spiral

# Example usage
input_array = [[1, 2, 3],
               [4, 5, 6],
               [7, 8, 9]]

spiral = spiral_array(input_array)
print(spiral)


def generate_primes(n):
    # Initialize a boolean array to track whether a number is prime or not
    is_prime = [True] * (n+1)
    is_prime[0] = is_prime[1] = False

    # Use the Sieve of Eratosthenes algorithm to mark non-prime numbers
    p = 2
    while p*p <= n:
        if is_prime[p]:
            for i in range(p*p, n+1, p):
                is_prime[i] = False
        p += 1

    primes = []
    prime_factors = {}

    # Generate the list of prime numbers and their factors
    for p in range(2, n+1):
        if is_prime[p]:
            primes.append(p)
            prime_factors[p] = []

    # Calculate the sum of prime numbers
    prime_sum = sum(primes)

    # Calculate the prime factors for each prime number
    for p in primes:
        for i in range(p, n+1, p):
            prime_factors[i].append(p)

    return {"primes": prime_factors, "sum": prime_sum}


class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

def delete_elements(head, value):
    # Handle the case where the head node itself has the value
    while head is not None and head.value == value:
        head = head.next
    
    # Start from the head node and iterate through the linked list
    current = head
    while current is not None and current.next is not None:
        # If the next node has the value, skip it by updating the current node's next pointer
        if current.next.value == value:
            current.next = current.next.next
        else:
            current = current.next
    
    return head


def convert_to_float(input_string):
    # Check for empty string
    if input_string.strip() == '':
        return None
    
    # Remove leading/trailing whitespace characters
    input_string = input_string.strip()
    
    # Check for multiple decimal points
    if input_string.count('.') > 1:
        return None
    
    # Check for negative sign in unexpected positions
    if input_string.startswith('-') or input_string.endswith('-'):
        return None
    if '--' in input_string or '-.' in input_string or '.-' in input_string:
        return None
    
    try:
        # Attempt to convert string to float
        result = float(input_string)
    except ValueError:
        # Handle ValueError if input_string is not a valid float
        return None
    
    return result


def compare_strings(string1, string2):
    # Check if the lengths of the strings are equal
    if len(string1) != len(string2):
        return False
    
    # Iterate through each character of both strings
    for i in range(len(string1)):
        # Check if the characters are different
        if string1[i] != string2[i]:
            return False
    
    # All characters are equal
    return True


def generate_fibonacci(n):
    fibonacci_series = [0, 1]  # Initialize the series with the first two numbers
    prime_sum = 0  # Initialize the sum of prime Fibonacci numbers
    
    while len(fibonacci_series) < n:
        next_number = fibonacci_series[-1] + fibonacci_series[-2]  # Generate the next Fibonacci number
        fibonacci_series.append(next_number)  # Add the number to the series
        
        if is_prime(next_number):  # Check if the number is prime
            prime_sum += next_number  # Add the number to the sum of prime Fibonacci numbers
    
    return fibonacci_series, prime_sum


def is_prime(num):
    if num < 2:  # Numbers less than 2 are not prime
        return False
    
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:  # If the number is divisible by any number in the range, it is not prime
            return False
    
    return True


import mysql.connector
from mysql.connector import Error

try:
    # Establish database connection
    connection = mysql.connector.connect(
        host='your_host',
        database='your_database',
        user='your_user',
        password='your_password'
    )
    
    # Create a cursor object to execute queries
    cursor = connection.cursor()

    # Define the genre
    genre = 'fiction'

    # Retrieve books that meet the given conditions
    query = """
        SELECT *
        FROM Books
        WHERE publication_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH)
        AND average_rating > 4
        AND genre = %s
    """
    cursor.execute(query, (genre,))

    # Fetch all the rows as a list of tuples
    books = cursor.fetchall()

    # Print the retrieved data
    for book in books:
        print(book)

except Error as e:
    print("Error connecting to MySQL database", e)

finally:
    # Close the cursor and database connection
    if connection.is_connected():
        cursor.close()
        connection.close()


import string

def contains_a_as_second_letter(strings):
    for string in strings:
        # Ignore strings that start with a lowercase letter or end with a punctuation mark
        if string[0].islower() or string[-1] in string.punctuation:
            continue
        
        # Check if the second letter is 'a'
        if len(string) > 1 and string[1] == 'a':
            return True
    
    return False


def format_date(date):
    # Create a dictionary to map month names to their two-digit numbers
    month_dict = {
        'January': '01', 'February': '02', 'March': '03', 'April': '04',
        'May': '05', 'June': '06', 'July': '07', 'August': '08',
        'September': '09', 'October': '10', 'November': '11', 'December': '12'
    }
    
    # Split the date string into month, day, and year
    parts = date.split()
    month = parts[0]
    day = parts[1].rstrip(',')
    year = parts[2]
    
    # Format the day as a two-digit number
    day = day.zfill(2)
    
    # Get the two-digit month number from the dictionary
    month = month_dict[month]
    
    # Concatenate the year, month, and day with hyphens
    formatted_date = f'{year}-{month}-{day}'
    
    return formatted_date


from typing import List

class WordList:
    def __init__(self, words: List[str]):
        self.words = words

    def add_word(self, word: str) -> bool:
        if word in self.words:
            return False
        self.words.append(word)
        return True

    def remove_word(self, word: str) -> bool:
        if word not in self.words:
            return False
        self.words.remove(word)
        return True

    def get_words_with_prefix(self, prefix: str) -> List[str]:
        return sorted([word for word in self.words if word.startswith(prefix)])

    def get_words_with_suffix(self, suffix: str) -> List[str]:
        return sorted([word for word in self.words if word.endswith(suffix)], reverse=True)

    def get_words_with_length(self, length: int) -> List[str]:
        return sorted([word for word in self.words if len(word) == length])

    def get_words_containing(self, substring: str) -> List[str]:
        return sorted([word for word in self.words if substring in word])

    def get_words_starting_with_vowel(self) -> List[str]:
        vowels = ['a', 'e', 'i', 'o', 'u']
        return sorted([word for word in self.words if word[0].lower() in vowels])

    def get_words_ending_with_consonant(self) -> List[str]:
        vowels = ['a', 'e', 'i', 'o', 'u']
        return sorted([word for word in self.words if word[-1].lower() not in vowels])


def dot_product(array1, array2):
    # Check if the arrays have the same length
    if len(array1) != len(array2):
        raise ValueError("Arrays must have the same length")
    
    # Initialize the dot product to 0
    dot_product = 0
    
    # Calculate the dot product
    for i in range(len(array1)):
        dot_product += array1[i] * array2[i]
    
    return dot_product


def find_max_difference(arr):
    max_diff = 0
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            diff = abs(arr[i] - arr[j])  # Take the absolute difference
            if diff > max_diff:
                max_diff = diff
    return max_diff


import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from sklearn.model_selection import StratifiedKFold
from sklearn.model_selection import RandomizedSearchCV
from tensorflow.keras.preprocessing.image import ImageDataGenerator


class IntegerSet:
    def __init__(self):
        self.capacity = 100
        self.elements = []

    def add(self, element):
        if not isinstance(element, int):
            raise ValueError("Only integers are allowed in the set.")
        if len(self.elements) >= self.capacity:
            raise ValueError("The set is already at its maximum capacity.")
        self.elements.append(element)

    def remove_duplicates(self):
        self.elements = list(set(self.elements))

    def get_sum(self):
        return sum(self.elements)

    def get_smallest(self):
        if len(self.elements) == 0:
            raise ValueError("The set is empty.")
        return min(self.elements)

    def get_largest(self):
        if len(self.elements) == 0:
            raise ValueError("The set is empty.")
        return max(self.elements)

    def contains(self, element):
        return element in self.elements

    def sort(self):
        self.elements.sort()


myFunction("example")


def binary_search(arr, target):
    # Check if list contains only one item
    if len(arr) == 1:
        return arr[0] == target
    
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return True
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
            
    return False


def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1


import heapq
def second_smallest(numbers):
 return heapq.nsmallest(2, numbers)[1]
numbers = [5, 3, 8, 1, 9, 2, 7]
print("The second smallest number in the list is:", second_smallest(numbers))


def quicksort(arr, low, high):
    if low < high:
        pivot_index = partition(arr, low, high)
        quicksort(arr, low, pivot_index - 1)
        quicksort(arr, pivot_index + 1, high)

def partition(arr, low, high):
    pivot = arr[high]
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def sort_array(arr):
    quicksort(arr, 0, len(arr) - 1)

# Example usage:
arr = [7, 2, 1, 6, 8, 5, 3, 4]
sort_array(arr)
print(arr)


def calculate_sum(numbers):
    total = 0
    for num in numbers:
        if num % 3 != 0:
            total += num
    return total

numbers = [-1, 2, -3, 4]
print(calculate_sum(numbers))  # Output: 2

numbers = [5, 9, 2, 18, -6]
print(calculate_sum(numbers))  # Output: 16


import sys
sys.setrecursionlimit(1000)

def factorial(n):
    if not isinstance(n, int) or n < 0:
        return "Error: Input should be a positive integer."
    elif n == 0:
        return 1
    else:
        return n * factorial(n-1)


def factorial(n):
    if n == 0 or n == 1:  # Base case: factorial of 0 or 1 is 1
        return 1
    else:  # Recursive case: factorial of n is n * factorial(n-1)
        return n * factorial(n-1)


MOD = 10**9 + 7
MAX = 1001

def ways(startPos, endPos, k, dp):
    if k == 0: return 1 if startPos == endPos else 0
    if startPos < 0 or endPos < 0 or startPos >= MAX or endPos >= MAX: return 0
    
    if dp[startPos][k] != -1: return dp[startPos][k]
    
    left = ways(startPos - 1, endPos, k - 1, dp)
    right = ways(startPos + 1, endPos, k - 1, dp)
    
    dp[startPos][k] = (left + right) % MOD
    return dp[startPos][k]

def numberOfWays(startPos, endPos, k):
    dp = [[-1 for _ in range(k + 1)] for _ in range(MAX)]
    return ways(startPos, endPos, k, dp)


import math

def calculate_circle_properties(radius):
    # Validate the input
    if radius <= 0:
        raise ValueError("Invalid input: radius must be positive")

    # Calculate the area
    area = math.pi * radius**2

    # Calculate the circumference
    circumference = 2 * math.pi * radius

    return area, circumference

# Example usage
try:
    radius = float(input("Enter the radius of the circle: "))
    area, circumference = calculate_circle_properties(radius)
    print("Area:", area)
    print("Circumference:", circumference)
except ValueError as e:
    print("Error:", e)


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
            new_node.prev = current

    def display(self):
        current = self.head
        while current:
            print(current.data, end=" ")
            current = current.next
        print()

    def bubble_sort(self):
        if self.head is None:
            return

        sorted = False
        while not sorted:
            sorted = True
            current = self.head
            while current.next:
                if current.data > current.next.data:
                    current.data, current.next.data = current.next.data, current.data
                    sorted = False
                current = current.next

# Test the implementation
linked_list = DoublyLinkedList()
linked_list.append(9)
linked_list.append(5)
linked_list.append(1)
linked_list.append(7)
linked_list.append(3)
linked_list.display()  # Output: 9 5 1 7 3

linked_list.bubble_sort()
linked_list.display()  # Output: 1 3 5 7 9


def evaluate_length(arr):
    return len(arr)


def modify_array(arr, constant):
    if constant == 0:
        arr = [0] * len(arr)
    else:
        arr = [num * constant for num in arr]
        
        if constant < 0:
            arr = arr[::-1]
    
    return arr

arr = [3, 7, 8]
constant = -4
modified_arr = modify_array(arr, constant)
print(modified_arr)


import random
import time

# Function to generate the secret code
def generate_secret_code():
    colors = ['R', 'G', 'B', 'Y', 'O', 'P']  # Red, Green, Blue, Yellow, Orange, Purple
    secret_code = random.sample(colors, 4)  # Select 4 colors randomly from the list
    return secret_code

# Function to check the correctness of the guess
def check_guess(guess, secret_code):
    correct_color_position = 0
    correct_color = 0
    for i in range(len(secret_code)):
        if guess[i] == secret_code[i]:
            correct_color_position += 1
        elif guess[i] in secret_code:
            correct_color += 1
    return correct_color_position, correct_color

# Function to print the game instructions
def print_instructions():
    print("Welcome to Mastermind!")
    print("The secret code contains 4 colors from the following options:")
    print("R -> Red, G -> Green, B -> Blue, Y -> Yellow, O -> Orange, P -> Purple")
    print("The code may contain duplicate colors.")
    print("You need to guess the secret code within the given attempts.")
    print("For each guess, you will receive feedback on the number of correct colors in correct positions")
    print("and the number of correct colors in wrong positions.")
    print("Good luck!")

# Function to play the game
def play_game(attempts):
    print_instructions()
    secret_code = generate_secret_code()
    print("The secret code has been generated. Let's begin!")
    print()

    for attempt in range(1, attempts + 1):
        print("Attempt", attempt)
        guess = input("Enter your guess: ").upper()
        start_time = time.time()

        # Check if the response time exceeds 30 seconds
        while time.time() - start_time > 30:
            print("Oops! Time's up. You took too long to respond.")
            guess = input("Enter your guess: ").upper()
            start_time = time.time()

        correct_color_position, correct_color = check_guess(guess, secret_code)

        if correct_color_position == 4:
            print("Congratulations! You guessed the secret code correctly!")
            print("You win!")
            return

        print("Correct color in correct position:", correct_color_position)
        print("Correct color in wrong position:", correct_color)
        print()

    print("Sorry, you ran out of attempts.")
    print("The secret code was:", secret_code)
    print("Better luck next time!")

# Main function
def main():
    print("Welcome to Mastermind!")
    attempts = int(input("Enter the number of attempts (minimum 5): "))
    if attempts < 5:
        attempts = 5
    play_game(attempts)

if __name__ == '__main__':
    main()


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_numbers(start, end):
    primes = []
    if start <= 2 and end >= 2:
        primes.append(2)
    
    if start % 2 == 0:
        start += 1

    for num in range(start, end + 1, 2):
        if is_prime(num):
            primes.append(num)
    
    return primes


list_a = [1, 2, 3, 4, 5]
list_b = [6, 7, 8, 9, 10]

# Step 1: Merge the lists
list_a.extend(list_b)

# Step 2: Sort the merged list in descending order (using Bubble Sort)
n = len(list_a)
for i in range(n):
    for j in range(0, n-i-1):
        if list_a[j] < list_a[j+1]:
            list_a[j], list_a[j+1] = list_a[j+1], list_a[j]

print(list_a)


def find_smallest_positive_integer(lst):
    # Remove duplicates and sort the list in ascending order
    lst = sorted(set(lst))
    
    # Check if the list is empty or if the first element is greater than 1
    if not lst or lst[0] > 1:
        return 1
    
    # Iterate through the sorted list and find the first gap between consecutive elements
    for i in range(len(lst) - 1):
        if lst[i+1] - lst[i] > 1:
            return lst[i] + 1
    
    # If there are no gaps, return the next positive integer after the last element
    return lst[-1] + 1


import time

def solve_sudoku(board, time_limit):
    start_time = time.time()
    n = len(board)
    empty_cells = find_empty_cells(board)
    
    if backtracking(board, empty_cells, n, start_time, time_limit):
        return board
    else:
        return None

def backtracking(board, empty_cells, n, start_time, time_limit):
    if time.time() - start_time >= time_limit:
        return False

    if not empty_cells:
        return True
    
    row, col = empty_cells.pop(0)
    for num in range(1, n+1):
        if is_valid(board, row, col, num):
            board[row][col] = num
            if backtracking(board, empty_cells, n, start_time, time_limit):
                return True
            board[row][col] = 0
    
    empty_cells.insert(0, (row, col))
    return False

def is_valid(board, row, col, num):
    n = len(board)
    # Check row and column
    for i in range(n):
        if board[row][i] == num or board[i][col] == num:
            return False
    # Check box
    box_size = int(n ** 0.5)
    start_row = (row // box_size) * box_size
    start_col = (col // box_size) * box_size
    for i in range(start_row, start_row + box_size):
        for j in range(start_col, start_col + box_size):
            if board[i][j] == num:
                return False
    return True

def find_empty_cells(board):
    empty_cells = []
    for i in range(len(board)):
        for j in range(len(board)):
            if board[i][j] == 0:
                empty_cells.append((i, j))
    return empty_cells


def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def print_twin_primes(limit):
    for n in range(3, limit + 1):
        if is_prime(n) and is_prime(n + 2):
            print(f"({n}, {n + 2})")

print_twin_primes(10000)


import hashlib
import binascii
import os
import hashlib
import hmac
# Define the passphrase words
words = ['elephant', 'giraffe', 'kangaroo', 'rhinoceros', 'zebra']
# Compute the SHA-256 hash of each word
hashes = [hashlib.sha256(word.encode()).digest() for word in words]
# Concatenate the hash values
concatenated = b''.join(hashes)
# Define the salt value
salt = b'salt1234'
# Derive the passphrase using PBKDF2
passphrase = hashlib.pbkdf2_hmac('sha256', concatenated, salt, 1000)
# Convert the passphrase to a string
passphrase_str = binascii.hexlify(passphrase).decode()
print('Passphrase:', passphrase_str)


def min_moves(n):
    dp = [0, 1] + [0] * (n - 1)

    for i in range(2, n + 1):
        dp[i] = i
        for x in range(1, i):
            broken = x - 1
            unbroken = i - x
            dp[i] = min(dp[i], 1 + max(dp[broken], dp[unbroken]))

    return dp[n]


import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.datasets import mnist
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import EarlyStopping, LearningRateScheduler
from tensorflow.keras.regularizers import l2

# Load and preprocess the MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()

x_train = x_train.reshape(-1, 28, 28, 1).astype("float32") / 255.0
x_test = x_test.reshape(-1, 28, 28, 1).astype("float32") / 255.0

# Data augmentation
datagen = ImageDataGenerator(
    rotation_range=15,
    zoom_range=0.1,
    width_shift_range=0.1,
    height_shift_range=0.1
)
datagen.fit(x_train)

# Define the CNN architecture
model = keras.Sequential()

model.add(layers.Conv2D(32, kernel_size=(3, 3), strides=(1, 1), padding="same", input_shape=(28, 28, 1)))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

model.add(layers.Conv2D(64, kernel_size=(3, 3), strides=(1, 1), padding="same"))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

model.add(layers.Conv2D(128, kernel_size=(3, 3), strides=(1, 1), padding="same"))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

model.add(layers.Conv2D(256, kernel_size=(3, 3), strides=(1, 1), padding="same"))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

model.add(layers.Conv2D(512, kernel_size=(3, 3), strides=(1, 1), padding="same"))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))

model.add(layers.Flatten())

model.add(layers.Dense(512))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.Dropout(0.5))

model.add(layers.Dense(512))
model.add(layers.BatchNormalization())
model.add(layers.Activation("relu"))
model.add(layers.Dropout(0.5))

model.add(layers.Dense(10, activation="softmax"))

# Define learning rate schedule
def lr_schedule(epoch, lr):
    if epoch % 10 == 0 and epoch > 0:
        lr *= 0.1
    return lr

# Define early stopping
early_stopping = EarlyStopping(monitor="val_loss", patience=5)

# Compile the model
model.compile(
    optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
    loss="sparse_categorical_crossentropy",
    metrics=["accuracy"]
)

# Train the model
history = model.fit(
    datagen.flow(x_train, y_train, batch_size=64),
    validation_data=(x_test, y_test),
    epochs=50,
    callbacks=[LearningRateScheduler(lr_schedule), early_stopping]
)

# Evaluate the model on the test set
_, test_accuracy = model.evaluate(x_test, y_test, verbose=0)
print("Test accuracy:", test_accuracy)


import random

def create_phone_number():
    first_digit = random.randint(2, 9)
    second_digit = random.randint(0, 1)
    third_digit = random.choice([2, 3, 4, 5, 6, 9])
    remaining_digits = random.choices(range(10), k=6)
    phone_number = [first_digit, second_digit, third_digit] + remaining_digits
    phone_number.sort() # Corrected line: Sorts the digits in non-decreasing order
    return "".join(map(str, phone_number))


import random
import string
import time


import json
# Example JSON data
data = '{"name": "John Smith", "age": 30, "location": {"city": "New York", "state": "New York", "country": "USA"}}'
# Load JSON data
json_data = json.loads(data)
# Extract location information
city = json_data["location"]["city"].lower()
state = json_data["location"]["state"].lower()
country = json_data["location"]["country"].lower()
# Print extracted information
print("City:", city)
print("State:", state)
print("Country:", country)


def parse_string(input_string):
    # Initialize an empty dictionary to store the key-value pairs
    result = {}

    # Split the input string into lines
    lines = input_string.split('\n')

    # Iterate through each line
    for line in lines:
        # Remove leading and trailing spaces from the line
        line = line.strip()

        # Ignore empty lines
        if not line:
            continue

        # Split the line at the first occurrence of '='
        parts = line.split('=', 1)

        # Ignore lines without '='
        if len(parts) != 2:
            continue

        # Extract the key and value from the parts
        key, value = parts

        # Remove leading and trailing spaces from the key and value
        key = key.strip()
        value = value.strip()

        # Check if the key is enclosed in quotes
        if key.startswith('"') and key.endswith('"'):
            key = key[1:-1]  # Remove the quotes

        # Check if the value is enclosed in quotes
        if value.startswith('"') and value.endswith('"'):
            value = value[1:-1]  # Remove the quotes

        # Store the value in the dictionary, overwriting any previous value for the same key
        result[key] = value

    return result


def findMax(arr):
    # Check for empty input array
    if len(arr) == 0:
        return None
    
    # Initialize maxElement as the first element of the array
    maxElement = arr[0]
    
    # Iterate over each element in the array starting from the second element
    for i in range(1, len(arr)):
        # Check if the current element is greater than maxElement
        if arr[i] > maxElement:
            # Update maxElement
            maxElement = arr[i]
    
    # Return the maximum element
    return maxElement


def is_palindrome(s):
    # Remove whitespace characters
    s = ''.join(s.split())

    # Remove punctuation marks
    punctuation = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
    s = ''.join(ch for ch in s if ch not in punctuation)

    # Convert string to lowercase
    s = s.lower()

    # Check if the string is a palindrome
    length = len(s)
    for i in range(length // 2):
        if s[i] != s[length - i - 1]:
            return False
    return True

# Test the program
string1 = "Racecar"
string2 = "A man a plan a canal Panama"
string3 = "Able, was I saw Elba"
string4 = "Hello, world!"

print(is_palindrome(string1))  # True
print(is_palindrome(string2))  # True
print(is_palindrome(string3))  # True
print(is_palindrome(string4))  # False


from collections import Counter

def find_second_most_frequent(arr):
    # Count the frequency of each element in the array
    counter = Counter(arr)
    
    # Get a list of elements with their frequencies in descending order
    frequencies = sorted(counter.items(), key=lambda x: x[1], reverse=True)
    
    # Find the second most frequent element that is not a duplicate
    for element, count in frequencies:
        if count > 1:
            return element


import math

def find_logarithm(num):
    if num == 0:
        return None
    elif num < 0:
        return "Invalid input"
    else:
        return math.log10(num)
    
number = 1000
logarithm = find_logarithm(number)
print(logarithm)


def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # Swap if the current element is smaller than the next element
            if arr[j] < arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Given array
arr = [8, 6, 7, 5, 4, 3, 1]

# Sort the array in descending order
bubble_sort(arr)

# Print the sorted array
print("Sorted array in descending order:", arr)


import colorsys
# Define the base color
base_color = (1.0, 0.75, 0.80) # This is a light pink color
# Define the number of shades you want to generate
num_shades = 10
# Define the range of darkness for the shades
min_darkness = 0.1
max_darkness = 0.9
# Calculate the increment of darkness for each shade
darkness_increment = (max_darkness - min_darkness) / num_shades
# Generate the shades of pink
for i in range(num_shades):
 darkness = min_darkness + i * darkness_increment
 color = colorsys.hsv_to_rgb(base_color[0], base_color[1], base_color[2] * darkness)
 print(color)


def decimal_to_binary(decimal, decimal_places=0):
    # Handle negative decimal numbers
    negative = False
    if decimal < 0:
        negative = True
        decimal = abs(decimal)
    
    # Convert the integer part of the decimal number to binary
    binary_integer = ''
    while decimal > 0:
        binary_integer = str(decimal % 2) + binary_integer
        decimal //= 2
    
    # Convert the fractional part of the decimal number to binary
    binary_fraction = ''
    if decimal_places > 0:
        binary_fraction += '.'
        while decimal_places > 0:
            decimal *= 2
            binary_fraction += str(int(decimal))
            decimal = decimal % 1
            decimal_places -= 1
    
    # Combine the integer and fractional parts
    binary = binary_integer + binary_fraction
    
    # Handle negative decimal numbers using two's complement
    if negative:
        binary = ''.join('1' if bit == '0' else '0' for bit in binary)
        binary = binary[:-1] + '1'
    
    return binary


def reverse_sentence(sentence):
    reversedSentence = ""
    start = -1
    end = -1

    for i in range(len(sentence)):
        if sentence[i] != " ":
            if start == -1:
                start = i
            end = i
        else:
            if start != -1:
                reversedSentence += sentence[start:end+1][::-1] + " "
                start = -1

    if start != -1:
        reversedSentence += sentence[start:end+1][::-1]

    return reversedSentence


import random

def create_matrix(rows, cols):
    matrix = []
    for _ in range(rows):
        row = []
        for _ in range(cols):
            value = random.randint(1, 10)
            row.append(value)
        matrix.append(row)
    return matrix


import re

def search_substrings(string, substrings):
    # Ignore case
    string = string.lower()
    substrings = [substring.lower() for substring in substrings]
    
    # Consider only alphanumeric characters
    string = re.sub(r'[^a-zA-Z0-9]', '', string)
    substrings = [re.sub(r'[^a-zA-Z0-9]', '', substring) for substring in substrings]
    
    # Initialize count dictionary
    count_dict = {substring: 0 for substring in substrings}
    
    # Search for substrings
    for substring in substrings:
        i = 0
        while i < len(string):
            index = string.find(substring, i)
            if index == -1:
                break
            count_dict[substring] += 1
            i = index + len(substring)
    
    return count_dict

# Test the program
string = "Hello, how are you? Are you doing well?"
substrings = ["how", "you", "doing well"]
count_dict = search_substrings(string, substrings)
for substring, count in count_dict.items():
    print(f"{substring}: {count}")


def print_spiral_matrix(n):
    matrix = [['' for _ in range(n)] for _ in range(n)]
    start_row = 0
    end_row = n - 1
    start_col = 0
    end_col = n - 1
    current_num = 1
    current_letter = ord('B')

    while current_num <= n * n:
        # Fill top row
        for j in range(start_col, end_col + 1):
            matrix[start_row][j] = chr(current_letter)
            current_num += 1
            current_letter += 1
        start_row += 1

        # Fill right column
        for i in range(start_row, end_row + 1):
            matrix[i][end_col] = chr(current_letter)
            current_num += 1
            current_letter += 1
        end_col -= 1

        # Fill bottom row
        for j in range(end_col, start_col - 1, -1):
            matrix[end_row][j] = chr(current_letter)
            current_num += 1
            current_letter += 1
        end_row -= 1

        # Fill left column
        for i in range(end_row, start_row - 1, -1):
            matrix[i][start_col] = chr(current_letter)
            current_num += 1
            current_letter += 1
        start_col += 1

    for row in matrix:
        print(' '.join(row))

n = int(input("Enter a positive integer (1 <= n <= 26): "))
print_spiral_matrix(n)


def calculate_gcd(a, b):
    # Convert negative numbers to positive
    a = abs(a)
    b = abs(b)

    # Base cases
    if a == 0:
        return b
    if b == 0:
        return a

    # Reduce larger number to smaller number
    if a > b:
        a, b = b, a

    # Apply Euclidean algorithm
    while b % a != 0:
        remainder = b % a
        b = a
        a = remainder

    return a


movies = [
 {"title": "The Jazz Singer", "year": 1927, "genre": "musical/drama", "country": "USA", "budget": 500000},
 {"title": "King Kong", "year": 1933, "genre": "adventure/fantasy", "country": "USA", "budget": 672000},
 {"title": "Snow White and the Seven Dwarfs", "year": 1937, "genre": "musical/fantasy", "country": "USA", "budget": 1499000},
 {"title": "Singin' in the Rain", "year": 1952, "genre": "musical/comedy", "country": "USA", "budget": 2543000},
 {"title": "Jurassic Park", "year": 1993, "genre": "sci-fi/adventure", "country": "USA", "budget": 63000000},
 {"title": "The Lord of the Rings: The Fellowship of the Ring", "year": 2001, "genre": "fantasy/adventure", "country": "New Zealand/USA", "budget": 93000000}
]
# Filter movies with budget of at least $5 million
movies = list(filter(lambda x: x["budget"] >= 5000000, movies))
# Sort movies by release date
movies.sort(key=lambda x: x["year"])
# Print table header
print("{:<50} {:<10} {:<20}".format("Title", "Budget", "Country"))
# Print each movie's information
for movie in movies:
 print("{:<50} ${:<10,} {:<20}".format(movie["title"], movie["budget"], movie["country"]))


def analyze_html(html):
    stack = []
    elements = []

    i = 0
    while i < len(html):
        if html[i] == '<':
            element = {}
            i += 1

            # Get element type
            start = i
            while html[i] != '>':
                i += 1
            element['type'] = html[start:i]

            # Get inner text content
            while html[i] in [' ', '\n']:
                i += 1
            start = i
            while html[i:i+2] != '</':
                i += 1
            element['inner_text'] = html[start:i]

            # Get attributes
            attributes = {}
            while html[i] != '>':
                while html[i] in [' ', '\n']:
                    i += 1
                start = i
                while html[i] not in [' ', '\n', '=', '>', '\'', '\"']:
                    i += 1
                attr_name = html[start:i]
                if html[i] == '=':
                    i += 1
                    while html[i] in [' ', '\n', '\'', '\"']:
                        i += 1
                    quote_char = html[i]
                    i += 1
                    start = i
                    while html[i] != quote_char:
                        i += 1
                    attr_value = html[start:i]
                    attributes[attr_name] = attr_value
                else:
                    attributes[attr_name] = None

            element['attributes'] = attributes

            if element['type'][-1] == '/':
                elements.append(element)
            else:
                stack.append(element)

        elif html[i:i+2] == '</':
            i += 2
            start = i
            while html[i] != '>':
                i += 1
            element = stack.pop()
            element['inner_text'] = html[start:i]
            elements.append(element)

        i += 1

    return elements

html_code = """
<div>
    <h3>Title</h3>
    <p>paragraph</p>
    <button>Button</button>
</div>
"""

elements = analyze_html(html_code)

for element in elements:
    print('Element Type:', element['type'])
    print('Inner Text:', element['inner_text'])
    print('Attributes:', element['attributes'])
    print()


import datetime
today = datetime.date.today()
future_date = today + datetime.timedelta(days=21)
print("Today's date:", today)
print("Date 21 days from now:", future_date)


sum = 0

for i in range(101):
    if i % 5 != 0:
        sum += i

print(sum)


import math

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

sum_of_squares = 0
count = 0

for i in range(1, 501):
    if is_prime(i):
        sum_of_squares += i ** 2
        count += 1

print("Sum of the squares of prime numbers between 1 and 500:", sum_of_squares)
print("Count of prime numbers between 1 and 500:", count)


def parse_url(url):
    # Find the protocol
    protocol_end = url.find("://")
    protocol = url[:protocol_end]
    remaining_url = url[protocol_end+3:]

    # Find the domain
    domain_end = remaining_url.find("/")
    domain = remaining_url[:domain_end]
    remaining_url = remaining_url[domain_end:]

    # Find the path
    path_end = remaining_url.find("?")
    if path_end == -1:
        path_end = remaining_url.find("#")
    if path_end == -1:
        path_end = len(remaining_url)
    path = remaining_url[:path_end]
    remaining_url = remaining_url[path_end:]

    # Find the query parameters
    query_params = {}
    if remaining_url.startswith("?"):
        query_end = remaining_url.find("#")
        if query_end == -1:
            query_end = len(remaining_url)
        query_string = remaining_url[1:query_end]
        query_pairs = query_string.split("&")
        for pair in query_pairs:
            key, value = pair.split("=")
            query_params[key] = value
        remaining_url = remaining_url[query_end:]

    # Find the hash fragment
    hash_fragment = ""
    if remaining_url.startswith("#"):
        hash_fragment = remaining_url[1:]

    # Create the result dictionary
    result = {
        "protocol": protocol,
        "domain": domain,
        "path": path,
        "query_params": query_params,
        "hash": hash_fragment
    }

    return result


def is_palindrome(string):
    # Remove special characters and whitespace
    string = ''.join(e for e in string if e.isalnum())

    # Convert the string to lowercase
    string = string.lower()

    # Check if the string is a palindrome
    for i in range(len(string) // 2):
        if string[i] != string[len(string) - i - 1]:
            return False
    return True

# Test the function
string = input("Enter a string: ")
if is_palindrome(string):
    print("The string is a palindrome")
else:
    print("The string is not a palindrome")


import re

def count_occurrences(sentence):
    # Remove special characters and emojis using regular expression
    cleaned_sentence = re.sub(r'[^\w\s\d\U0001F600-\U0001F64F\U0001F300-\U0001F5FF\U0001F680-\U0001F6FF\U0001F1E0-\U0001F1FF]+', '', sentence)
    
    # Convert the sentence to lowercase
    cleaned_sentence = cleaned_sentence.lower()
    
    # Split the sentence into individual words
    words = cleaned_sentence.split()
    
    # Create a dictionary to store the word counts
    word_counts = {}
    
    # Iterate through each word and count its occurrences
    for word in words:
        if word in word_counts:
            word_counts[word] += 1
        else:
            word_counts[word] = 1
    
    return word_counts

# Example usage
sentence = "This is a sample sentence! ð This is another sample sentence."
word_counts = count_occurrences(sentence)

# Print the word counts
for word, count in word_counts.items():
    print(f"{word}: {count} occurrence(s)")


import re
def sort_words(words, output_format='list'):
    # Remove any articles or prepositions from the words
    pattern = re.compile(r'\b(a|an|the|of|in|on)\b', re.IGNORECASE)
    words = [pattern.sub('', word) for word in words]
    
    # Sort the words in alphabetical order and remove duplicates
    words = sorted(set(words))
    
    # Output the sorted words in the desired format
    if output_format == 'list':
        return words
    elif output_format == 'table':
        table = ''
        for word in words:
            table += f'| {word} |\n'
        return table
    elif output_format == 'csv':
        csv = ','.join(words)
        return csv
    elif output_format == 'latex':
        latex = '\\begin{tabular}{|c|}\n\\hline\n'
        for word in words:
            latex += f'{word} \\\\ \\hline\n'
        latex += '\\end{tabular}'
        return latex
    else:
        return 'Invalid output format'


def multiply_two_numbers(a, b):
    if not isinstance(a, int) or not isinstance(b, int):
        return "Error: Both inputs must be integers."
    if not (-1000 <= a <= 1000) or not (-1000 <= b <= 1000):
        return "Error: Inputs must be within the range of -1000 to 1000."
    result = a * b
    if isinstance(result, float):
        result = round(result)
    return result


import re
from collections import Counter
text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium."
# Define regular expression pattern to match non-silent vowel and consonant combinations
pattern = re.compile(r'[bcdfghjklmnpqrstvwxyz]+[aeiou]+[bcdfghjklmnpqrstvwxyz]+', re.IGNORECASE)
# Find all matches in the text
matches = pattern.findall(text)
# Count the frequency of each match
freq = Counter(matches)
# Print the top 10 most frequent combinations
for combo, count in freq.most_common(10):
 print(combo, count)


def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def fibonacci(n):
    a, b = 0, 1
    while a <= n:
        if is_prime(a):
            print(a, end=' ')
        a, b = b, a + b

n = 10
fibonacci(n)


a = 45
b = '45'

if a < int(b):
    print("a is less than b")
else:
    print("a is greater than or equal to b")


def delete_items(dictionary):
    deleted_items = []
    keys_to_delete = []

    # Find keys to delete
    for key in dictionary.keys():
        if key.startswith('item') and key[-1].isdigit():
            keys_to_delete.append(key)

    # Delete keys and store deleted items
    for key in keys_to_delete:
        deleted_items.append((key, dictionary[key]))
        del dictionary[key]

    return deleted_items


def transform_string(s):
    transformed_string = ""
    for char in s:
        if char.islower():
            transformed_string += char.upper()
        elif char.isupper():
            transformed_string += char.lower()
    transformed_string = ''.join(sorted(transformed_string))
    return transformed_string


def is_palindrome(input_str):
    # Remove any spaces and convert all characters to lowercase
    input_str = input_str.replace(" ", "").lower()
    
    # Initialize two pointers at the beginning and end of the string
    left = 0
    right = len(input_str) - 1
    
    # Loop through the string until the pointers meet or cross each other
    while left < right:
        # If the characters at the two pointers are not the same, return False
        if input_str[left] != input_str[right]:
            return False
        left += 1
        right -= 1
    
    # If the loop completes without returning False, the string is a palindrome
    return True

# Test cases
print(is_palindrome("racecar"))  # True
print(is_palindrome("hello"))    # False
print(is_palindrome("A man a plan a canal Panama"))  # True


def insert_item_at_index(lst, item, index):
    if index < 0 or index > len(lst):
        return "Index out of bounds"
    
    if item in lst:
        return "Item already present in the list"
    
    lst.append(None)  # Add a placeholder at the end of the list
    
    for i in range(len(lst)-1, index, -1):
        lst[i] = lst[i-1]  # Shift elements to the right
    
    lst[index] = item  # Insert item at the specified index
    
    return lst


def bubble_sort(lst):
    n = len(lst)
    
    for i in range(n - 1):
        for j in range(n - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    
    return lst

my_list = [3, 8, 5, 4, 1, 9, 7]
sorted_list = bubble_sort(my_list)
print(sorted_list)


def remove_duplicates(nums):
    def remove_duplicates_recursive(nums, i, j):
        if i >= len(nums):
            return j
        
        if nums[i] != nums[j]:
            j += 1
            nums[j] = nums[i]
        
        return remove_duplicates_recursive(nums, i + 1, j)
    
    if len(nums) == 0:
        return []
    
    last_index = remove_duplicates_recursive(nums, 1, 0)
    return nums[:last_index + 1]


def find_uncommon_chars(str1, str2):
    """
    This function finds all uncommon characters between two strings.
    It uses a dictionary to keep track of the characters in the strings, which allows it to operate in O(n) time complexity.
    The function can handle strings of up to 1000 characters in length.

    Parameters:
    str1 (str): The first string.
    str2 (str): The second string.

    Returns:
    list: A list of all uncommon characters between the two strings.
    """

    # Create a dictionary to keep track of the characters in the strings
    char_dict = {}

    # Iterate over the characters in the first string
    for char in str1:
        # If the character is already in the dictionary, increment its count
        # Otherwise, add it to the dictionary with a count of 1
        char_dict[char] = char_dict.get(char, 0) + 1

    # Iterate over the characters in the second string
    for char in str2:
        # If the character is already in the dictionary, decrement its count
        # Otherwise, add it to the dictionary with a count of -1
        char_dict[char] = char_dict.get(char, 0) - 1

    # Find all characters that have a count of 1 or -1 in the dictionary
    # These are the characters that are unique to one of the strings
    uncommon_chars = [char for char, count in char_dict.items() if count == 1 or count == -1]

    return uncommon_chars


def find_numbers(numbers, target_sum):
    complements = set()
    max_product = float('-inf')
    max_numbers = []
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            for k in range(j+1, len(numbers)):
                complement = target_sum - (numbers[i] + numbers[j] + numbers[k])
                if complement in complements:
                    product = numbers[i] * numbers[j] * numbers[k]
                    if product > max_product:
                        max_product = product
                        max_numbers = [numbers[i], numbers[j], numbers[k]]
                complements.add(complement)
    return max_numbers

# Test the function
numbers = [3, 6, 2, 8, 4]
target_sum = 15
result = find_numbers(numbers, target_sum)
print(result)  # Output: [2, 6, 8]


from abc import ABC, abstractmethod

class AbstractSorter(ABC):
    @abstractmethod
    def sort(self, nums):
        pass

class CustomSorter(AbstractSorter):
    def sort(self, nums):
        n = len(nums)
        for i in range(n):
            for j in range(i+1, n):
                if nums[i] < nums[j]:
                    nums[i], nums[j] = nums[j], nums[i]
        return nums

# Example usage
nums = [5, 3, 8, 2, 1, 7]
sorter = CustomSorter()
sorted_nums = sorter.sort(nums)
print(sorted_nums)


def reverse_list(lst):
    left = 0
    right = len(lst) - 1
    
    while left < right:
        lst[left], lst[right] = lst[right], lst[left]
        left += 1
        right -= 1
    
    return lst.copy()


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def get_prime_numbers(numbers):
    prime_numbers = []
    for number in numbers:
        if is_prime(number):
            prime_numbers.append(number)
    return prime_numbers

# Taking input from the user
numbers = input("Enter a list of integers separated by space: ").split()
numbers = [int(num) for num in numbers]

prime_numbers = get_prime_numbers(numbers)
print("Prime numbers:", prime_numbers)


def usd_to_inr(amount_usd):
    ratio = 73.20
    amount_inr = amount_usd * ratio
    return amount_inr


from pymongo import MongoClient

# Connect to MongoDB
client = MongoClient("<mongodb_connection_string>")
db = client["<database_name>"]
collection = db["<collection_name>"]


def matrixReshape(mat, r, c):
    m, n = len(mat), len(mat[0])
    if m * n != r * c:
        return mat

    reshaped = [[0] * c for _ in range(r)]
    for i in range(m * n):
        reshaped[i // c][i % c] = mat[i // n][i % n]

    return reshaped


import math

def sum_of_primes(N):
    # Initialize a boolean array to mark all numbers as prime
    is_prime = [True] * (N+1)
    is_prime[0] = is_prime[1] = False

    # Loop through all numbers up to square root of N
    for i in range(2, int(math.sqrt(N))+1):
        if is_prime[i]:
            # Mark all multiples of i as non-prime
            for j in range(i*i, N+1, i):
                is_prime[j] = False

    # Calculate the sum of all prime numbers
    prime_sum = 0
    for i in range(2, N+1):
        if is_prime[i]:
            prime_sum += i

    return prime_sum

# Test the function
N = int(input("Enter the value of N: "))
print("Sum of prime numbers from 1 to", N, "is", sum_of_primes(N))


import re

def extract_dates(text):
    # Regular expression pattern to match different date formats
    date_pattern = r"\b(?:(?:\d{1,2}(?:st|nd|rd|th)?[-/ ])?(?:\d{1,2}(?:st|nd|rd|th)?[-/ ])?(?:\d{2,4}(?:\s+(?:AD|BC))?))?(?:(?:(?:\d{1,2}(?:st|nd|rd|th)?)[-/ ])?(?:\d{1,2}(?:st|nd|rd|th)?)[-/ ](?:\d{2,4}(?:\s+(?:AD|BC))?))?\b"

    # Extract dates using the date pattern
    dates = re.findall(date_pattern, text)

    return dates

# Test the program
text = "The conference will be held on Wednesday, June 16th, 2021, at 10:00 AM. However, please note that there are other events scheduled as well. For example, there will be a workshop on Friday, July 2nd, 2021, from 2:00 PM to 4:00 PM, and a networking event on Saturday, August 14th, 2021, starting at 6:00 PM."
dates = extract_dates(text)
print(dates)


def find_median(nums):
    nums.sort()  # Sort the array in ascending order
    median_index = (len(nums) - 1) // 2  # Find the middle index
    return nums[median_index]  # Return the value at the middle index

# Example usage
arr = [5, 2, 9, 1, 7]
median = find_median(arr)
print(median)  # Output: 5


# Create an empty dictionary
my_dict = {}

# Iterate over the range from 1 to 11 (excluding 11)
for i in range(1, 11):
    # Add key-value pair to the dictionary
    my_dict[i] = i ** 2

# Sort the dictionary based on values in descending order
sorted_dict = dict(sorted(my_dict.items(), key=lambda x: x[1], reverse=True))

# Print the sorted dictionary
print(sorted_dict)


def reverse_words(string):
    words = string.split()  # split the string into a list of words
    reversed_words = []
    
    for word in words:
        reversed_word = ""
        for i in range(len(word)-1, -1, -1):  # iterate over the characters of the word in reverse order
            reversed_word += word[i]  # append each character to the reversed_word
        reversed_words.append(reversed_word)  # append the reversed_word to the list of reversed words
    
    reversed_string = " ".join(reversed_words)  # join the reversed words with spaces to form a string
    
    return reversed_string


def rgb_to_hex(rgb):
    r, g, b = map(int, rgb)
    if r < 0 or r > 255 or g < 0 or g > 255 or b < 0 or b > 255:
        return "Error: RGB values must be between 0 and 255."
    
    r = round(r)
    g = round(g)
    b = round(b)
    
    hex_value = '#'
    
    for color in (r, g, b):
        hex_code = hex(color)[2:]
        if len(hex_code) == 1:
            hex_code = '0' + hex_code
        hex_value += hex_code
    
    return hex_value


rgb = (255.8, 205.3, 100.7)
hex_value = rgb_to_hex(rgb)
print(hex_value)


def split_string(string, delimiters):
    result = []
    delimiter_stack = []
    current_word = ""

    for char in string:
        if char in delimiters:
            if not delimiter_stack:
                result.append(current_word)
                current_word = ""
            else:
                current_word += char
        else:
            current_word += char

        if char in delimiters:
            delimiter_stack.append(char)
        elif delimiter_stack and char == delimiter_stack[-1]:
            delimiter_stack.pop()

    result.append(current_word)
    return result

string = "ABC,,,,DEF,XYZ///123"
delimiters = [",", "/"]
output = split_string(string, delimiters)
print(output)


import re

def count_unique_email_addresses(text):
    # Define the regular expression pattern to match email addresses
    pattern = r'[\w.-]+@[\w.-]+'

    # Compile the pattern into a regular expression object
    regex = re.compile(pattern)

    # Find all matches of the pattern within the text
    matches = regex.findall(text)

    # Remove duplicates and count unique email addresses
    unique_addresses = set(matches)
    total_unique_addresses = len(unique_addresses)

    # Print the email addresses found and the total count
    print("Email addresses found:")
    for address in unique_addresses:
        print("- " + address)
    print("\nTotal unique email addresses:", total_unique_addresses)

# Test the program with the given example input
text = """
Hello,

Please find attached the report for the month of January. It contains important information that needs to be reviewed.

If you have any questions, please email me at john.doe@example.com or contact our support team at support@example.com.

Thank you,
John Doe
"""

count_unique_email_addresses(text)


def find_longest_common_substring(string1, string2):
    # Initialize variables
    max_length = 0
    end_position = 0
    longest_substrings = []

    # Initialize matrix
    matrix = [[0] * (len(string2) + 1) for _ in range(len(string1) + 1)]

    # Iterate through each character position
    for i in range(1, len(string1) + 1):
        for j in range(1, len(string2) + 1):
            if string1[i-1] == string2[j-1]:
                matrix[i][j] = matrix[i-1][j-1] + 1
                if matrix[i][j] > max_length:
                    max_length = matrix[i][j]
                    end_position = (i, j)
                elif matrix[i][j] == max_length:
                    if string1[i-max_length:i] < string1[end_position[0]-max_length:end_position[0]]:
                        end_position = (i, j)
            else:
                matrix[i][j] = 0

    # Check if max_length is greater than or equal to 3
    if max_length >= 3:
        substring = string1[end_position[0]-max_length:end_position[0]]
        longest_substrings.append(substring)

    return longest_substrings

# Test the function
string1 = "Hello World! How are you?"
string2 = "Hello, World! I am fine, thank you!"
result = find_longest_common_substring(string1, string2)
print(result)  # Output: ['Hello']


class Node:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None
        self.prev = None

class LRUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}
        self.head = Node(None, None)
        self.tail = Node(None, None)
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def _add_node(self, node):
        node.next = self.head.next
        node.prev = self.head
        self.head.next.prev = node
        self.head.next = node

    def get(self, key):
        if key in self.cache:
            node = self.cache[key]
            self._remove_node(node)
            self._add_node(node)
            return node.value
        return None

    def put(self, key, value):
        if key in self.cache:
            node = self.cache[key]
            self._remove_node(node)
            node.value = value
            self._add_node(node)
        else:
            if len(self.cache) == self.capacity:
                del self.cache[self.tail.prev.key]
                self._remove_node(self.tail.prev)
            node = Node(key, value)
            self.cache[key] = node
            self._add_node(node)


import json

# JSON string
json_string = '''
{
    "name": "John Doe",
    "age": 25,
    "city": "New York"
}
'''

# Parse the JSON string
data = json.loads(json_string)

# Validate name field
if isinstance(data.get('name'), str):
    print("Name field is a string")
else:
    print("Name field is not a string")

# Validate age field
if isinstance(data.get('age'), int) and data.get('age') > 18:
    print("Age field is an integer greater than 18")
else:
    print("Age field is not an integer greater than 18")

# Validate city field
valid_cities = ["New York", "Los Angeles", "Chicago"]
if data.get('city') in valid_cities:
    print("City field is one of the valid cities")
else:
    print("City field is not one of the valid cities")


class Vehicle:
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year

    def start(self):
        pass

class Car(Vehicle):
    def start(self):
        print(f"Starting {self.make} {self.model}...")

class Truck(Vehicle):
    def start(self):
        print(f"Starting {self.make} {self.model} with Diesel Engine...")

class ElectricCar(Car):
    def start(self):
        print(f"Starting {self.make} {self.model} with Electric Motor...")


import re
import socket


def is_valid_email(email):
    # Check email syntax
    if not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', email):
        return False

    # Split email into username and domain
    username, domain = email.split('@')

    # Validate username format
    if not re.match(r'^[a-zA-Z0-9]+[a-zA-Z0-9\._-]*[a-zA-Z0-9]+$', username):
        return False

    # Validate domain name
    domain_parts = domain.split('.')
    if len(domain_parts) < 2:
        return False

    for part in domain_parts:
        if not re.match(r'^[a-zA-Z0-9-]+$', part):
            return False

    # Check if domain is registered and has a valid IP address
    try:
        socket.gethostbyname(domain)
    except socket.gaierror:
        return False

    return True


def capitalize_words(string):
    # Trim the input string
    string = string.strip()

    # Split the trimmed string into an array of words
    words = string.split()

    # Iterate over each word
    for i in range(len(words)):
        word = words[i]

        # Check if the first character is alphabetic
        if word[0].isalpha():
            # Capitalize the first character
            words[i] = word[0].capitalize() + word[1:]

    # Join the modified words back into a string
    capitalized_string = ' '.join(words)

    return capitalized_string


import random
list1 = ["I am setting out now", "The journey that awaits me", "The road calls out to me"]
list2 = ["Leaving behind my comfort zone", "Exploring the uncharted territories", "Seeking new horizons and frontiers"]
list3 = ["My heart beats with thrill and anticipation", "My senses come alive with excitement", "Adventure awaits and beckons me"]
def generate_haiku():
    line1 = random.choice(list1)
    line2 = random.choice(list2)
    line3 = random.choice(list3)
    return f"{line1}\n{line2}\n{line3}"
print(generate_haiku())


def find_kth_smallest_distinct_value(nums, k):
    # Sort the list
    nums.sort()

    # Use a hash set to keep track of distinct values
    distinct_values = set()

    # Iterate over the sorted list and add distinct values to the hash set
    for num in nums:
        distinct_values.add(num)

    # Convert the hash set back to a list and sort it
    distinct_values = sorted(list(distinct_values))

    # If k is larger than the number of distinct values, return -1
    if k > len(distinct_values):
        return -1

    # Return the kth smallest distinct value
    return distinct_values[k - 1]


def sum_of_squares(arr):
    total_sum = 0

    for num in arr:
        if isinstance(num, int) and num > 0:
            total_sum += num ** 2

    return total_sum


import requests
import json
from datetime import datetime, timedelta

# Function to fetch the authentication token
def get_token():
    token_endpoint = "https://auth.example.com/v1/token"
    response = requests.get(token_endpoint)
    token_data = response.json()
    return token_data["token"]

# Function to make the API call and fetch the data
def fetch_data():
    api_endpoint = "https://api.example.com/v1/search"
    token = get_token()
    
    headers = {
        "Authorization": "Bearer " + token
    }
    
    response = requests.get(api_endpoint, headers=headers)
    data = response.json()
    return data["results"]

# Function to sort the data based on the rating field
def sort_data(data):
    return sorted(data, key=lambda x: x["rating"])

# Function to check if the token is expired
def is_token_expired(token_data):
    expiration_time = datetime.strptime(token_data["expiration"], "%Y-%m-%d %H:%M:%S")
    current_time = datetime.now()
    return current_time > expiration_time

# Main program logic
data = fetch_data()

# Check if the token is expired and refresh if necessary
if is_token_expired(token_data):
    token_data = get_token()

sorted_data = sort_data(data)

# Print the sorted data
for item in sorted_data:
    print(item)


def find_pattern(numbers):
    patterns = {}  # Dictionary to store the identified patterns
    pattern_length = 2  # Minimum length of a pattern to be detected
    
    for i in range(len(numbers) - pattern_length):
        pattern = tuple(numbers[i:i+pattern_length])  # Extract pattern from the stream
        
        if pattern not in patterns:
            # Check if the pattern is already identified
            patterns[pattern] = i  # Store the starting index of the pattern
        
        else:
            # Pattern already identified, update its length and starting index
            pattern_start = patterns[pattern]
            pattern_length = i - pattern_start + pattern_length
    
    return numbers[:pattern_length] if pattern_length > 0 else None


# Test the program
stream = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 7, 8, 9]
pattern = find_pattern(stream)

if pattern:
    print("Pattern found:", pattern)
else:
    print("No pattern found.")


import re
from collections import Counter

def get_most_common_phrase(strings):
    # Regex pattern to match a phrase starting with a capital letter, ending with a punctuation mark, and containing at least three words
    pattern = r'[A-Z][^.!?]*[.!?]'

    # Combine all strings into a single string
    combined_string = ' '.join(strings)

    # Find all phrases matching the pattern
    phrases = re.findall(pattern, combined_string)

    # Filter out phrases that are less than 10 characters long or contain numbers or special characters
    filtered_phrases = [phrase.upper() for phrase in phrases if len(phrase) >= 10 and not any(char.isdigit() or not char.isalnum() for char in phrase)]

    # Count the occurrences of each phrase
    phrase_counts = Counter(filtered_phrases)

    # Exclude common English phrases
    excluded_phrases = ['I LOVE YOU', 'HELLO WORLD']  # Add more phrases if needed
    for phrase in excluded_phrases:
        phrase_counts.pop(phrase, None)

    # Get the most common phrase
    most_common_phrase = phrase_counts.most_common(1)

    if most_common_phrase:
        return most_common_phrase[0][0]
    else:
        return None


# Example usage
strings = [
    "Hello, how are you today? I am fine!",
    "I love you, my dear friend.",
    "This is a sample sentence.",
    "I cannot believe it's already December.",
    "Python is a great programming language."
]

most_common = get_most_common_phrase(strings)
print(most_common)


def binomial_coefficient(n, r):
    # Calculate the factorial of a number
    def factorial(num):
        if num == 0 or num == 1:
            return 1
        else:
            return num * factorial(num-1)

    # Calculate the binomial coefficient
    coefficient = factorial(n) // (factorial(r) * factorial(n-r))
    return coefficient

# Test the function
n = 10
r = 5
coefficient = binomial_coefficient(n, r)
print(coefficient)


def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a)

def find_gcd(array):
    if len(array) == 0:
        return "Array is empty"
    if len(array) == 1:
        return abs(array[0])
    
    result = abs(array[0])
    for i in range(1, len(array)):
        result = gcd(result, abs(array[i]))
    
    return result

# Test cases
array = [2, 4, 6, 8]
print(find_gcd(array))  # Output: 2

array = [3, 6, 9, 12]
print(find_gcd(array))  # Output: 3

array = [0, 0, 0, 0]
print(find_gcd(array))  # Output: 0

array = [-2, -4, -6, -8]
print(find_gcd(array))  # Output: 2

array = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
print(find_gcd(array))  # Output: 2

array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(find_gcd(array))  # Output: 1

array = [0, 1, -2, 3, -4, 5, -6, 7, -8, 9, -10]
print(find_gcd(array))  # Output: 1


class Node:
    def __init__(self, value):
        self.value = value
        self.prev = None
        self.next = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def insert(self, value, index):
        # Check if the index is out of bounds
        if index < 0:
            raise IndexError("Index out of bounds")
        
        # Create a new node with the given value
        new_node = Node(value)
        
        # Check if the list is empty
        if self.head is None:
            self.head = new_node
            self.tail = new_node
            return self

        # Find the node at the specified index
        current = self.head
        i = 0
        while current and i < index:
            current = current.next
            i += 1
        
        # Check if the index is out of bounds
        if not current:
            raise IndexError("Index out of bounds")
        
        # Check if the value already exists in the list
        if current.value == value:
            return self
        
        # Find the correct position to insert the new node
        if value >= current.value:
            while current.next and value >= current.next.value:
                current = current.next
        else:
            while current.prev and value < current.prev.value:
                current = current.prev
        
        # Insert the new node at the correct position
        if value >= current.value:
            new_node.prev = current
            new_node.next = current.next
            if current.next:
                current.next.prev = new_node
            else:
                self.tail = new_node
            current.next = new_node
        else:
            new_node.next = current
            new_node.prev = current.prev
            if current.prev:
                current.prev.next = new_node
            else:
                self.head = new_node
            current.prev = new_node
        
        return self

    def display(self):
        values = []
        current = self.head
        while current:
            values.append(current.value)
            current = current.next
        print(values)


sum = 0
for i in range(1, 11):
    print(i)
    if i % 2 == 0:
        sum += i


def remove_duplicates(arr):
    unique_arr = list(set(arr))
    sorted_arr = sorted(unique_arr)
    return sorted_arr

arr = [1, 2, 2, 3, 4, 4, 4, 5, 6, 6]
result = remove_duplicates(arr)
print(result)


def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Flag to check if any swaps are made in this pass
        swapped = False
        
        # Iterate through the unsorted part of the array
        for j in range(0, n-i-1):
            # Swap if the element is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        
        # If no swaps are made, the array is already sorted
        if not swapped:
            break
    
    return arr

# Test the program with different arrays

# Test 1
arr1 = [7, 3, 1, 9, 2]
print(bubble_sort(arr1))
# Output: [1, 2, 3, 7, 9]

# Test 2
arr2 = [7, 3, 1, 9, 2, -5, -2]
print(bubble_sort(arr2))
# Output: [-5, -2, 1, 2, 3, 7, 9]


def to_hexspeak(num: str) -> str:
    n = int(num)
    hex_str = []
    while n:
        rem = n % 16
        if rem == 1: hex_str.insert(0, 'I')
        elif rem == 0: hex_str.insert(0, 'O')
        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))
        else: return 'ERROR'
        n //= 16
    return ''.join(hex_str)


import random
import time

def generate_code():
    """
    This function generates a 4-digit secret code for the game.
    """
    return [random.randint(1, 6) for _ in range(4)]

def get_guess():
    """
    This function gets the player's guess from the console.
    """
    return list(map(int, input("Enter your guess: ").split()))

def give_feedback(secret_code, guess):
    """
    This function gives feedback on the player's guess.
    """
    black = sum(a == b for a, b in zip(secret_code, guess))
    white = sum(min(secret_code.count(n), guess.count(n)) for n in set(guess)) - black
    return black, white

def play_game(attempts):
    """
    This function runs the game.
    """
    secret_code = generate_code()
    start_time = time.time()

    for _ in range(attempts):
        guess = get_guess()
        if time.time() - start_time > 30:
            print("Time's up!")
            break
        black, white = give_feedback(secret_code, guess)
        print(f"Black: {black}, White: {white}")
        if black == 4:
            print("Congratulations, you won!")
            return
    print("You lost. The correct code was: ", secret_code)

attempts = max(5, int(input("Enter the number of attempts: ")))
play_game(attempts)


def find_min_cost(matrix):
    # Get the number of rows and columns in the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Create a 2D array to store the minimum cost of reaching each cell
    min_cost = [[float('inf')] * cols for _ in range(rows)]
    
    # Create a 2D array to store the number of paths with the minimum cost of reaching each cell
    num_paths = [[0] * cols for _ in range(rows)]
    
    # Initialize the minimum cost and number of paths of reaching the top left cell as 0
    min_cost[0][0] = matrix[0][0]
    num_paths[0][0] = 1
    
    # Calculate the minimum cost of reaching each cell
    for i in range(rows):
        for j in range(cols):
            # Calculate the minimum cost and number of paths for the current cell
            if i > 0:
                min_cost[i][j] = min(min_cost[i][j], min_cost[i-1][j] + matrix[i][j])
                if min_cost[i][j] == min_cost[i-1][j] + matrix[i][j]:
                    num_paths[i][j] += num_paths[i-1][j]
            if j > 0:
                min_cost[i][j] = min(min_cost[i][j], min_cost[i][j-1] + matrix[i][j])
                if min_cost[i][j] == min_cost[i][j-1] + matrix[i][j]:
                    num_paths[i][j] += num_paths[i][j-1]
    
    # Initialize the minimum cost and number of paths of reaching the bottom right cell
    min_cost_bottom_right = min_cost[rows-1][cols-1]
    num_paths_bottom_right = num_paths[rows-1][cols-1]
    
    # Find all the paths that have the minimum cost
    paths = []
    find_paths(matrix, rows-1, cols-1, '', min_cost_bottom_right, num_paths_bottom_right, paths)
    
    return min_cost_bottom_right, num_paths_bottom_right, paths

def find_paths(matrix, i, j, path, min_cost, num_paths, paths):
    # Add the current cell to the path
    path = str(matrix[i][j]) + ' ' + path
    
    # Base case: If we reach the top left cell, add the path to the list of paths
    if i == 0 and j == 0:
        paths.append(path)
        return
    
    # Recursive case: Move to the adjacent cells that have the minimum cost
    if i > 0 and min_cost - matrix[i][j] == min_cost[i-1][j]:
        find_paths(matrix, i-1, j, path, min_cost - matrix[i][j], num_paths, paths)
    if j > 0 and min_cost - matrix[i][j] == min_cost[i][j-1]:
        find_paths(matrix, i, j-1, path, min_cost - matrix[i][j], num_paths, paths)

# Test the program
matrix = [[2, 0, 3, 5],
          [4, 5, 1, 2],
          [3, 1, 2, 7]]

min_cost, num_paths, paths = find_min_cost(matrix)

print("Minimum Cost:", min_cost)
print("Number of Paths:", num_paths)
print("Paths with Minimum Cost:")
for path in paths:
    print(path)


def find_indices(s1, s2):
    indices = []
    for char in s2:
        for i in range(len(s1)):
            if s1[i] == char:
                indices.append(i)
    return indices


import mysql.connector
import threading
import logging
import time
from cryptography.fernet import Fernet

# Encrypt username and password
key = b'your-secret-key'
cipher_suite = Fernet(key)
encrypted_username = cipher_suite.encrypt(b'your-username').decode()
encrypted_password = cipher_suite.encrypt(b'your-password').decode()

# Connect to MySQL database securely
try:
    cnx = mysql.connector.connect(user=cipher_suite.decrypt(encrypted_username.encode()).decode(),
                                  password=cipher_suite.decrypt(encrypted_password.encode()).decode(),
                                  host='your-host',
                                  database='your-database',
                                  ssl_ca='path-to-ca-cert',
                                  ssl_cert='path-to-client-cert',
                                  ssl_key='path-to-client-key')
    cursor = cnx.cursor()
except mysql.connector.Error as err:
    logging.error(f"Error connecting to the database: {err}")
    exit(1)

# Validate retrieved data and retrieve in batches of 50 records
try:
    cursor.execute("SELECT * FROM your-table")
    records = cursor.fetchall()
    if len(records) < 100:
        logging.warning("Retrieved data does not contain at least 100 records.")
except mysql.connector.Error as err:
    logging.error(f"Error retrieving data from the database: {err}")
    exit(1)

# Multi-threading for faster data retrieval
def retrieve_batch(start_index):
    try:
        query = f"SELECT * FROM your-table LIMIT 50 OFFSET {start_index}"
        cursor.execute(query)
        return cursor.fetchall()
    except mysql.connector.Error as err:
        logging.error(f"Error retrieving data from the database: {err}")

threads = []
for i in range(0, len(records), 50):
    t = threading.Thread(target=retrieve_batch, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()

# Data caching
cached_data = {}
for i in range(0, len(records), 50):
    start_index = i
    if start_index in cached_data:
        batch_data = cached_data[start_index]
    else:
        batch_data = retrieve_batch(start_index)
        cached_data[start_index] = batch_data

    # Data transformation or manipulation
    # Sort records by a specific column
    sorted_batch = sorted(batch_data, key=lambda x: x[2])

    # Apply filter condition
    filtered_batch = [record for record in sorted_batch if record[3] > 100]

    # Encrypt retrieved data before storing in a local file
    encrypted_data = cipher_suite.encrypt(str(filtered_batch).encode())

    # Store data in a local file
    with open('data.txt', 'a') as file:
        file.write(encrypted_data.decode() + '\n')

# Logging mechanism
logging.basicConfig(filename='retrieval.log', level=logging.INFO)
logging.info("Data retrieval process started.")

# Unit tests
# TODO: Implement unit tests to validate functionality

# Database optimization techniques
# TODO: Implement advanced database query techniques like indexing or optimizing SQL queries

# Database connection pooling
# TODO: Implement database connection pooling for efficient management and reuse of connections

# User interface for custom query parameters
# TODO: Implement user interface to allow users to specify custom query parameters or filters

# Support for handling large datasets
# TODO: Implement support for handling large datasets that may not fit entirely in memory

# Support for concurrent database transactions
# TODO: Implement support for handling concurrent database transactions during data retrieval

# Data validation rules
# TODO: Implement data validation rules to ensure retrieved data meets specific criteria

# Dynamically configure database connection details
# TODO: Implement mechanism to dynamically configure database connection details at runtime

# Track and log execution time for each retrieval batch
# TODO: Implement mechanism to track and log execution time for each retrieval batch

# Handle and merge duplicate records
# TODO: Implement mechanism to handle and merge duplicate records during retrieval process

# Support for different types of database errors
# TODO: Implement support for handling different types of database errors and performing appropriate actions based on error type

logging.info("Data retrieval process completed.")
cnx.close()


dictionary = {
  'name': ['John', 'Jane', 'Jake', 'Jared', 'Jill'],
  'age': [25, 22, 19, 21, 27]
}

sum_ages = 0
for name, age in zip(dictionary['name'], dictionary['age']):
    if name.startswith('J') and age > 18 and age % 2 != 0:
        sum_ages += age

print(sum_ages)


import numpy as np

matrix = np.ones((10, 10))
print(matrix)


import numpy as np

scores = [8, 6, 5, 9, 7]
avg_score = np.mean(scores)
std_dev = np.std(scores)

print("Average score: ", avg_score)
print("Standard deviation: ", std_dev)


import random
import string

def generate_random_string():
    # Generate a random uppercase character
    uppercase_char = random.choice(string.ascii_uppercase)
    
    # Generate a random numeric digit
    numeric_digit = random.choice(string.digits)
    
    # Generate a random lowercase string of length 6
    lowercase_string = ''.join(random.choices(string.ascii_lowercase, k=6))
    
    # Combine all the generated characters
    random_string = uppercase_char + lowercase_string + numeric_digit
    
    # Shuffle the string to make it random
    random_string = ''.join(random.sample(random_string, len(random_string)))
    
    return random_string

# Generate and print a random string
print(generate_random_string())


def add_numbers(nums):
    nums = list(set(nums))  # remove duplicates from the list
    return sum(nums)


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

while True:
    try:
        num = int(input("Enter a positive integer between 1 and 1000: "))
        if num < 1 or num > 1000:
            raise ValueError
        if is_prime(num):
            raise ValueError("Prime numbers are not allowed")
        print(f"The number you entered, {num}, printed twice is: {num}{num}")
        break
    except ValueError:
        print("Invalid input. Please try again.")


def strip_tags(html):
    stack = []
    i = 0

    while i < len(html):
        if html[i] == '<':
            # Check if it's an opening tag
            if html[i:i+2] != '</':
                stack.append(i)
            else:
                # Find the corresponding opening tag
                start = stack.pop()
                end = i + 1
                html = html[:start] + html[end:]

                # Adjust the index to account for removed characters
                i = start - 1
        i += 1

    # Remove any remaining opening tags from the string
    while stack:
        start = stack.pop()
        html = html[:start] + html[start+1:]

    return html


def transpose(matrix):
    # Base case: if the matrix is empty, return an empty matrix
    if not matrix:
        return []

    # Recursive case:
    # Transpose the submatrix starting from the second row
    sub_matrix = transpose(matrix[1:])

    # Swap elements in the first row with their corresponding elements in the column
    transposed_row = [matrix[0][i] for i in range(len(matrix[0]))]

    # Add the transposed row to the transposed submatrix
    transposed_matrix = [transposed_row] + sub_matrix

    return transposed_matrix


import datetime

def validate_age(age):
    try:
        # Handle textual representations of age
        if isinstance(age, str):
            age = parse_age_text(age)
        
        # Check if age is within the specified range
        if not (18 <= age <= 65):
            return False
        
        # Check if age is negative or exceeds maximum lifespan
        if age < 0 or age > get_maximum_lifespan():
            return False
        
        return True
    
    except Exception as e:
        print(f"Error validating age: {str(e)}")
        return False

def parse_age_text(age_text):
    age_text = age_text.lower()
    
    # Handle numerical age text
    if age_text.isdigit():
        return int(age_text)
    
    # Handle textual representations of age
    age_words = age_text.split('-')
    if len(age_words) == 1:
        return parse_age_word(age_words[0])
    elif len(age_words) == 2:
        return parse_age_word(age_words[0]) + parse_age_word(age_words[1])
    else:
        raise ValueError("Invalid age format")
    
def parse_age_word(age_word):
    # Handle numerical age word
    if age_word.isdigit():
        return int(age_word)
    
    # Handle textual representations of age
    number_words = {
        "zero": 0, "one": 1, "two": 2, "three": 3, "four": 4, "five": 5,
        "six": 6, "seven": 7, "eight": 8, "nine": 9, "ten": 10,
        "eleven": 11, "twelve": 12, "thirteen": 13, "fourteen": 14, "fifteen": 15,
        "sixteen": 16, "seventeen": 17, "eighteen": 18, "nineteen": 19, "twenty": 20,
        "thirty": 30, "forty": 40, "fifty": 50, "sixty": 60
    }
    
    if age_word in number_words:
        return number_words[age_word]
    else:
        raise ValueError("Invalid age format")
    
def get_maximum_lifespan():
    # Consider leap years and other factors to calculate the maximum lifespan
    current_year = datetime.datetime.now().year
    maximum_lifespan = (current_year - 1900) * 0.75  # Example calculation
    
    return maximum_lifespan



def get_combinations(string1, string2):
    # Generate all possible combinations of characters from both strings
    combinations = []
    for char1 in string1:
        for char2 in string2:
            combination = ''.join(sorted(char1 + char2))
            if combination not in combinations:
                combinations.append(combination)
    # Sort the combinations in lexicographical order
    combinations.sort()
    return combinations


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


def search(root, key):
    return search_helper(root, key, 0)


def search_helper(node, key, count):
    if node is None:
        return count  # key not found, return the number of comparisons made

    count += 1  # increment the number of comparisons made

    if key == node.val:
        return count  # key found, return the number of comparisons made

    if key < node.val:
        return search_helper(node.left, key, count)  # search in the left subtree

    return search_helper(node.right, key, count)  # search in the right subtree


# create the BST
root = TreeNode(5)
root.left = TreeNode(3)
root.right = TreeNode(8)
root.left.left = TreeNode(2)
root.left.right = TreeNode(4)
root.right.left = TreeNode(6)
root.right.right = TreeNode(9)

# search for key=3
result = search(root, 3)
print(result)  # Output: 1


import math
from datetime import datetime

class ScientificCalculator:
    def __init__(self):
        self.memory = {}
        self.history = []

    def add(self, num1, num2):
        result = num1 + num2
        self._add_to_history("addition", result)
        return result

    def subtract(self, num1, num2):
        result = num1 - num2
        self._add_to_history("subtraction", result)
        return result

    def multiply(self, num1, num2):
        result = num1 * num2
        self._add_to_history("multiplication", result)
        return result

    def divide(self, num1, num2):
        try:
            result = num1 / num2
            self._add_to_history("division", result)
            return result
        except ZeroDivisionError:
            print("Error: Cannot divide by zero")
            return None

    def square_root(self, num):
        try:
            result = math.sqrt(num)
            self._add_to_history("square root", result)
            return result
        except ValueError:
            print("Error: Cannot take the square root of a negative number")
            return None

    def power(self, num, exponent):
        result = num ** exponent
        self._add_to_history(f"power({exponent})", result)
        return result

    def factorial(self, num):
        if num < 0:
            print("Error: Cannot calculate factorial of a negative number")
            return None
        result = 1
        for i in range(1, num + 1):
            result *= i
        self._add_to_history("factorial", result)
        return result

    def store_memory(self, label, value):
        self.memory[label] = value

    def recall_memory(self, label):
        if label in self.memory:
            return self.memory[label]
        else:
            print("Error: Memory label not found")
            return None

    def view_history(self):
        for entry in self.history:
            timestamp, operation, result = entry
            print(f"{timestamp}: {operation} = {result}")

    def search_history(self, keyword):
        for entry in self.history:
            timestamp, operation, result = entry
            if keyword in operation:
                print(f"{timestamp}: {operation} = {result}")

    def _add_to_history(self, operation, result):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.history.append((timestamp, operation, result))


import random

# Define lists of possible building materials and team members
materials = ['sticks', 'leaves', 'mud', 'rocks', 'straw']
team_members = ['Dave', 'Spider', 'Ladybug', 'Snail']

# Randomly select building materials and team members
building_materials = [random.choice(materials) for i in range(5)]
team = [random.choice(team_members) for i in range(4)]


import random
symbols = {
    'alpha': 2,
    'beta': 3,
    'gamma': 4,
    'delta': 5,
    'epsilon': 6,
    'theta': 7,
    'lambda': 8,
    'mu': 9
}
operators = {
    '+': lambda a, b: a + b,
    '-': lambda a, b: a - b,
    '*': lambda a, b: a * b,
    '/': lambda a, b: a // b
}
def generate_puzzle(difficulty):
    symbol1, symbol2, symbol3 = random.sample(list(symbols.keys()), 3)
    operand1 = random.randint(1, 10**difficulty) * symbols[symbol1]
    operand2 = random.randint(1, 10**difficulty) * symbols[symbol2]
    operator1 = random.choice(list(operators.keys()))
    operator2 = random.choice(list(operators.keys()))
    puzzle = f"{symbol1} {operator1} {symbol2} {operator2} {symbol3} = {operand1} {operator1} {operand2}"
    temp = operators[operator1](symbols[symbol1], symbols[symbol2])
    answer = operators[operator2](temp, symbols[symbol3])
    return puzzle, answer
# Example usage
puzzle, answer = generate_puzzle(difficulty=2)
print(puzzle)
print(answer)


def is_substring(s1: str, s2: str) -> bool:
    return s2 in s1


import random

number = random.randint(4, 8)  # Generate a random integer between 4 and 8
while number % 2 != 0 or number % 3 == 0:  # Repeat until the number satisfies the conditions
    number = random.randint(4, 8)

print(number)


import math
def find_missing_number(lst):
 sum_lst = sum(lst)
 n = len(lst) + 1
 perfect_square = int(math.sqrt(sum_lst + n*n))
 missing_number = perfect_square - sum_lst - n//2
 return missing_number
lst = [1, 2, 3, 4, 5]
missing_number = find_missing_number(lst)
print("The missing number is:", missing_number)


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True


def convertRomanToInteger(s):
    roman_values = {
        'I': 1,
        'V': 5,
        'X': 10,
        'L': 50,
        'C': 100,
        'D': 500,
        'M': 1000
    }
    
    max_counts = {
        'I': 3,
        'V': 1,
        'X': 3,
        'L': 1,
        'C': 3,
        'D': 1,
        'M': 3
    }
    
    num = 0
    count = {symbol: 0 for symbol in roman_values}
    
    for i in range(len(s)):
        curr = roman_values[s[i]]
        if i < len(s) - 1 and curr < roman_values[s[i+1]]:
            next = roman_values[s[i+1]]
            if next > curr * 10:
                return "Error: Invalid Roman numeral"
            num -= curr
        else:
            num += curr
        
        count[s[i]] += 1
        if count[s[i]] > max_counts[s[i]]:
            return "Error: Invalid Roman numeral"
        
    return num


class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        if not self.is_empty():
            return self.items.pop()

    def is_empty(self):
        return len(self.items) == 0

    def size(self):
        return len(self.items)


def reverse_string(string):
    stack = Stack()

    # Push each character onto the stack
    for char in string:
        stack.push(char)

    reversed_string = ''
    # Pop each character from the stack and append it to the reversed string
    while not stack.is_empty():
        reversed_string += stack.pop()

    return reversed_string


# Example usage
string = "Hello, World!"
reversed_string = reverse_string(string)
print(reversed_string)


def is_palindrome(s):
    # Remove any non-alphanumeric characters and convert to lowercase
    s = ''.join(e for e in s if e.isalnum()).lower()
    
    # Check if the string is equal to its reverse
    return s == s[::-1]


def validate_input(input_array):
    """
    This function validates the input array. It checks if the array contains exactly three positive integers.
    If the array contains negative integers, non-numeric values, or floating-point numbers, the function raises an exception.
    """
    if len(input_array) != 3:
        raise ValueError("Input array must contain exactly three elements.")
    for element in input_array:
        if not isinstance(element, int):
            raise ValueError("All elements in the input array must be integers.")
        if element <= 0:
            raise ValueError("All elements in the input array must be positive.")
            
def cube_volume(a, b, c):
    """
    This function calculates the volume of a cube using a custom mathematical function instead of the multiplication operator.
    The function takes the side lengths as input and returns the volume as output.
    """
    return a * a * a + b * b * b + c * c * c - (a * b * c)

def test_cube_volume():
    """
    This function tests the cube_volume function with various test cases, including edge cases.
    """
    assert cube_volume(1, 1, 1) == 1
    assert cube_volume(2, 2, 2) == 8
    assert cube_volume(3, 3, 3) == 27
    try:
        cube_volume(-1, -1, -1)
    except ValueError as e:
        assert str(e) == "All elements in the input array must be positive."
    try:
        cube_volume(1.5, 1.5, 1.5)
    except ValueError as e:
        assert str(e) == "All elements in the input array must be integers."
    try:
        cube_volume(1, 2)
    except ValueError as e:
        assert str(e) == "Input array must contain exactly three elements."
    print("All test cases passed.")
    
if __name__ == "__main__":
    test_cube_volume()


import random
nouns = ["cloud", "leaf", "river"]
adjectives = ["gentle", "rustling", "melodic"]
verbs = ["whisper", "dance", "soar"]
# generate the first line of the haiku
first_line = random.choice(adjectives) + " " + random.choice(nouns)
# generate the second line of the haiku
second_line = random.choice(adjectives) + " " + random.choice(nouns) + " " + random.choice(verbs)
# generate the third line of the haiku
third_line = random.choice(nouns) + " " + random.choice(verbs)
# print the haiku
print(first_line)
print(second_line)
print(third_line)


def generate_dictionary(list_a, list_b):
    dictionary = {}

    # Sort list_a in ascending order
    sorted_list_a = sorted(list_a)

    # Sort list_b in descending order
    sorted_list_b = sorted(list_b, reverse=True)

    # Generate the dictionary
    for i in range(len(sorted_list_a)):
        dictionary[sorted_list_a[i]] = sorted_list_b[i]

    return dictionary


import math

def is_prime(num):
    if num < 2:
        return False
    if num == 2:
        return True
    if num % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(num)) + 1, 2):
        if num % i == 0:
            return False
    return True

lower_limit = int(input("Enter the lower limit: "))
upper_limit = int(input("Enter the upper limit: "))

print("Prime numbers between", lower_limit, "and", upper_limit, "are:")
for num in range(lower_limit, upper_limit + 1):
    if is_prime(num):
        print(num)


def print_first_n_primes(n):
    primes = []
    num = 2  # Start checking from 2, as it is the first prime number
    
    while len(primes) < n:
        is_prime = True
        
        for i in range(2, int(num ** 0.5) + 1):
            if num % i == 0:
                is_prime = False
                break
        
        if is_prime:
            primes.append(num)
            print(num)
        
        num += 1

# Example usage
print_first_n_primes(10)


year = 2024

# Check if the year is divisible by 4 and not divisible by 100
if (year % 4 == 0) and (year % 100 != 0):
    leap_year = True
# Check if the year is divisible by 400
elif year % 400 == 0:
    leap_year = True
else:
    leap_year = False

if leap_year:
    print(year, "is a leap year.")
else:
    print(year, "is not a leap year.")


import re

def title_case_and_count(string):
    # Apply title case
    title_string = string.title()
    
    # Remove duplicate characters
    unique_chars = []
    for char in title_string:
        if char.isalpha() and char not in unique_chars:
            unique_chars.append(char)
    
    # Count occurrences of each character
    char_counts = {}
    for char in unique_chars:
        count = title_string.count(char)
        char_counts[char] = count
    
    # Sort character counts in descending order
    sorted_counts = sorted(char_counts.items(), key=lambda x: x[1], reverse=True)
    
    return sorted_counts

# Test the program
string = input("Enter a string: ")

# Handle empty input
if not string:
    print("String cannot be empty.")
    exit()

# Apply title case, remove duplicates, and count occurrences
result = title_case_and_count(string)

# Handle invalid input
if not result:
    print("Invalid input. The string should contain at least one letter.")
    exit()

# Print the result
print("Title case string with duplicate characters removed:", ''.join([char for char, _ in result]))
print("Character count in descending order:")
for char, count in result:
    print(char, "-", count)


import tensorflow as tf
from tensorflow.keras.datasets import imdb
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense

# Set the maximum number of words to be used in the vocabulary
max_words = 10000

# Load the IMDB movie review dataset
(x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=max_words)

# Pad the sequences to have the same length
max_sequence_length = 250
x_train = tf.keras.preprocessing.sequence.pad_sequences(x_train, maxlen=max_sequence_length)
x_test = tf.keras.preprocessing.sequence.pad_sequences(x_test, maxlen=max_sequence_length)

# Build the model
model = Sequential()
model.add(Embedding(max_words, 32, input_length=max_sequence_length))
model.add(LSTM(64))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train the model
model.fit(x_train, y_train, validation_split=0.2, epochs=3, batch_size=128)

# Evaluate the model on the test set
_, accuracy = model.evaluate(x_test, y_test)
print('Test accuracy:', accuracy)


class PhoneBook:
    def __init__(self):
        self.contacts = {}

    def add_contact(self, name, phone_number):
        self.contacts[name] = phone_number

    def remove_contact(self, name):
        del self.contacts[name]

    def update_phone_number(self, name, new_phone_number):
        self.contacts[name] = new_phone_number

    def search_contact(self, name):
        if name in self.contacts:
            return self.contacts[name]
        else:
            return None

def main():
    phone_book = PhoneBook()

    while True:
        print("\n--- Phone Book Menu ---")
        print("1. Add contact")
        print("2. Remove contact")
        print("3. Update phone number")
        print("4. Search contact")
        print("5. Quit")

        choice = int(input("Enter your choice: "))

        if choice == 1:
            name = input("Enter contact name: ")
            phone_number = input("Enter contact phone number: ")
            phone_book.add_contact(name, phone_number)
            print("Contact added successfully!")

        elif choice == 2:
            name = input("Enter contact name: ")
            phone_book.remove_contact(name)
            print("Contact removed successfully!")

        elif choice == 3:
            name = input("Enter contact name: ")
            phone_number = input("Enter new phone number: ")
            phone_book.update_phone_number(name, phone_number)
            print("Phone number updated successfully!")

        elif choice == 4:
            name = input("Enter contact name: ")
            phone_number = phone_book.search_contact(name)
            if phone_number:
                print(f"Phone number for {name}: {phone_number}")
            else:
                print(f"No contact found with the name {name}")

        elif choice == 5:
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()


# Import the random module
import random
# Define the function to generate a playlist
def generate_playlist(mood, activity_level):
    # Create a dictionary of songs with their corresponding moods and activity levels
    songs = {
        "Happy and Energetic": ["Happy", "Uptown Funk", "Can't Stop the Feeling"],
        "Sad and Relaxing": ["Someone Like You", "Stay", "All of Me"],
        "Angry and Intense": ["Lose Yourself", "Killing in the Name", "Break Stuff"],
        "Calm and Productive": ["Weightless", "Ambient 1", "Clair de Lune"]
    }
    # Choose a song based on the user's mood and activity level
    if mood == "Happy" and activity_level == "High":
        song = random.choice(songs["Happy and Energetic"])
    elif mood == "Sad" and activity_level == "Low":
        song = random.choice(songs["Sad and Relaxing"])
    elif mood == "Angry" and activity_level == "High":
        song = random.choice(songs["Angry and Intense"])
    elif mood == "Calm" and activity_level == "Low":
        song = random.choice(songs["Calm and Productive"])
    else:
        song = "Sorry, I couldn't find a song for your mood and activity level."
    # Print the personalized playlist with the phrase "Music is the medicine of the mind."
    print(f"Based on your mood '{mood}' and activity level '{activity_level}', I recommend the song '{song}'. Music is the medicine of the mind.")
# Test the function with example inputs
generate_playlist("Happy", "High")


def get_unique_elements(lst):
    unique_elements = []
    for element in lst:
        if element not in unique_elements:
            unique_elements.append(element)
    return unique_elements

# Test the function
lst = [3, 5, 7, 9, 5, 3, 7]
unique_elements = get_unique_elements(lst)
print(unique_elements)  # Output: [3, 5, 7, 9]


my_tuple = (1, 2, 3)
my_list = list(my_tuple)
print(my_list)


import string
from collections.abc import Iterable

def sort_strings(input_set):
    non_string_elements = []
    string_elements = []

    # Separate the input set into non-string and string elements
    for element in input_set:
        if isinstance(element, str):
            string_elements.append(element)
        else:
            non_string_elements.append(element)

    # Sort the non-string elements by data type
    non_string_elements = sorted(non_string_elements, key=lambda x: (type(x).__name__ != 'str', x))

    # Sort the string elements
    def sort_key(s):
        # Remove leading and trailing whitespace, ignore case, and consider special characters and numbers
        s = s.strip().lower()
        return ''.join(char if char.isalnum() or char in string.whitespace else '' for char in s)

    string_elements = sorted(string_elements, key=sort_key)

    # Sort nested sub-sets of strings recursively
    def sort_nested_strings(lst):
        for i, element in enumerate(lst):
            if isinstance(element, Iterable) and not isinstance(element, str):
                lst[i] = sort_strings(element)
        return lst

    string_elements = sort_nested_strings(string_elements)

    # Combine the sorted non-string elements and string elements
    sorted_list = non_string_elements + string_elements

    # Remove duplicates from the sorted list
    sorted_list = list(dict.fromkeys(sorted_list))

    return sorted_list


class Employee:
    def __init__(self, name, age, salary):
        self.name = name
        self.age = age
        self.salary = salary
    
    def increase_salary(self, percentage):
        self.salary += (self.salary * percentage / 100)
    
    def get_details(self):
        return f"Name: {self.name}, Age: {self.age}, Salary: ${self.salary}"

# Creating instances of the Employee class
employee1 = Employee("John Doe", 30, 5000)
employee2 = Employee("Jane Smith", 25, 4000)

# Demonstrating the use of methods
print(employee1.get_details())  # Output: Name: John Doe, Age: 30, Salary: $5000
employee2.increase_salary(10)
print(employee2.get_details())  # Output: Name: Jane Smith, Age: 25, Salary: $4400


import math

def is_prime(num):
    if num <= 1:
        return "Composite"

    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return "Composite"

    return "Prime"


import datetime

def convert_to_local_time(gmt_time, timezone_offset, dst_start, dst_end, output_format):
    # Parse the GMT time string and convert it to a datetime object
    gmt_datetime = datetime.datetime.strptime(gmt_time, "%Y-%m-%d %H:%M:%S")
    
    # Calculate the local time by adding the timezone offset
    local_datetime = gmt_datetime + datetime.timedelta(hours=timezone_offset)
    
    # Check if DST is in effect for the given date
    if dst_start <= local_datetime.replace(year=gmt_datetime.year) < dst_end:
        local_datetime += datetime.timedelta(hours=1)
    
    # Format the local time based on the desired output format
    if output_format == "12-hour":
        return local_datetime.strftime("%Y-%m-%d %I:%M:%S %p")
    elif output_format == "24-hour":
        return local_datetime.strftime("%Y-%m-%d %H:%M:%S")
    else:
        raise ValueError("Invalid output format. Supported formats are '12-hour' and '24-hour'.")

# Example usage
gmt_time = "2022-03-01 08:30:00"
timezone_offset = 3.5  # GMT+3:30
dst_start = datetime.datetime(2022, 3, 27)  # DST start date
dst_end = datetime.datetime(2022, 10, 30)  # DST end date
output_format = "12-hour"

try:
    local_time = convert_to_local_time(gmt_time, timezone_offset, dst_start, dst_end, output_format)
    print("Local time:", local_time)
except ValueError as e:
    print("Error:", str(e))


def find_max_min_swap(arr):
    # Find the maximum and minimum elements in the array
    max_num = max(arr)
    min_num = min(arr)

    # Swap their positions
    max_index = arr.index(max_num)
    min_index = arr.index(min_num)
    arr[max_index], arr[min_index] = arr[min_index], arr[max_index]

    # Remove duplicates
    arr = list(set(arr))

    # Sort the array in descending order
    arr.sort(reverse=True)

    # Calculate the sum of all elements
    arr_sum = sum(arr)

    return arr, arr_sum


# Test the program
array = [3, 2, 1, 5, 4, 5, 1, 2]
result, sum_of_elements = find_max_min_swap(array)
print("Array after swapping max and min elements, removing duplicates, and sorting in descending order:", result)
print("Sum of all elements in the array:", sum_of_elements)


def reverse_remove_vowels(string):
    # Remove vowels and replace 's' with 'z'
    modified_string = string.replace('s', 'z')
    modified_string = ''.join(char for char in modified_string if char.lower() not in 'aeiou')
    
    # Count unique consonants
    unique_consonants = len(set(modified_string))
    
    # Reverse the string
    reversed_string = modified_string[::-1]
    
    return reversed_string, unique_consonants


import math
import threading
import sys

class PrimeNumberGenerator:
    def __init__(self, start, end, num_threads):
        self.start = start
        self.end = end
        self.num_threads = num_threads
        self.primes = []

    def generate_primes(self):
        if self.start < 2:
            self.start = 2

        if self.start > self.end:
            print("Invalid range: starting number is greater than ending number.")
            return

        if self.start == self.end:
            print("Invalid range: starting number is equal to ending number.")
            return

        if self.num_threads <= 0:
            print("Invalid number of threads. Please provide a positive integer.")
            return

        # Calculate the chunk size for each thread
        chunk_size = math.ceil((self.end - self.start + 1) / self.num_threads)

        # Create and start the threads
        threads = []
        for i in range(self.num_threads):
            thread_start = self.start + (i * chunk_size)
            thread_end = min(self.start + ((i + 1) * chunk_size) - 1, self.end)
            thread = threading.Thread(target=self._find_primes, args=(thread_start, thread_end))
            thread.start()
            threads.append(thread)

        # Wait for all threads to finish
        for thread in threads:
            thread.join()

        # Sort the prime numbers
        self.primes.sort()

        # Print or write the prime numbers to a file
        if len(sys.argv) > 1 and sys.argv[1] == "output":
            with open("prime_numbers.txt", "w") as file:
                for prime in self.primes:
                    file.write(str(prime) + "\n")
            print("Prime numbers written to prime_numbers.txt.")
        else:
            for prime in self.primes:
                print(prime)

    def _is_prime(self, num):
        if num < 2:
            return False
        for i in range(2, int(math.sqrt(num)) + 1):
            if num % i == 0:
                return False
        return True

    def _find_primes(self, start, end):
        for num in range(start, end + 1):
            if self._is_prime(num):
                self.primes.append(num)


def main():
    if len(sys.argv) != 4:
        print("Usage: python prime_generator.py start end num_threads")
        return

    try:
        start = int(sys.argv[1])
        end = int(sys.argv[2])
        num_threads = int(sys.argv[3])
    except ValueError:
        print("Invalid input. Please provide integers for start, end, and num_threads.")
        return

    prime_generator = PrimeNumberGenerator(start, end, num_threads)
    prime_generator.generate_primes()


if __name__ == "__main__":
    main()


import numpy as np

# Given matrix array
matrix_array = np.array([[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]])

# Reshape the matrix array to have 5 rows and 7 columns
reshaped_array = np.reshape(matrix_array, (5, 7))

# Find the sum of each row and each column in the reshaped matrix
row_sums = np.sum(reshaped_array, axis=1)
column_sums = np.sum(reshaped_array, axis=0)

print("Reshaped Array:")
print(reshaped_array)
print("\nSum of each row:")
print(row_sums)
print("\nSum of each column:")
print(column_sums)


def addNumbers(a, b):
    # Check if either input is a floating-point number
    if isinstance(a, float) or isinstance(b, float):
        # Convert both inputs to floating-point numbers
        a = float(a)
        b = float(b)
        # Return the sum as a floating-point number
        return a + b
    
    # Check if either input is not a number
    if not (isinstance(a, int) or isinstance(b, int)):
        raise ValueError("Both inputs must be numbers")
    
    # Check if the inputs are very large numbers
    if isinstance(a, int) and isinstance(b, int) and (abs(a) > 10**10 or abs(b) > 10**10):
        # Handle the large numbers efficiently without causing any memory or performance issues
        # For example, we can use a library that supports arbitrary-precision arithmetic
        
        # Here is a simple implementation using the built-in Python `decimal` module
        from decimal import Decimal
        a = Decimal(str(a))
        b = Decimal(str(b))
        return a + b
    
    # Remove leading and trailing whitespace characters if present
    a = str(a).strip()
    b = str(b).strip()
    
    # Check if the inputs contain only digits or an optional sign followed by digits
    if not (a.isdigit() or (a[0] in ['-', '+'] and a[1:].isdigit())):
        raise ValueError("Input a is not a valid number")
    if not (b.isdigit() or (b[0] in ['-', '+'] and b[1:].isdigit())):
        raise ValueError("Input b is not a valid number")
    
    # Convert the inputs to integers
    a = int(a)
    b = int(b)
    
    # Check if the sum exceeds the maximum or minimum value that can be represented by the integer data type
    if a + b > sys.maxsize or a + b < -sys.maxsize - 1:
        raise ValueError("Sum exceeds the maximum or minimum value that can be represented by the integer data type")
    
    # Return the sum of the inputs as an integer
    return a + b


def find_min(arr):
    n = len(arr)
    
    # Base case: if array has only one element, it is the minimum
    if n == 1:
        return arr[0]
    
    # Divide the array into two halves
    mid = n // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    # Find minimum element in each half
    min_left = find_min(left_half)
    min_right = find_min(right_half)
    
    # Compare and return the smaller minimum element
    return min(min_left, min_right)


def wiggleSort(nums):
    for i in range(1, len(nums)):
        if i % 2 == 0 and nums[i] > nums[i-1]:
            swap(nums[i], nums[i-1])
        elif i % 2 == 1 and nums[i] < nums[i-1]:
            swap(nums[i], nums[i-1])


# Sample input dictionary
input_dict = {'a': 3, 'd': 2, 'c': 4, 'b': 1}

# Sort the dictionary in descending order based on keys
sorted_dict = dict(sorted(input_dict.items(), key=lambda x: x[0], reverse=True))

# Print the elements of the dictionary with keys in uppercase and values squared
for key, value in sorted_dict.items():
    print(key.upper(), ":", value ** 2)


FUNCTION find_original_array(encoded: LIST[int], first: int) -> LIST[int]:
    arr = [first]
    FOR i in RANGE(0, LEN(encoded)):
        arr.append(encoded[i] XOR arr[i])
    RETURN arr


def max_alternating_sum(nums):
    even_sum = odd_sum = 0
    for num in nums:
        even_sum, odd_sum = max(even_sum + num, odd_sum), even_sum - num
    return even_sum


import requests
from bs4 import BeautifulSoup

def get_specific_data(url):
    try:
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        anchor_tags = soup.find_all('a')
        data_points = [tag.text for tag in anchor_tags]
        return data_points
    except requests.exceptions.RequestException as e:
        print(e)
        return []

url = "http://example.com"
data = get_specific_data(url)
print(data)


list.sort()


def decimalToBinary(n):
    if n == 0:
        return ''
    elif n % 2 == 0:
        return decimalToBinary(n // 2) + '0'
    else:
        return decimalToBinary((n - 1) // 2) + '1'

# Example usage:
decimal_number = 42
binary_representation = decimalToBinary(decimal_number)
print(f"The binary representation of {decimal_number} is: {binary_representation}")


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def sum_of_cubes_of_prime_numbers(n):
    if n <= 0:
        return "n must be a positive integer."
    
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    
    sum_of_cubes = sum([prime**3 for prime in primes])
    return sum_of_cubes


def find_primes(start, end):
    """
    This function takes in two parameters, a start number and an end number, and returns a list of all the prime numbers between the start and end (inclusive).
    
    The function uses a for loop to iterate over the range from start to end. For each number in the range, it checks if the number is prime by dividing it by all numbers less than its square root. This is because a larger factor of the number would be a multiple of smaller factor that has already been checked.
    
    The function has a time complexity of O(n sqrt(n)), where n is the difference between the start and end numbers. This is because for each number in the range, we are performing a operation that takes sqrt(n) time.
    
    The function does not use any built-in libraries or functions for checking prime numbers.
    """
    primes = []  # Initialize an empty list to store the prime numbers

    for num in range(start, end + 1):  # Iterate over the range from start to end
        if num > 1:  # The number must be greater than 1 to be a prime number
            for i in range(2, int(num**0.5) + 1):  # Check divisibility up to the square root of the number
                if (num % i) == 0:  # If the number is divisible by i, it is not a prime number
                    break
            else:  # If the number is not divisible by any i, it is a prime number
                primes.append(num)

    return primes


def print_array_without_duplicates(arr):
    result = []
    for num in arr:
        if num not in result:
            result.append(num)
    return result

# Example usage
arr = [4, 3, 6, 5, 4, 7, -2, 5, 0, 3]
print(print_array_without_duplicates(arr))  # Output: [4, 3, 6, 5, 7, -2, 0]


cm = 15
inches = cm / 2.54
feet = inches / 12
yards = feet / 3
print("Conversion Table")
print("-----------------")
print("Centimeters | Inches | Feet | Yards")
print("-----------------------------------")
print(f"{cm:<11} | {inches:<6.2f} | {feet:<4.2f} | {yards:<4.2f}")


def is_fibonacci(n):
    # Check if n is a perfect square
    def is_perfect_square(num):
        square_root = int(num ** 0.5)
        return square_root * square_root == num

    # Check if n is a Fibonacci number
    def is_fib(num):
        return is_perfect_square(5 * num * num + 4) or is_perfect_square(5 * num * num - 4)

    # Find the closest Fibonacci number smaller than n
    def find_closest_fibonacci(num):
        fib_prev, fib_curr = 0, 1
        while fib_curr <= num:
            fib_prev, fib_curr = fib_curr, fib_prev + fib_curr
        return fib_prev

    if is_fib(n):
        return f"{n} is a Fibonacci number."
    else:
        return f"{n} is not a Fibonacci number. The closest Fibonacci number smaller than {n} is {find_closest_fibonacci(n)}."


# Test the function
print(is_fibonacci(5))  # Output: 5 is a Fibonacci number.
print(is_fibonacci(8))  # Output: 8 is a Fibonacci number.
print(is_fibonacci(13))  # Output: 13 is a Fibonacci number.
print(is_fibonacci(15))  # Output: 15 is not a Fibonacci number. The closest Fibonacci number smaller than 15 is 13.
print(is_fibonacci(21))  # Output: 21 is a Fibonacci number.
print(is_fibonacci(25))  # Output: 25 is not a Fibonacci number. The closest Fibonacci number smaller than 25 is 21.


def remove_elements(lst, element):
    result = []
    for num in lst:
        if num != element:
            result.append(num)
    return result


import re

def count_words(string, stop_words):
    # Remove punctuation and convert to lowercase
    string = re.sub(r'[^\w\s]', '', string).lower()
    
    # Remove stop words
    words = string.split()
    words = [word for word in words if word not in stop_words]
    
    # Count the occurrences of each word
    word_count = {}
    for word in words:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    
    return word_count


def find_length(lst):
    count = 0

    for item in lst:
        if isinstance(item, list):
            count += find_length(item)
        else:
            count += 1

    return count

# Test the program
my_list = [1, 2, 3, [4, 5, [6, 7]], [8, 9]]
length = find_length(my_list)
print("Length of the list:", length)


def move_disk(n, source, destination, auxiliary):
    if n == 0:
        return
    
    move_disk(n-1, source, auxiliary, destination)
    
    print(f"Move disk {n} from tower {source} to tower {auxiliary}")
    print(f"Move disk {n} from tower {auxiliary} to tower {destination}")
    
    move_disk(n-1, auxiliary, destination, source)

# Example usage
move_disk(3, "A", "C", "B")


class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if self.is_empty():
            return "Stack is empty"
        return self.stack.pop()

    def peek(self):
        if self.is_empty():
            return "Stack is empty"
        return self.stack[-1]

    def is_empty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)


def bisection_root(n, low, high, epsilon):
    mid = (low + high) / 2
    error = abs(mid ** 7 - n)

    if error < epsilon:
        return mid
    elif mid ** 7 > n:
        return bisection_root(n, low, mid, epsilon)
    else:
        return bisection_root(n, mid, high, epsilon)

number = 823543
epsilon = 0.0001
low = 0
high = number

root = bisection_root(number, low, high, epsilon)
print("7th root of", number, "is approximately", root)


def addBoldTag(s: str, words: list) -> str:
    n = len(s)
    marked = [False] * n
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                marked[i] = True
            pos = s.find(word, pos + 1)
    result = []
    i = 0
    while i < n:
        if marked[i]:
            result.append("<b>")
            while i < n and marked[i]:
                result.append(s[i])
                i += 1
            result.append("</b>")
        else:
            result.append(s[i])
            i += 1
    return "".join(result)


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_primes(l):
    return sum([x for x in l if is_prime(x)])

l = [1,2,3,4,5,6,7,8,9,10]
prime_sum = sum_primes(l)
print(prime_sum)


import time

def get_current_time():
    # Get the current system time in seconds since the epoch
    current_time = time.time()

    # Calculate the time difference between UTC and New York City (in seconds)
    utc_offset = 4 * 60 * 60  # New York is UTC-4 during Standard Time

    # Adjust the current time by the time difference
    adjusted_time = current_time - utc_offset

    # Get the current date and time in New York City
    current_datetime = time.gmtime(adjusted_time)

    # Format the time in 24-hour format
    current_time = time.strftime('%H:%M:%S', current_datetime)

    return current_time

# Get the current time in New York City
current_time_nyc = get_current_time()
print(current_time_nyc)


def longest_substring(s):
    start = end = max_start = max_len = 0
    seen = set()

    while end < len(s):
        if s[end] in seen:
            seen.remove(s[start])
            start += 1
        else:
            seen.add(s[end])
            end += 1
            curr_len = end - start
            if curr_len > max_len:
                max_len = curr_len
                max_start = start

    return s[max_start:max_start + max_len]

s = "abcabcbb"
print(longest_substring(s))  # Output: "abc"


import random

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def generate_random_number():
    primes = [2, 3, 5, 7]
    while True:
        number = random.randint(1, 100)
        if all(number % prime != 0 for prime in primes):
            return number

random_number = generate_random_number()
print(random_number)


def calculate_anagrams(string):
    string = string.lower()
    anagrams = []

    def find_anagrams(anagram, remaining):
        if len(anagram) == len(string):
            if len(set(anagram)) == len(anagram):
                anagrams.append(anagram)
        else:
            for char in remaining:
                if char not in anagram:
                    find_anagrams(anagram + char, remaining.replace(char, '', 1))

    find_anagrams('', string)
    return anagrams

string = "Listen"
anagrams = calculate_anagrams(string)
print(anagrams)


def factorial(n):
    # Base case: factorial of 0 is 1
    if n == 0:
        return 1

    # Error case: input is a float or negative integer
    if not isinstance(n, int) or n < 0:
        return "Error: Input must be a positive integer."

    # Error case: input is greater than 10^6
    if n > 10**6:
        return "Error: Input must be less than or equal to 10^6."

    # Recursive case: calculate factorial
    return n * factorial(n-1)


def reverse_string(string):
    # Define the vowels and their corresponding uppercase versions
    vowels = {'a': 'A', 'e': 'E', 'i': 'I', 'o': 'O', 'u': 'U'}
    
    # Define the Roman numerals for the digits 0 to 9
    roman_numerals = {0: '', 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V',
                      6: 'VI', 7: 'VII', 8: 'VIII', 9: 'IX'}
    
    # Convert the string to a list of characters
    string_list = list(string)
    
    # Reverse the list in-place
    string_list.reverse()
    
    # Iterate over the characters and apply the required transformations
    for i in range(len(string_list)):
        char = string_list[i]
        if char.isalpha():
            # Shift the character to its next lexicographically greater character
            if char.isupper():
                string_list[i] = chr((ord(char) - ord('A') + 1) % 26 + ord('A'))
            else:
                string_list[i] = chr((ord(char) - ord('a') + 1) % 26 + ord('a'))
            
            # Capitalize vowels and lowercase consonants
            if string_list[i].lower() in vowels:
                string_list[i] = vowels[string_list[i].lower()]
        elif char.isdigit():
            # Replace digits with their corresponding Roman numerals
            digit = int(char)
            string_list[i] = roman_numerals[digit]
    
    # Convert the list back to a string
    reversed_string = ''.join(string_list)
    
    # Count the number of unique characters in the reversed string
    unique_characters = len(set(reversed_string))
    
    return reversed_string, unique_characters

# Test the function
input_string = "hello world"
reversed_string, unique_characters = reverse_string(input_string)
print("Input:", input_string)
print("Output:", reversed_string)
print("Unique characters:", unique_characters)


class Dog:
    def __init__(self, name, breed, age):
        self.name = name
        self.breed = breed
        self.age = age

    def bark(self):
        print("Woof woof!")

    def get_info(self):
        print(f"Name: {self.name}\nBreed: {self.breed}\nAge: {self.age}")

    def set_age(self, new_age):
        if isinstance(new_age, int) and new_age >= 0:
            self.age = new_age
        else:
            print("Invalid age value.")

    def is_old(self):
        return self.age >= 10

    def birthday(self):
        self.age += 1

    def set_breed(self, new_breed):
        if isinstance(new_breed, str):
            self.breed = new_breed
        else:
            print("Invalid breed value.")

    def get_breed(self):
        return self.breed


words = ['apple', 'banana', 'cherry', 'date', 'elephant', 'fig', 'grape', 'honey', 'indigo', 'jungle', 'kiwi', 'lemon', 'mango', 'nutmeg', 'orange', 'peach', 'quilt', 'raspberry', 'strawberry', 'tangerine', 'umbrella', 'violet', 'watermelon', 'xylophone', 'yellow', 'zebra']
# Filter words to only include odd-length words with at least 5 letters
words = [word for word in words if len(word) % 2 == 1 and len(word) >= 5]
# Sort words by their middle letter
words = sorted(words, key=lambda x: x[len(x)//2])
print(words)


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def twoSumBSTs(root1, root2, target):
    def build_set(node, s):
        if node:
            s.add(node.val)
            build_set(node.left, s)
            build_set(node.right, s)

    def find_pair(node, target, s):
        if node:
            if target - node.val in s:
                return True
            return find_pair(node.left, target, s) or find_pair(node.right, target, s)
        return False

    s = set()
    build_set(root1, s)
    return find_pair(root2, target, s)


class Triangle:
    count = 0

    def __init__(self, side1, side2, side3):
        if side1 > 0 and side2 > 0 and side3 > 0 and self._is_valid_triangle(side1, side2, side3):
            self.side1 = side1
            self.side2 = side2
            self.side3 = side3
            Triangle.count += 1
        else:
            print("Invalid sides for a triangle!")

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is not None:
            print("Invalid sides for a triangle!")
        return True

    def _is_valid_triangle(self, side1, side2, side3):
        return side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1

    def get_area(self):
        def _calc_area(a, b, c):
            if a == 0 or b == 0 or c == 0:
                return 0
            p = (a + b + c) / 2
            return (p * (p - a) * (p - b) * (p - c)) ** 0.5

        return _calc_area(self.side1, self.side2, self.side3)

    def get_perimeter(self):
        return self.side1 + self.side2 + self.side3

    @property
    def is_equilateral(self):
        return self.side1 == self.side2 == self.side3

    def is_isosceles(self):
        return self.side1 == self.side2 or self.side1 == self.side3 or self.side2 == self.side3

    def resize(self, new_side1, new_side2, new_side3):
        if new_side1 > 0 and new_side2 > 0 and new_side3 > 0 and self._is_valid_triangle(new_side1, new_side2, new_side3):
            self.side1 = new_side1
            self.side2 = new_side2
            self.side3 = new_side3
        else:
            print("Invalid sides for a triangle!")


import re
sentence = "The fireworks will light up the sky as we celebrate our hard-earned victory in the grand parade that will take place tomorrow."
# Define the regular expression pattern
pattern = r"\b(celebrate|victory|parade|tomorrow)\b"
# Find all matches in the sentence
matches = re.findall(pattern, sentence, flags=re.IGNORECASE)
# Print the matches
print(matches)


def compress_string(string):
    compressed_string = ""
    count = 1
    for i in range(1, len(string)):
        if string[i] == string[i-1]:
            count += 1
        else:
            compressed_string += string[i-1] + str(count)
            count = 1
    compressed_string += string[-1] + str(count)
    
    if len(compressed_string) >= len(string):
        return string
    else:
        return compressed_string


import datetime

class EncryptedStudentGrades:
    def __init__(self):
        self.data = {}

    def encrypt_name(self, name):
        encrypted_name = ""
        current_date = datetime.date.today()
        
        for i, char in enumerate(name):
            char_position = ord(char.lower()) - ord('a') + 1
            encrypted_char = (char_position * len(name) * current_date.year) % 26 + ord('a')
            encrypted_name += chr(encrypted_char)
        
        return encrypted_name
    
    def add_grade(self, name, grade):
        encrypted_name = self.encrypt_name(name)
        self.data[encrypted_name] = grade
    
    def get_grade(self, name):
        encrypted_name = self.encrypt_name(name)
        return self.data.get(encrypted_name, None)

# Example usage
student_grades = EncryptedStudentGrades()

# Adding grades
student_grades.add_grade("Alice", 90)
student_grades.add_grade("Bob", 80)
student_grades.add_grade("Charlie", 95)

# Retrieving grades
print(student_grades.get_grade("Alice"))    # Output: 90
print(student_grades.get_grade("Bob"))      # Output: 80
print(student_grades.get_grade("Charlie"))  # Output: 95


def sort_list_of_dicts(original_list, sort_key, group_key, secondary_key):
    # Check if the given key is present in any of the dictionaries
    if not all(sort_key in d for d in original_list):
        raise KeyError(f"{sort_key} is not present in any of the dictionaries.")
    
    # Check if the group key is present in any of the dictionaries
    if not all(group_key in d for d in original_list):
        raise KeyError(f"{group_key} is not present in any of the dictionaries.")
    
    # Sort the original list based on the given key in ascending order
    sorted_list = sorted(original_list, key=lambda x: x[sort_key].lower())
    
    # Group the dictionaries based on the value of the group key
    groups = {}
    for dictionary in sorted_list:
        group_value = dictionary[group_key]
        if group_value not in groups:
            groups[group_value] = []
        groups[group_value].append(dictionary)
    
    # Sort the groups based on the sum of the secondary key in descending order
    sorted_groups = sorted(groups.values(), key=lambda x: sum(d[secondary_key] for d in x), reverse=True)
    
    # Sort each group based on the alphabetical order of another key in ascending order
    for group in sorted_groups:
        group.sort(key=lambda x: x['name'].lower())
    
    return sorted_groups

# Test the function with the provided example
original_list = [
    {'name':'John', 'age': 25, 'score': 90},
    {'name':'jim', 'age': 18, 'score': 85},
    {'name':'Lisa', 'age': 20, 'score': 85},
    {'name':'john', 'age': 25, 'score': 95},
    {'name':'Lisa', 'age': 20, 'score': 80},
    {'name':'Mike', 'age': 30, 'score': 80},
    {'name':'jim', 'age': 22, 'score': 85}
]

sorted_list = sort_list_of_dicts(original_list, 'score', 'name', 'age')
print(sorted_list)


import math

class Vector2D:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def get_x(self) -> float:
        return self.x

    def get_y(self) -> float:
        return self.y

    def magnitude(self) -> float:
        return round(math.sqrt(self.x**2 + self.y**2), 6)

    def add(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x + other.get_x(), self.y + other.get_y())

    def subtract(self, other: 'Vector2D') -> 'Vector2D':
        return Vector2D(self.x - other.get_x(), self.y - other.get_y())

    def multiply(self, scalar: float) -> 'Vector2D':
        return Vector2D(self.x * scalar, self.y * scalar)

    def dot_product(self, other: 'Vector2D') -> float:
        return round(self.x * other.get_x() + self.y * other.get_y(), 6)

    def cross_product(self, other: 'Vector2D') -> float:
        return 0.0

    def normalize(self) -> 'Vector2D':
        magnitude = self.magnitude()
        return Vector2D(self.x / magnitude, self.y / magnitude)

    def distance(self, other: 'Vector2D') -> float:
        return round(math.sqrt((self.x - other.get_x())**2 + (self.y - other.get_y())**2), 6)

    def angle(self, other: 'Vector2D') -> float:
        dot_product = self.dot_product(other)
        magnitude_product = self.magnitude() * other.magnitude()
        if magnitude_product == 0:
            return 0.0
        return round(math.degrees(math.acos(dot_product / magnitude_product)), 6)

    def rotate(self, angle: float) -> 'Vector2D':
        angle_rad = math.radians(angle)
        rotated_x = self.x * math.cos(angle_rad) - self.y * math.sin(angle_rad)
        rotated_y = self.x * math.sin(angle_rad) + self.y * math.cos(angle_rad)
        return Vector2D(rotated_x, rotated_y)

    def project(self, other: 'Vector2D') -> 'Vector2D':
        dot_product = self.dot_product(other)
        magnitude_product = other.magnitude()**2
        if magnitude_product == 0:
            return Vector2D(0, 0)
        scalar = dot_product / magnitude_product
        return other.multiply(scalar)

    def is_parallel(self, other: 'Vector2D') -> bool:
        return self.cross_product(other) == 0.0

    def is_orthogonal(self, other: 'Vector2D') -> bool:
        return self.dot_product(other) == 0.0


def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_primes(n):
    if n <= 0:
        return []
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    return primes


def reverse_string(s):
    if not s:
        return s

    # Convert the string to a list of characters
    chars = list(s)

    # Use two pointers to swap characters from both ends of the list
    left = 0
    right = len(chars) - 1
    while left < right:
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1

    # Convert the list of characters back to a string
    reversed_s = ''.join(chars)
    return reversed_s


def calculate_mean(input_string):
    numbers = input_string.split(",")
    total = 0
    count = 0
    for number in numbers:
        try:
            num = float(number)
            if num >= 0:
                total += num
                count += 1
        except ValueError:
            continue
    mean = round(total / count)
    return mean

input_string = "7, 15, 16, 23, 35, 42, 50, 56, 61, 74"
mean = calculate_mean(input_string)
print(mean)


def computeFibonacci(n):
    fib = [0, 1]
    a, b = 0, 1
    i = 2
    while True:
        fib.append(a + b)
        a, b = b, fib[i]
        if fib[i] > n:
            break
        i += 1
    return fib

# Example usage:
n = 1000
fibonacci = computeFibonacci(n)
print(fibonacci)


string = '2947'

# Check if it is an integer
try:
    int_value = int(string)
    print(f"The data type of '{string}' is: int")
except ValueError:
    # Check if it is a float
    try:
        float_value = float(string)
        print(f"The data type of '{string}' is: float")
    except ValueError:
        # Check if it is a boolean
        if string.lower() == 'true' or string.lower() == 'false':
            print(f"The data type of '{string}' is: bool")
        else:
            # Check if it is a string
            print(f"The data type of '{string}' is: str")


import requests

def calculate_average_age():
    # Make the API call and retrieve the data
    response = requests.get("https://example.com/api/data")
    data = response.json()

    # Filter out objects with age less than 18
    filtered_data = []
    for obj in data:
        if obj["age"] >= 18:
            filtered_data.append(obj)

    # Sort the remaining objects based on name in ascending order
    sorted_data = []
    while filtered_data:
        min_name = filtered_data[0]["name"]
        min_obj = filtered_data[0]
        for obj in filtered_data:
            if obj["name"] < min_name:
                min_name = obj["name"]
                min_obj = obj
        sorted_data.append(min_obj)
        filtered_data.remove(min_obj)

    # Group the objects based on the first letter of the name
    grouped_data = {}
    for obj in sorted_data:
        first_letter = obj["name"][0]
        if first_letter not in grouped_data:
            grouped_data[first_letter] = []
        grouped_data[first_letter].append(obj)

    # Find the object with the highest age for each group
    final_data = []
    for group in grouped_data.values():
        max_age = -1
        max_obj = None
        for obj in group:
            if obj["age"] > max_age:
                max_age = obj["age"]
                max_obj = obj
        final_data.append(max_obj)

    # Calculate the average age of the remaining objects
    total_age = 0
    for obj in final_data:
        total_age += obj["age"]
    average_age = total_age / len(final_data)

    # Round the average age to two decimal places
    average_age = round(average_age, 2)

    return average_age


class InvalidNameError(Exception):
    def __init__(self, message):
        self.message = message

class InvalidModelError(Exception):
    def __init__(self, message):
        self.message = message

class Computer:
    def __init__(self, name, model):
        self._name = name
        self._model = model

    def get_name(self):
        if not isinstance(self._name, str) or not self._name.isalpha():
            raise InvalidNameError("Invalid name format. Please enter a valid name consisting of only letters")
        elif not self._name[0].isupper():
            raise InvalidNameError("Invalid name format. Please enter a valid name starting with an uppercase letter")
        return self._name

    def get_model(self):
        if not isinstance(self._model, str) or not self._model.isalnum():
            raise InvalidModelError("Invalid model format. Please enter a valid model consisting of alphanumeric characters")
        elif not any(char.isdigit() for char in self._model):
            raise InvalidModelError("Invalid model format. Please enter a valid model containing at least one digit")
        return self._model


import re
import tkinter as tk
from tkinter import messagebox

def validate_email(email):
    pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
    if re.match(pattern, email):
        return True
    else:
        return False

def submit_email():
    email = email_entry.get()
    if validate_email(email):
        messagebox.showinfo("Welcome", f"Welcome, {email}!")
    else:
        messagebox.showerror("Error", "Please enter a valid email address.")

# Create the main window
window = tk.Tk()
window.title("Email Validation")
window.geometry("300x200")

# Create a label for instructions
label = tk.Label(window, text="Enter your email address:")
label.pack()

# Create an entry field for the email address
email_entry = tk.Entry(window)
email_entry.pack()

# Create a submit button
submit_button = tk.Button(window, text="Submit", command=submit_email)
submit_button.pack()

# Run the main event loop
window.mainloop()


def remove_duplicates(input_array):
    unique_elements = []  # to store unique elements
    seen_elements = set()  # to keep track of already seen elements

    for element in input_array:
        if element not in seen_elements:
            unique_elements.append(element)
            seen_elements.add(element)

    return unique_elements


def convert_fahrenheit_to_celsius(fahrenheit):
    return round((fahrenheit - 32) * 5/9, 2)

def convert_celsius_to_fahrenheit(celsius):
    return round((celsius * 9/5) + 32, 2)

def is_valid_temperature(temperature):
    try:
        temperature = float(temperature)
        if temperature < -459.67 or temperature > 10000.0:
            raise ValueError
        return True
    except ValueError:
        return False

def convert_temperatures():
    print("Temperature Conversion Program")
    print("==============================")

    while True:
        print("Please select the conversion direction:")
        print("1. Fahrenheit to Celsius")
        print("2. Celsius to Fahrenheit")
        print("0. Exit")

        choice = input("Enter your choice (0-2): ")

        if choice == "0":
            print("Exiting the program...")
            break

        if choice not in ["1", "2"]:
            print("Invalid choice. Please try again.\n")
            continue

        is_reverse = choice == "2"
        conversion_function = convert_fahrenheit_to_celsius if is_reverse else convert_celsius_to_fahrenheit
        conversion_direction = "Fahrenheit to Celsius" if is_reverse else "Celsius to Fahrenheit"
        temperature_type = "Celsius" if is_reverse else "Fahrenheit"

        temperatures = []
        while True:
            temperature = input(f"Enter a temperature in {temperature_type} (or 'done' to finish): ")

            if temperature == "done":
                break

            if not is_valid_temperature(temperature):
                print("Invalid temperature. Please enter a numeric value within the range of -459.67 to 10000.0.\n")
                continue

            temperatures.append(float(temperature))

        if not temperatures:
            print("No temperatures entered. Exiting the program...")
            break

        converted_temperatures = [conversion_function(temp) for temp in temperatures]

        print("\nTemperature Conversion Results")
        print("===============================")
        print(f"Conversion direction: {conversion_direction}\n")

        print("Original Temperature\tConverted Temperature")
        print("-------------------------------------------")
        for original, converted in zip(temperatures, converted_temperatures):
            print(f"{original:.2f}\t\t\t{converted:.2f}")

        print()

convert_temperatures()


def is_palindrome(string):
    left = 0
    right = len(string) - 1
    
    while left < right:
        if string[left] != string[right]:
            return False
        left += 1
        right -= 1
    
    return True

# Test the function
string = "ana"
print(is_palindrome(string))  # True


def is_palindrome(word):
    # Convert the word to lowercase
    word = word.lower()

    # Remove non-alphanumeric characters
    word = ''.join(char for char in word if char.isalnum())

    # Check if the word is equal to its reverse
    return word == word[::-1]


import random

def roll_dice():
    # Roll three dice
    dice1 = random.randint(1, 6)
    dice2 = random.randint(1, 6)
    dice3 = random.randint(1, 6)
    
    # Check if sum is greater than or equal to 15 and one dice shows an odd number
    if (dice1 + dice2 + dice3 >= 15) and (dice1 % 2 != 0 or dice2 % 2 != 0 or dice3 % 2 != 0):
        return dice1, dice2, dice3
    else:
        return roll_dice()  # Recursive call if conditions are not met

# Simulate rolling of dice until conditions are met
dice1, dice2, dice3 = roll_dice()

# Print the results
print(f"Dice 1: {dice1}")
print(f"Dice 2: {dice2}")
print(f"Dice 3: {dice3}")
print(f"Sum: {dice1 + dice2 + dice3}")


side_length = 10
perimeter = 4 * side_length
print("Perimeter of the square:", perimeter)


import socket
import sys

def get_ipv4_address(domain):
    try:
        ip = socket.getaddrinfo(domain, None, socket.AF_INET)[0][4][0]
        return ip
    except socket.gaierror as e:
        print(f"Error resolving {domain}: {e}")
    except socket.timeout:
        print(f"Timeout resolving {domain}")

def get_ipv4_addresses(domains):
    addresses = []
    for domain in domains:
        ip = get_ipv4_address(domain)
        if ip:
            addresses.append(ip)
    addresses.sort()
    return addresses

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python dns_resolver.py domain1 domain2 ...")
        sys.exit(1)
    
    domains = sys.argv[1:]
    addresses = get_ipv4_addresses(domains)
    
    for address in addresses:
        print(address)


def is_prime(n):
    if n < 2:  # 0 and 1 are not prime
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def filter_primes(numbers):
    primes = []
    for num in numbers:
        if is_prime(abs(num)):
            primes.append(num)
    return primes


total_sum = 0
for i in range(1, 1000001):
    total_sum += i

print("The sum of all numbers between 1 and 1 million is:", total_sum)


def print_pascals_triangle(num_rows):
    # Validate the input
    if not isinstance(num_rows, int) or num_rows <= 0 or num_rows > 100:
        print("Invalid input! Number of rows should be a positive integer less than or equal to 100.")
        return

    # Create an empty triangle
    triangle = []

    # Calculate Pascal's triangle
    for row in range(num_rows):
        triangle.append([1] * (row+1))
        if row > 1:
            for col in range(1, row):
                triangle[row][col] = triangle[row-1][col-1] + triangle[row-1][col]

    # Print Pascal's triangle
    for row in triangle:
        print(' '.join(map(str, row)))


# Test the function
num_rows = int(input("Enter the number of rows for Pascal's triangle: "))
print_pascals_triangle(num_rows)


class Node:
    def __init__(self, data=None):
        self.data = data
        self.prev = None
        self.next = None

class SortedLinkedList:
    def __init__(self):
        self.head = None

    def insert(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        elif data <= self.head.data:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        else:
            current = self.head
            while current.next and current.next.data < data:
                current = current.next
            new_node.next = current.next
            new_node.prev = current
            if current.next:
                current.next.prev = new_node
            current.next = new_node

    def delete(self, data):
        current = self.head
        while current and current.data != data:
            current = current.next
        if not current:
            return
        if current.prev:
            current.prev.next = current.next
        else:
            self.head = current.next
        if current.next:
            current.next.prev = current.prev

    def search(self, data):
        current = self.head
        index = 0
        while current and current.data != data:
            current = current.next
            index += 1
        if current:
            return index
        else:
            return -1


def recursive_function(n):
    if n == 0:
        return "Termination condition reached"
    elif n < 0:
        raise ValueError("Input must be a positive integer")
    else:
        try:
            return recursive_function(n - 1)
        except ValueError as error:
            return str(error)

def main_function(input_value):
    try:
        result = recursive_function(input_value)
        print("Result:", result)
    except Exception as error:
        print("An error occurred:", str(error))

# Testing with different data types
main_function(5)
main_function(0)
main_function(-3)
main_function("hello")
main_function([1, 2, 3])


import re

def count_words_with_consecutive_vowels(filename):
    count = 0
    pattern = re.compile(r'[aeiou]{2,}', re.IGNORECASE)
    
    with open(filename, 'r') as file:
        for line in file:
            words = line.split()
            for word in words:
                if pattern.match(word) and not re.search(r'[aeiou]{2,}\W', word, re.IGNORECASE):
                    count += 1
                    
    return count

# Example usage
filename = 'input.txt'
total_count = count_words_with_consecutive_vowels(filename)
print("Total count of words with at least two consecutive vowels:", total_count)


import json

def sort_json(json_string):
    json_data = json.loads(json_string)
    flattened_data = flatten_json(json_data)
    sorted_data = sorted(flattened_data, key=lambda x: x[0])
    return remove_duplicates(sorted_data)

def flatten_json(json_data, parent_key='', separator='.'):
    flattened_data = []
    for key, value in json_data.items():
        new_key = f"{parent_key}{separator}{key}" if parent_key else key
        if isinstance(value, dict):
            flattened_data.extend(flatten_json(value, new_key, separator=separator))
        elif isinstance(value, list):
            for i, item in enumerate(value):
                flattened_data.extend(flatten_json({str(i): item}, new_key, separator=separator))
        else:
            flattened_data.append((new_key, value))
    return flattened_data

def remove_duplicates(sorted_data):
    unique_data = {}
    for key, value in sorted_data:
        unique_data[key] = value
    return list(unique_data.items())

# Example usage
json_string = '{"key2": "value2", "key1": "value1", "key1": "value3"}'
result = sort_json(json_string)
print(result)

json_string = '{"key2": "value2", "key1": {"nestedKey2": "nestedValue2", "nestedKey1": "nestedValue1"}, "key1": {"nestedKey1": "nestedValue3", "nestedKey2": "nestedValue4"}}'
result = sort_json(json_string)
print(result)


# Importing necessary library for converting numbers to Roman numerals
import roman

# Given list
my_list = ["apple", "banana", "cherry", "date", "elderberry"]

# Sorting the list in descending order
my_list.sort(reverse=True)

# Initializing a counter for the index
index_counter = 1

# Iterating over the list
for i, item in enumerate(my_list):
    # Checking if the item is a string and the index is odd
    if isinstance(item, str) and index_counter % 2 != 0:
        # Converting the index to Roman numerals
        roman_numeral = roman.toRoman(index_counter)
        # Printing the formatted output
        print("Index: {}, Item: {}".format(roman_numeral, item.upper()))
    # Incrementing the counter for the index
    index_counter += 1


def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def copy_smaller_primes(input_array, new_array, index):
    # Base cases
    if index == len(input_array) or len(new_array) == 5:
        return new_array
    
    # Recursive case
    if input_array[index] < 5 and is_prime(input_array[index]):
        new_array.append(input_array[index])
    
    return copy_smaller_primes(input_array, new_array, index + 1)

# Example usage
input_array = [2, 4, 3, 6, 1, 8, 7]
new_array = []
result = copy_smaller_primes(input_array, new_array, 0)
print(result)


import math

def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    sqrt_n = int(math.sqrt(n)) + 1
    for i in range(3, sqrt_n, 2):
        if n % i == 0:
            return False
    return True

def sort_numbers(numbers):
    primes = []
    non_primes = []
    for num in numbers:
        if is_prime(num):
            primes.append(num)
        else:
            non_primes.append(num)
    return sorted(primes, reverse=True) + sorted(non_primes, reverse=True)


class IntegerKeyStringValDict(dict):
    def __setitem__(self, key, value):
        if not isinstance(key, int):
            raise TypeError("Keys must be integers.")
        if not isinstance(value, str):
            raise TypeError("Values must be strings.")
        super().__setitem__(key, value)

# Create an instance of the custom dictionary
my_dict = IntegerKeyStringValDict()

# Adding items to the dictionary
my_dict[1] = "Hello"
my_dict[2] = "World"

# Trying to add items with invalid types
try:
    my_dict["3"] = "Invalid key"
except TypeError as e:
    print(e)  # Keys must be integers.

try:
    my_dict[3] = 42
except TypeError as e:
    print(e)  # Values must be strings.


class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        if self.is_empty():
            return "Stack is empty"
        return self.stack.pop()

    def is_empty(self):
        return len(self.stack) == 0


from queue import PriorityQueue

def min_stones(piles, k):
    task_indices = sorted(range(len(piles)), key=lambda i: piles[i])
    min_heap = PriorityQueue()
    time = 0
    task_idx = 0
    result = []

    while task_indices:
        while task_idx < len(task_indices) and piles[task_indices[task_idx]] <= time:
            idx = task_indices[task_idx]
            min_heap.put(((-1)*piles[idx], idx))
            task_idx += 1

        if not min_heap.empty() and k > 0:
            _, index = min_heap.get()
            piles[index] = (-1)*min_heap.get()[0]
            piles[index] = (-1)*piles[index]//2
            piles[index] = (-1)*piles[index]
            k -= 1
            task_indices = sorted(range(len(piles)), key=lambda i: piles[i])
            time += 1
        elif task_idx < len(task_indices):
            time = piles[task_indices[task_idx]]
        else:
            break

    return sum(piles)


def find_first_non_duplicate(string):
    # Create a dictionary to store the count of each character
    character_count = {}
    
    # Convert the string to lowercase
    string = string.lower()
    
    # Iterate over each character in the string
    for char in string:
        # If the character is already in the dictionary, increment its count
        # Otherwise, add the character to the dictionary with a count of 1
        if char in character_count:
            character_count[char] += 1
        else:
            character_count[char] = 1
    
    # Iterate over the original string to find the first non-duplicate character
    for char in string:
        # If the count of the character is 1, return it
        if character_count[char] == 1:
            return char
    
    # If no non-duplicate character is found, return None
    return None

# Test the function with the given example
print(find_first_non_duplicate("aPpLe!123"))  # Output: "P"


from functools import lru_cache

class Job:
    def __init__(self, start, end, profit):
        self.start = start
        self.end = end
        self.profit = profit

def find_next_job(jobs, i):
    for j in range(i + 1, len(jobs)):
        if jobs[j].start >= jobs[i].end:
            return j
    return -1

@lru_cache(None)
def max_profit_helper(jobs, i):
    if i == -1:
        return 0

    next_job = find_next_job(jobs, i)
    incl_curr_job = jobs[i].profit + max_profit_helper(jobs, next_job)
    excl_curr_job = max_profit_helper(jobs, i - 1)
    
    return max(incl_curr_job, excl_curr_job)

def max_profit(startTime, endTime, profit):
    n = len(startTime)
    jobs = [Job(startTime[i], endTime[i], profit[i]) for i in range(n)]

    jobs.sort(key=lambda job: job.end)
    
    return max_profit_helper(tuple(jobs), n - 1)


import math

def degrees_to_radians(degrees):
    pi = math.pi
    radians = (degrees * pi) / 180
    return radians


def sort_array(arr, num):
    def sum_digits(n):
        sum = 0
        while n != 0:
            sum += n % 10
            n = n // 10
        return sum

    return sorted(arr, key=sum_digits, reverse=True)


import heapq

def find_shortest_path(matrix, start, end):
    rows, cols = len(matrix), len(matrix[0])
    distances = [[float('inf')] * cols for _ in range(rows)]
    distances[start[0]][start[1]] = 0

    pq = [(0, start)]

    while pq:
        dist, current = heapq.heappop(pq)

        if current == end:
            return dist

        if dist > distances[current[0]][current[1]]:
            continue

        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = current[0] + dx, current[1] + dy

            if 0 <= nx < rows and 0 <= ny < cols:
                new_dist = dist + matrix[nx][ny]

                if new_dist < distances[nx][ny]:
                    distances[nx][ny] = new_dist
                    heapq.heappush(pq, (new_dist, (nx, ny)))

    return -1  # No path found

matrix = [[1, 8, 3],
          [4, 5, 6],
          [9, 5, 0]]
start = (0, 0)
end = (2, 2)

shortest_path = find_shortest_path(matrix, start, end)
print("Shortest path length:", shortest_path)


import string

def is_palindrome(string):
    # Remove whitespace, punctuation, and convert to lowercase
    clean_string = "".join(char.lower() for char in string if char not in string.punctuation and char != " ")

    # Check if the clean string is equal to its reverse
    return clean_string == clean_string[::-1]

# Prompt the user for input
input_lines = input("Enter one or more lines of text: ")

# Split the input into individual lines
lines = input_lines.split("\n")

# Check each line for palindromicity and output the result
for line in lines:
    if is_palindrome(line):
        print("Palindrome")
    else:
        print("Not Palindrome")


def splitIntoFibonacci(num):
    ans = []
    def backtrack(index, prev1, prev2):
        if index == len(num):
            return len(ans) >= 3
        curr = 0
        for i in range(index, len(num)):
            if i > index and num[index] == '0':
                break
            curr = curr * 10 + ord(num[i]) - ord('0')
            if curr > 2**31 - 1:
                break
            if len(ans) >= 2:
                if curr < prev1 + prev2:
                    continue
                elif curr > prev1 + prev2:
                    break
            ans.append(curr)
            if backtrack(i + 1, prev2, curr):
                return True
            ans.pop()
        return False
            
    backtrack(0, 0, 0)
    return ans


for i in range(1, 11):
    for j in range(1, 11):
        product = i * j
        print(f'{i} * {j} = {product:2}', end='  ')
    print()


import xml.etree.ElementTree as ET

def get_key_value(xml, key):
    root = ET.fromstring(xml)

    highest_score = float('-inf')
    player_with_highest_score = None

    def extract_key_value(element, key, current_depth):
        if current_depth > 3:
            return
        if element.tag == 'score':
            score = float(element.find('score').text)
            if score > highest_score:
                highest_score = score
                player_with_highest_score = element.find('name').text
        for child in element:
            extract_key_value(child, key, current_depth + 1)

    extract_key_value(root, key, 0)

    return highest_score, player_with_highest_score


def find_median(arr):
    n = len(arr)
    mid = n // 2
    
    # Find the kth smallest element using the QuickSelect algorithm
    kth_smallest = quickselect(arr, 0, n - 1, mid)
    
    # Count the frequency of the kth smallest element
    frequency = arr.count(kth_smallest)
    
    # Find the medians with the highest frequency
    medians = []
    for num in arr:
        if arr.count(num) == frequency:
            medians.append(num)
    
    # Find the median with the smallest absolute value
    median = min(medians, key=abs)
    
    return median


def quickselect(arr, left, right, k):
    if left == right:
        return arr[left]
    
    pivot_index = partition(arr, left, right)
    
    if k == pivot_index:
        return arr[k]
    elif k < pivot_index:
        return quickselect(arr, left, pivot_index - 1, k)
    else:
        return quickselect(arr, pivot_index + 1, right, k)


def partition(arr, left, right):
    pivot = arr[right]
    i = left - 1
    
    for j in range(left, right):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[right] = arr[right], arr[i + 1]
    
    return i + 1


# Test the script
arr = [1, 2, 3, 4, 5]
median = find_median(arr)
print("Median:", median)

arr = [1, 2, 3, 4, 5, 5, 5]
median = find_median(arr)
print("Median:", median)

arr = [-5, -4, -3, -2, -1]
median = find_median(arr)
print("Median:", median)

arr = [-5, -4, -3, -2, -1, -1, -1]
median = find_median(arr)
print("Median:", median)


import json

def parse_json(json_data):
    result = []

    def parse_object(obj, prefix=""):
        if isinstance(obj, dict):
            for key, value in obj.items():
                new_prefix = f"{prefix}.{key}" if prefix else key
                if isinstance(value, (dict, list)):
                    parse_object(value, new_prefix)
                else:
                    result.append({"key": new_prefix, "value": value})
        elif isinstance(obj, list):
            for index, value in enumerate(obj):
                new_prefix = f"{prefix}[{index}]"
                if isinstance(value, (dict, list)):
                    parse_object(value, new_prefix)
                else:
                    result.append({"key": new_prefix, "value": value})

    parse_object(json_data)
    return result

# Example usage
json_data = '''
{
  "key1": "value1",
  "key2": {
    "subkey1": "subvalue1",
    "subkey2": [1, 2, 3]
  },
  "key3": [4, 5, 6]
}
'''

parsed_data = parse_json(json.loads(json_data))
for item in parsed_data:
    print(item)


my_list = [
    {'name': 'John', 'age': 25},
    {'name': 'Jane', 'age': 30},
    {'name': 'Alice', 'age': 35}
]

index = 0
length = len(my_list)

while index < length:
    item = my_list[index]
    # Perform operations on the dictionary item
    print(item)
    
    index += 1


import math
import multiprocessing
def factorial(n):
    if n < 0:
        return "Error: factorial of negative number"
    elif n == 0:
        return 1
    else:
        num_processors = multiprocessing.cpu_count()
        sublist_size = math.ceil(n/num_processors)
        num_sublists = math.ceil(n/sublist_size)
        pool = multiprocessing.Pool(processes=num_processors)
        sublists = [list(range(i*sublist_size+1, min((i+1)*sublist_size+1, n+1))) for i in range(num_sublists)]
        products = pool.map(lambda sublist: math.prod(sublist), sublists)
        pool.close()
        pool.join()
        while len(products) > 1:
            products = [products[i] * products[i+1] for i in range(0, len(products), 2)]
        return products[0]


def power(base, p):
    if p == 0:
        return 1
    
    result = 1
    abs_p = abs(p)
    
    while abs_p > 0:
        if abs_p % 2 == 1:
            result *= base
        
        base *= base
        abs_p //= 2
    
    return result if p > 0 else 1/result


from heapq import heappush, heappop

def getLastMoment(n, k, time):
    left = [(time[j][0] + time[j][2], j) for j in range(k)]
    right = []

    while n:
        while right and right[0][0] <= left[0][0]:
            right_top = heappop(right)
            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))
        left_top = heappop(left)
        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]
        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))
        n -= 1

    lastMoment = -1
    while right:
        right_top = heappop(right)
        lastMoment = max(lastMoment, time[right_top[1]][2])
    return lastMoment


def caesar_cipher(string, shift):
    result = ""
    
    for char in string:
        if char.isalpha():
            unicode_offset = ord('A') if char.isupper() else ord('a')
            shifted_unicode = (ord(char) - unicode_offset + shift) % 26 + unicode_offset
            result += chr(shifted_unicode)
        else:
            result += char
    
    return result


import random

def partition(arr, low, high):
    i = low - 1
    pivot = arr[high]
    
    for j in range(low, high):
        if arr[j] >= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i+1

def quicksort(arr, low, high):
    if low < high:
        pivot_index = random.randint(low, high)
        arr[high], arr[pivot_index] = arr[pivot_index], arr[high]
        
        pivot = partition(arr, low, high)
        
        quicksort(arr, low, pivot-1)
        quicksort(arr, pivot+1, high)

def sort_descending(arr):
    quicksort(arr, 0, len(arr)-1)
    return arr


numbers = [15, 20, 12, 18, 10]
numbers.sort(reverse=True)

print(numbers)


def count_and_sum_elements(array, x):
    count = 0
    sum_of_elements = 0
    
    for element in array:
        if element > x:
            count += 1
            sum_of_elements += element
    
    return count, sum_of_elements

array = [2, 3, 5, 7, 11, 13]
x = 4

count, sum_of_elements = count_and_sum_elements(array, x)
print("Count of elements larger than", x, ":", count)
print("Sum of elements larger than", x, ":", sum_of_elements)


def linear_search(array, target):
    indices = []
    for i in range(len(array)):
        if array[i] == target:
            indices.append(i)
    return indices

# Example usage
arr = [4, 2, 1, 5, 2, 3, 2]
target = 2
result = linear_search(arr, target)
print(result)  # Output: [1, 4, 6]


def calculate_triangle_area():
    try:
        base = float(input("Enter the base of the triangle: "))
        height = float(input("Enter the height of the triangle: "))
        
        if base <= 0 or height <= 0:
            raise ValueError("Base and height must be positive numbers.")
        
        if base.is_integer() and height.is_integer():
            area = int(base * height / 2)
            print("The area of the triangle is:", area)
        else:
            raise ValueError("Base and height must be integers.")
    
    except ValueError as e:
        print("Error:", e)


def sort_array(arr):
    arr.sort(key=lambda x: (x[1], -x[0]), reverse=True)
    return arr

# Example usage:
arr = [[1, 3], [2, 2], [3, 1], [4, 2], [5, 1]]
sorted_arr = sort_array(arr)
print(sorted_arr)


def find_max_positive(arr):
    max_positive = -1
    max_index = -1
    
    for i, num in enumerate(arr):
        if num > 0 and (max_positive == -1 or num > max_positive):
            max_positive = num
            max_index = i
    
    return max_index


def count_occurrences(arr, specific_value):
    count = 0
    for element in arr:
        if element == specific_value:
            count += 1
    return count


def find_maximum(arr):
    if len(arr) == 0:
        return None
    
    max_num = arr[0]
    
    for num in arr:
        if type(num) != int:
            return None
        if num > max_num:
            max_num = num
    
    return max_num


def flatten_array(arr):
    if not arr:
        return []
    
    result = []
    for element in arr:
        if isinstance(element, list):
            result.extend(flatten_array(element))
        else:
            result.append(element)
    
    return result


def count_integers(lst):
    return len(lst)

# Test the program with example input
input_list = [2, 5, 7, 3, 8]
result = count_integers(input_list)
print(result)


import time

# Constants
MIN_RANGE = 1
MAX_RANGE = 10
TIME_LIMIT = 10

# Function to validate user input
def validate_input(user_input):
    try:
        user_number = int(user_input)
        if user_number < MIN_RANGE or user_number > MAX_RANGE:
            print("Error: Please enter a positive integer between", MIN_RANGE, "and", MAX_RANGE)
            return False
        return True
    except ValueError:
        print("Error: Please enter a valid positive integer")
        return False

# Function to print the multiplication table
def print_multiplication_table(number):
    print("Multiplication Table for", number)
    print("-----------------------------")
    for i in range(1, 11):
        print(number, "x", i, "=", number * i)

# Prompt user for input with time limit
start_time = time.time()
while True:
    if time.time() - start_time > TIME_LIMIT:
        print("Time limit exceeded. Exiting program.")
        break

    user_input = input("Enter a positive integer between " + str(MIN_RANGE) + " and " + str(MAX_RANGE) + ": ")
    if validate_input(user_input):
        print_multiplication_table(int(user_input))
        break


from django.shortcuts import render
from django.http import HttpResponse
from datetime import datetime
from .models import User

def form_view(request):
    if request.method == 'POST':
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        email = request.POST.get('email')

        if not first_name or not last_name:
            error_message = "First Name and Last Name fields should not be left blank."
            return render(request, 'form.html', {'error_message': error_message})
        
        if not email:
            error_message = "Email Address field should not be left blank."
            return render(request, 'form.html', {'error_message': error_message})
        
        if not validate_email(email):
            error_message = "Email Address is not in a valid format."
            return render(request, 'form.html', {'error_message': error_message})

        if User.objects.filter(email=email).exists():
            error_message = "Email Address already exists in the database."
            return render(request, 'form.html', {'error_message': error_message})

        # All inputs are valid, store data in the database
        user = User(first_name=first_name, last_name=last_name, email=email)
        user.save()

        # Get current date and time
        current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        success_message = "Form submitted successfully!"
        return render(request, 'form.html', {'success_message': success_message, 'current_datetime': current_datetime})

    return render(request, 'form.html')

def validate_email(email):
    from django.core.validators import validate_email
    from django.core.exceptions import ValidationError

    try:
        validate_email(email)
        return True
    except ValidationError:
        return False


def traverse_dict(dictionary):
    for key, value in dictionary.items():
        print(key, value)
        if isinstance(value, dict):
            traverse_dict(value)


def multiply(a: int, b: int) -> int:
    result = 0

    while b != 0:
        if b & 1:
            result += a

        a <<= 1
        b >>= 1

    return result


def find_max_subarray_sum(A):
    if not A or not any(A):
        return []

    max_sums = []
    for row in A:
        if all(num < 0 for num in row):
            max_sums.append(0)
        elif all(num >= 0 for num in row):
            max_sums.append(sum(row))
        else:
            max_sum = 0
            current_sum = 0
            for num in row:
                current_sum += num
                if current_sum < 0:
                    current_sum = 0
                elif current_sum > max_sum:
                    max_sum = current_sum
            max_sums.append(max_sum)

    return max_sums


def count_and_print_even_elements(arr):
    count = 0
    index = 0
    
    while index < len(arr):
        if arr[index] % 2 == 0:
            print(arr[index])
            count += 1
        index += 1
    
    return count


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_nth_prime(n):
    count = 0
    number = 2
    while count < n:
        if is_prime(number):
            count += 1
        number += 1
    return number - 1

n = int(input("Enter the value of N: "))
nth_prime = find_nth_prime(n)
print(f"The {n}th prime number is {nth_prime}.")


import random

numbers = []
temp = []

for i in range(0, 10):
    while True:
        num = random.randint(0, 9)
        if num not in temp:
            break
    
    numbers.append(num)
    numbers.append(num)
    temp.append(num)

random.shuffle(numbers)

print(numbers)


def replace_and_count(sentence):
    # Replace semicolons, exclamation marks, and question marks with underscores
    sentence = sentence.replace(";", "_").replace("!", "_").replace("?", "_")
    
    # Count the number of words in the sentence
    words = sentence.split()
    word_count = len(words)
    
    # Find the longest word
    longest_word = max(words, key=len)
    
    return sentence, word_count, longest_word


# Example usage
input_sentence = "Hello! How are you doing today?; I hope everything is fine!"
result = replace_and_count(input_sentence)
print("Replaced Sentence:", result[0])
print("Word Count:", result[1])
print("Longest Word:", result[2])


def scientific_to_decimal(num):
    coefficient, exponent = num.split('e')
    return float(coefficient) * 10 ** int(exponent)


def print_least_significant_digit(n):
    # Convert the integer to a string for easier manipulation
    n_str = str(n)
    
    # Handle negative numbers
    if n < 0:
        # Take the absolute value and convert it back to a string
        n_str = str(abs(n))
    
    # Get the least significant digit
    least_significant_digit = int(n_str[-1])
    
    # Get the second least significant digit, if it exists
    second_least_significant_digit = 0
    if len(n_str) > 1:
        second_least_significant_digit = int(n_str[-2])
    
    # Print the least significant digit
    print("Least significant digit:", least_significant_digit)
    
    # Calculate the sum of the least significant digit and the second least significant digit
    sum_digits = least_significant_digit + second_least_significant_digit
    print("Sum of least significant digit and second least significant digit:", sum_digits)


def character_frequency(string):
    # Initialize a list to store the frequency of each character
    frequency = [0] * 26

    # Iterate over each character in the string
    for char in string:
        # Ignore non-alphabetic characters
        if char.isalpha():
            # Convert the character to lowercase
            char = char.lower()
            # Increment the frequency count of the character
            frequency[ord(char) - ord('a')] += 1

    # Initialize a list to store the result
    result = []

    # Iterate over the frequency list and add characters with non-zero frequency to the result
    for i in range(26):
        if frequency[i] > 0:
            # Convert the index to the corresponding character
            char = chr(i + ord('a'))
            # Add the character and its frequency to the result
            result.append((char, frequency[i]))

    # Sort the result in descending order based on frequency
    result.sort(key=lambda x: x[1], reverse=True)

    return result

# Test the program
string = input("Enter a string: ")
result = character_frequency(string)
print("Character frequency:")
for char, freq in result:
    print(f"{char}: {freq}")


def is_palindrome(s):
    # Remove whitespace and punctuation marks
    s = ''.join(char.lower() for char in s if char.isalnum())
    
    # Handle HTML tags by removing them
    s = ''.join(char for char in s if char != '<' and char != '>')
    
    # Check if the string is a palindrome
    return s == s[::-1]


import xml.etree.ElementTree as ET
def find_equal_value_pair(strings):
    ascii_sum = {}
    for string in strings:
        sum = 0
        for char in string:
            sum += ord(char)
        if sum in ascii_sum:
            return (ascii_sum[sum], string)
        ascii_sum[sum] = string
    return None
# Example usage
xml_string = "<strings><string>abc123</string><string>123abc</string><string>456def</string></strings>"
root = ET.fromstring(xml_string)
strings = [string.text for string in root.findall('string')]
print(find_equal_value_pair(strings))


def replace_a_with_the(word_string):
    words = word_string.split()
    for i in range(len(words)):
        if words[i].lower() == 'a':
            # Check if the word is a standalone "a" (not a part of another word)
            if i == 0 or not words[i-1].isalpha():
                # Preserve the original word's case
                if words[i].islower():
                    words[i] = 'the'
                elif words[i].istitle():
                    words[i] = 'The'
                elif words[i].isupper():
                    words[i] = 'THE'
    
    return ' '.join(words)

word_string = "I am learning a lot of new things! A cat is sitting on a mat."
modified_string = replace_a_with_the(word_string)
print(modified_string)


def print_multiplication_table(x, n):
    # Step 1: Check if x is positive
    if x <= 0:
        print("Error: x must be a positive number")
        return
    
    # Step 2: Check if n is positive
    if n <= 0:
        print("Error: n must be a positive number")
        return
    
    # Step 3: Iterate from 1 to n
    for i in range(1, n+1):
        # Step 3a: Print the value of i followed by a colon
        print(str(i) + ":", end="")
        
        # Step 3b: Iterate from 1 to x
        for j in range(1, x+1):
            # Step 3bi: Calculate the product of i and j
            product = i * j
            # Step 3bii: Print the product followed by a tab character
            print(str(product) + "\t", end="")
        
        # Step 3c: Print a new line character
        print()

# Testing the function
print_multiplication_table(8, 5)


class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

def convertBSTToArray(root):
    result = []
    stack = []
    current = root
    
    while current is not None or len(stack) > 0:
        while current is not None:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        result.append(current.val)
        
        current = current.right
    
    return result


def is_palindrome(s):
    return s == s[::-1]

def get_palindromes(list_strings):
    palindromes = []
    for s in list_strings:
        if is_palindrome(s):
            palindromes.append(s)
    return palindromes

list_strings = ["racecar", "dog", "madam", "duck", "level", "cut"]
palindromes = get_palindromes(list_strings)
print(palindromes)


def is_anagram(word1, word2):
    # Convert the strings to lowercase and remove any whitespace
    word1 = word1.lower().replace(" ", "")
    word2 = word2.lower().replace(" ", "")
    
    # Check if the lengths of the two words are equal
    if len(word1) != len(word2):
        return False
    
    # Sort the letters of both words and compare them
    sorted_word1 = sorted(word1)
    sorted_word2 = sorted(word2)
    
    if sorted_word1 == sorted_word2:
        return True
    else:
        return False

# Example usage
word1 = "listen"
word2 = "silent"
print(is_anagram(word1, word2))  # Output: True

word1 = "listen"
word2 = "tislen"
print(is_anagram(word1, word2))  # Output: False


import datetime

try:
    given_date = datetime.datetime.strptime("1972-05-18 12:00 PM", "%Y-%m-%d %I:%M %p")
    utc_time = datetime.datetime.utcnow()
    unix_timestamp = (given_date - datetime.datetime(1970, 1, 1)).total_seconds()

    if unix_timestamp < 0:
        raise ValueError("The given date is before the UNIX epoch (January 1, 1970).")

    rounded_timestamp = int(unix_timestamp)

    print(rounded_timestamp)
except ValueError as e:
    print("Error:", str(e))


async def my_async_function():
    # Code that may raise exceptions
    ...

try:
    # Invoking the coroutine function
    asyncio.run(my_async_function())
except Exception as e:
    # Exception handling code
    ...


import random
class Plant:
    def __init__(self, temperature, humidity, soil_type):
        self.temperature = temperature
        self.humidity = humidity
        self.soil_type = soil_type
        self.genes = [random.randint(0, 1) for _ in range(10)]
        
    def grow(self):
        # simulate plant growth based on environmental factors and genes
        pass
        
class Garden:
    def __init__(self, temperature, humidity, soil_type):
        self.temperature = temperature
        self.humidity = humidity
        self.soil_type = soil_type
        self.plants = [Plant(temperature, humidity, soil_type) for _ in range(10)]
        
    def simulate(self, days):
        for _ in range(days):
            for plant in self.plants:
                plant.grow()
                
    def add_plant(self, plant):
        self.plants.append(plant)
        
    def remove_plant(self, plant):
        self.plants.remove(plant)
        
    def get_plants(self):
        return self.plants
        
if __name__ == '__main__':
    # create a garden with random environmental factors
    garden = Garden(random.randint(50, 100), random.randint(50, 100), random.choice(['sandy', 'clay', 'loam']))
    
    # simulate plant growth for 100 days
    garden.simulate(100)
    
    # print the list of plants in the garden
    for plant in garden.get_plants():
        print(plant)


def convert_to_list(input_string):
    input_string = input_string.strip()
    
    if not input_string:
        return []
    
    elements = input_string.split(',')
    unique_elements = set([element.strip().lower() for element in elements])
    
    return list(unique_elements)


def longest_consecutive_sequence(my_string):
    max_len = 0
    curr_len = 0
    start = -1
    end = -1
    vowels = "aeiou"

    for i, c in enumerate(my_string):
        if c in vowels:
            curr_len = 0
        else:
            if curr_len == 0:
                start = i
            curr_len += 1
            if curr_len > max_len:
                max_len = curr_len
                end = i

    return my_string[start:end+1]


def min_moves_to_sort(arr):
    n = len(arr)
    numSwaps = 0

    for i in range(n):
        swap = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                numSwaps += 1
                swap = True

        if not swap:
            break

    return numSwaps


arr = [100000, 20000, 3000, 400, 50]

# Convert integers to strings in scientific notation without leading zeros
arr_str = [f'{num:e}'.replace('e+0', 'e+') for num in arr]

# Reverse the array
arr_str.reverse()

# Join the elements with commas
result = ','.join(arr_str)

print(result)


def caesar_cipher(string, shift):
    # Ensure shift value is between 1 and 25
    shift = shift % 26

    # Initialize an empty string for the encrypted result
    encrypted_string = ""

    # Iterate through each character in the input string
    for char in string:
        # Check if the character is an alphabetic letter
        if char.isalpha():
            # Determine if the letter is uppercase or lowercase
            if char.isupper():
                # Convert the letter to its ASCII code, apply the shift, and convert back to a letter
                encrypted_char = chr((ord(char) - 65 + shift) % 26 + 65)
            else:
                encrypted_char = chr((ord(char) - 97 + shift) % 26 + 97)
        else:
            # Non-alphabetic characters remain unchanged
            encrypted_char = char

        # Append the encrypted character to the result string
        encrypted_string += encrypted_char

    return encrypted_string


def distinct_numbers(n):
    return n - 1


import json
# read JSON input
input_data = '{"angle1": 9, "angle2": 48}'
input_json = json.loads(input_data)
# extract angles from JSON
angle1 = input_json['angle1']
angle2 = input_json['angle2']
# calculate third angle
angle3 = 180 - angle1 - angle2
# create JSON output
output_json = json.dumps({'angle3': angle3})
# print JSON output
print(output_json)


class NumberList:
    def __init__(self, numbers):
        self.numbers = numbers
    
    def sum_numbers(self):
        return sum(self.numbers)
    
    def product_numbers(self):
        result = 1
        for num in self.numbers:
            result *= num
        return result
    
    def max_number(self):
        return max(self.numbers)


import re

disposable_domains = ["domain1.com", "domain2.net", "domain3.org"]

regex_pattern = r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"

if re.match(regex_pattern, email_address) and email_address.split("@")[1] not in disposable_domains:
    print("Valid email address and not a disposable domain.")
else:
    print("Invalid email address or belongs to a disposable domain.")


import re
text = "hipvinylster"
pattern = r"^hip(.*)(tea|vinyl|beard|tweed|glasses|vegan)ster$"
match = re.search(pattern, text)
if match:
 username = match.group(0)
 print(username)
else:
 print("No match found.")


import math

def is_prime(n):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

# Define the range
start = 10
end = 30

# Convert the range to a list and filter out prime numbers
prime_list = [x for x in range(start, end + 1) if is_prime(x)]

# Sort the list in ascending order
prime_list.sort()

# Print the resulting list
print(prime_list)


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def get_primes(lst):
    primes = []
    for num in lst:
        if is_prime(num):
            primes.append(num)
    return primes


import re

def count_word_frequency(string):
    # Convert string to lowercase
    string = string.lower()

    # Remove punctuation and special characters
    string = re.sub(r'[^\w\s]', '', string)

    # Split string into words
    words = string.split()

    # Count word frequency
    word_frequency = {}
    for word in words:
        if word in word_frequency:
            word_frequency[word] += 1
        else:
            word_frequency[word] = 1

    return word_frequency

# Example usage
string = "This is a test string, test it!"
frequency = count_word_frequency(string)
print(frequency)


import random

class ContinuumRandomTree:
    def __init__(self, value=None):
        self.value = value
        self.children = []
    
    def add_child(self, min_value, max_value):
        while True:
            new_value = random.uniform(min_value, max_value)
            if new_value not in [child.value for child in self.children]:
                break
        new_child = ContinuumRandomTree(value=new_value)
        self.children.append(new_child)
        return new_child


from bisect import insort

class DataStructure:
    def __init__(self):
        self.data = {}
        self.keys = []

    def insert(self, key, value):
        if key in self.data:
            raise ValueError("Key already exists")
        self.data[key] = value
        insort(self.keys, key)

    def get(self, key):
        if key not in self.data:
            raise ValueError("Key does not exist")
        return self.data[key]

    def delete(self, key):
        if key not in self.data:
            raise ValueError("Key does not exist")
        value = self.data.pop(key)
        self.keys.remove(key)
        return value

    def exists(self, key):
        return key in self.data

    def get_sorted_keys(self):
        return self.keys

    def num_elements(self):
        return len(self.data)

    def max_value_key(self):
        max_key = None
        max_value = float('-inf')
        for key, value in self.data.items():
            if value > max_value:
                max_value = value
                max_key = key
        return max_key

    def min_value_key(self):
        min_key = None
        min_value = float('inf')
        for key, value in self.data.items():
            if value < min_value:
                min_value = value
                min_key = key
        return min_key

    def average_value(self):
        if len(self.data) == 0:
            return 0
        return sum(self.data.values()) / len(self.data)

    def sum_values(self):
        return sum(self.data.values())


def find_kth_number(n, k):
    nums = [i for i in range(1, n + 1)]
    nums.sort(key=lambda x: str(x))
    return nums[k - 1]


def can_reorder_array(arr):
    from collections import Counter
    
    count = Counter(arr)
    arr = sorted(arr)
    for x in arr:
        if count[x] == 0:
            continue
        if count[2 * x] > 0:
            count[x] -= 1
            count[2 * x] -= 1
        else:
            return False
    return True


def fibonacci(n):
    sequence = [0, 1]
    for i in range(2, n):
        sequence.append(sequence[i-1] + sequence[i-2])
    return sequence

fib_sequence = fibonacci(100)
for num in fib_sequence:
    print(num)


import random
import string

def generate_password(length):
    while True:
        password = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))
        if (any(char.islower() for char in password) and 
            any(char.isupper() for char in password) and 
            any(char.isdigit() for char in password) and 
            any(char in string.punctuation for char in password)):
            return password


import xml.etree.ElementTree as ET

# Parse the XML document
tree = ET.parse('example.xml')
root = tree.getroot()

# Function to count and display attributes for each element
def count_and_display_attributes(element):
    # Get the attributes for the element
    attributes = element.attrib
    
    # Sort the attributes in alphabetical order
    sorted_attributes = sorted(attributes.keys())
    
    # Print the number of attributes for the element
    print(f"Element '{element.tag}' has {len(attributes)} attributes: {', '.join(sorted_attributes)}")
    
    # Print the attribute tag names in reverse alphabetical order
    for attribute in reversed(sorted_attributes):
        print(f"Attribute '{attribute}' belongs to element '{element.tag}'")

# Traverse the XML document and count/display attributes for each element
def traverse_xml(element):
    # Count and display attributes for the current element
    count_and_display_attributes(element)
    
    # Recursively traverse child elements
    for child in element:
        traverse_xml(child)

# Start traversing the XML document from the root element
traverse_xml(root)


def remove_apples(fruits):
    i = 0
    while i < len(fruits):
        if fruits[i] == "Apple":
            fruits = fruits[:i] + fruits[i+1:]
        else:
            i += 1
    return fruits


string = input("Enter a string: ")  # Prompt user to enter a string

# Get the last character of the string
last_character = string[-1]

# Convert the last character to uppercase
uppercase_last_character = last_character.upper()

# Display the uppercase last character
print("Uppercase last character:", uppercase_last_character)


def replace_character():
    # Prompt the user to enter the string, character, and replacement character
    string = input("Enter the string: ")
    character = input("Enter the character to be replaced: ")
    replacement = input("Enter the replacement character: ")

    # Check for empty inputs
    if string == "" or character == "" or replacement == "":
        print("Error: Please enter a non-empty string, character, and replacement character.")
        return

    # Check if the replacement character is more than one character long
    if len(replacement) > 1:
        print("Error: Replacement character should be a single character.")
        return

    # Check if the replacement character is a special character
    if replacement == "\n" or replacement == "\t":
        print("Error: Replacement character cannot be a special character.")
        return

    # Prompt the user to choose case sensitivity
    case_sensitive = input("Do you want the replacement to be case-sensitive? (y/n): ")
    case_sensitive = case_sensitive.lower()

    # Check for valid choice for case sensitivity
    if case_sensitive != "y" and case_sensitive != "n":
        print("Error: Invalid choice for case sensitivity. Please enter 'y' or 'n'.")
        return

    # Perform the replacement based on case sensitivity
    if case_sensitive == "y":
        count = string.count(character)
        new_string = string.replace(character, replacement)
    else:
        count = string.lower().count(character.lower())
        new_string = string.lower().replace(character.lower(), replacement)

    # Check if the character to be replaced is not found in the string
    if count == 0:
        print("Error: Character '{}' not found in the string.".format(character))
        return

    # Display the number of replacements made
    print("Replacements made: {}".format(count))

    # Display the number of replacements made for each character separately
    if case_sensitive == "y":
        for c in character:
            count = string.count(c)
            print("Replacements made for '{}': {}".format(c, count))
    else:
        for c in character.lower():
            count = string.lower().count(c)
            print("Replacements made for '{}': {}".format(c, count))

    # Display the new string
    print("New string: {}".format(new_string))

replace_character()


import math

def convert_coordinates_to_longitude_latitude(X, Y):
    R = 6371  # radius of the Earth in kilometers

    longitude = X / (R * math.cos(Y))
    latitude = math.atan(math.exp(Y / R)) - (math.pi / 4)

    return round(longitude, 6), round(latitude, 6)


class MaxHeap:
    """
    A custom implementation of a max heap using a dynamic array.
    """
    def __init__(self):
        """
        Initialize the heap with an empty array.
        """
        self.heap = []

    def insert(self, value):
        """
        Insert a value into the heap.
        The time complexity of this operation is O(log n).
        """
        self.heap.append(value)  # Add the new value to the end of the array.
        self._bubble_up(len(self.heap) - 1)  # Restore the heap property.

    def deleteMax(self):
        """
        Remove and return the maximum value from the heap.
        The time complexity of this operation is O(log n).
        """
        if not self.heap:
            return None  # The heap is empty.
        max_value = self.heap[0]  # The maximum value is at the root of the heap.
        self.heap[0] = self.heap[-1]  # Move the last value to the root.
        self.heap.pop()  # Remove the last value (now duplicated at the root).
        self._bubble_down(0)  # Restore the heap property.
        return max_value

    def getMax(self):
        """
        Return the maximum value from the heap.
        The time complexity of this operation is O(1).
        """
        return self.heap[0] if self.heap else None  # The maximum value is at the root of the heap.

    def _bubble_up(self, index):
        """
        Restore the heap property by swapping the value at the given index up the heap.
        """
        parent_index = (index - 1) // 2  # The parent's index.
        if index > 0 and self.heap[index] > self.heap[parent_index]:  # The value is larger than its parent.
            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]  # Swap the value with its parent.
            self._bubble_up(parent_index)  # Continue up the heap.

    def _bubble_down(self, index):
        """
        Restore the heap property by swapping the value at the given index down the heap.
        """
        left_index = 2 * index + 1  # The left child's index.
        right_index = 2 * index + 2  # The right child's index.
        max_index = index  # Assume the value is larger than its children.
        if left_index < len(self.heap) and self.heap[left_index] > self.heap[max_index]:  # The left child is larger.
            max_index = left_index
        if right_index < len(self.heap) and self.heap[right_index] > self.heap[max_index]:  # The right child is larger.
            max_index = right_index
        if max_index != index:  # The value is smaller than one of its children.
            self.heap[index], self.heap[max_index] = self.heap[max_index], self.heap[index]  # Swap the value with the larger child.
            self._bubble_down(max_index)  # Continue down the heap.


import tensorflow as tf
from tensorflow.keras import layers

# Define the deep CNN model
def create_model():
    model = tf.keras.Sequential()

    # Add convolutional layers with batch normalization and residual connections
    model.add(layers.Conv2D(32, (3, 3), activation='relu', padding='same', input_shape=(256, 256, 3)))
    model.add(layers.BatchNormalization())
    model.add(layers.Conv2D(32, (3, 3), activation='relu', padding='same'))
    model.add(layers.BatchNormalization())
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))
    model.add(layers.Dropout(0.25))

    model.add(layers.Conv2D(64, (3, 3), activation='relu', padding='same'))
    model.add(layers.BatchNormalization())
    model.add(layers.Conv2D(64, (3, 3), activation='relu', padding='same'))
    model.add(layers.BatchNormalization())
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))
    model.add(layers.Dropout(0.25))

    model.add(layers.Conv2D(128, (3, 3), activation='relu', padding='same'))
    model.add(layers.BatchNormalization())
    model.add(layers.Conv2D(128, (3, 3), activation='relu', padding='same'))
    model.add(layers.BatchNormalization())
    model.add(layers.MaxPooling2D(pool_size=(2, 2)))
    model.add(layers.Dropout(0.25))

    # Flatten the feature maps and add fully connected layers
    model.add(layers.Flatten())
    model.add(layers.Dense(256, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dropout(0.5))
    model.add(layers.Dense(1, activation='linear'))  # Output layer for regression

    return model

# Create the model
model = create_model()

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Apply data augmentation techniques
data_augmentation = tf.keras.Sequential([
    layers.experimental.preprocessing.RandomFlip("horizontal"),
    layers.experimental.preprocessing.RandomRotation(0.1),
    layers.experimental.preprocessing.RandomZoom(0.1),
])

# Prepare the data
train_dataset = ...
test_dataset = ...

# Apply data augmentation and train the model
model.fit(data_augmentation(train_dataset), epochs=10, validation_data=test_dataset)


import re
import json

def html_table_to_json(html):
    # Remove unnecessary whitespaces and newlines
    html = re.sub(r'\s+', ' ', html.strip())

    # Find all table rows
    rows = re.findall(r'<tr>(.*?)</tr>', html, re.IGNORECASE | re.DOTALL)

    # Parse each row into a list of cells
    data = []
    for row in rows:
        cells = re.findall(r'<td.*?>(.*?)</td>', row, re.IGNORECASE | re.DOTALL)
        data.append([cell.upper() for cell in cells])

    # Recursively handle nested tables
    nested_tables = re.findall(r'<table.*?>(.*?)</table>', html, re.IGNORECASE | re.DOTALL)
    for nested_table in nested_tables:
        data.append(html_table_to_json(nested_table))

    # Convert data to JSON format
    return json.dumps(data)

# Example usage
html_table = '''
<table>
    <tr>
        <td>Apple</td>
        <td>Banana</td>
    </tr>
    <tr>
        <td>Grapes</td>
        <td>Orange</td>
    </tr>
    <tr>
        <td>
            <table>
                <tr>
                    <td>Strawberry</td>
                    <td>Pineapple</td>
                </tr>
            </table>
        </td>
        <td>Kiwi</td>
    </tr>
</table>
'''

json_data = html_table_to_json(html_table)
print(json_data)


def lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        prev_prev = 2
        prev = 1
        for i in range(2, n + 1):
            curr = prev_prev + prev
            prev_prev = prev
            prev = curr
        return curr

n = int(input("Enter the value of n: "))
print("The", n, "th element of the Lucas sequence is:", lucas(n))


def calculate_total_cost(item_price, tax_rate, surcharge, quantity):
    if item_price < 10:
        discount = 0
    elif 1 <= quantity <= 10:
        discount = 0.05
    elif 11 <= quantity <= 20:
        discount = 0.1
    else:
        discount = 0.15
    
    total_cost = (item_price + surcharge) * (1 + tax_rate) * (1 - discount)
    return total_cost


def addBoldTag(s: str, words: list) -> str:
    n = len(s)
    marked = [False] * n
    for word in words:
        pos = s.find(word)
        while pos != -1:
            for i in range(pos, pos + len(word)):
                marked[i] = True
            pos = s.find(word, pos + 1)
    result = []
    i = 0
    while i < n:
        if marked[i]:
            result.append("<b>")
            while i < n and marked[i]:
                result.append(s[i])
                i += 1
            result.append("</b>")
        else:
            result.append(s[i])
            i += 1
    return "".join(result)


import math

def calculate_triangle_area(a, b, c):
    # Check if the given lengths form a valid triangle
    if a + b <= c or a + c <= b or b + c <= a:
        raise ValueError("Invalid triangle")

    # Calculate the semi-perimeter
    s = (a + b + c) / 2

    # Calculate the area using Heron's formula
    area = math.sqrt(s * (s - a) * (s - b) * (s - c))

    return area

# Test the program
try:
    a = float(input("Enter the length of side a: "))
    b = float(input("Enter the length of side b: "))
    c = float(input("Enter the length of side c: "))

    area = calculate_triangle_area(a, b, c)
    print("The area of the triangle is:", area)
except ValueError as e:
    print(e)


hex_map = {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9', 10: 'A', 11: 'B', 12: 'C', 13: 'D', 14: 'E', 15: 'F'}

def convertToHex(num):
    hex_value = ''
    if num == 0:
        return hex_value
    remainder = num % 16
    hex_value = hex_map[remainder] + hex_value
    num = num // 16
    return convertToHex(num) + hex_value

num = 67
hex_value = convertToHex(num)
print(hex_value)


def remove_duplicates(nums):
    # Create an empty hash set
    unique_nums = set()
    
    # Index to keep track of the last non-duplicate element
    last_non_duplicate = 0
    
    # Iterate over the array
    for i in range(len(nums)):
        # Check if the current element is unique
        if nums[i] not in unique_nums:
            # Add the current element to the hash set
            unique_nums.add(nums[i])
            
            # Swap the current element with the last non-duplicate element
            nums[last_non_duplicate] = nums[i]
            
            # Update the index of the last non-duplicate element
            last_non_duplicate += 1
    
    # Remove the remaining elements after the last non-duplicate element
    del nums[last_non_duplicate:]
    
    # Return the updated length of the array
    return last_non_duplicate


import heapq

def maxSumAfterKOperations(nums, k):
    heapq.heapify(nums)
    for _ in range(k):
        current = heapq.heappop(nums)
        heapq.heappush(nums, -current)
    return sum(nums)


def largest_prime(array):
    left = 0
    right = len(array) - 1

    while left <= right:
        mid = (left + right) // 2
        if is_prime(array[mid]):
            return array[mid]
        elif array[mid] < 2 or not is_prime(array[mid]):
            right = mid - 1
        else:
            left = mid + 1

    return None

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True


import json
# JSON data for an apple
apple_data = '{"name": "apple", "calories": 52, "weight": 100}'
# JSON data for an orange
orange_data = '{"name": "orange", "calories": 47, "weight": 100}'
# Parse the JSON data
apple = json.loads(apple_data)
orange = json.loads(orange_data)
# Calculate the total number of calories in an apple or an orange
def calculate_calories(fruit, weight):
 return (fruit['calories'] / 100) * weight
# Example usage
apple_calories = calculate_calories(apple, 150)
orange_calories = calculate_calories(orange, 200)
print("Total number of calories in 150g of apple:", apple_calories)
print("Total number of calories in 200g of orange:", orange_calories)


import random

def generate_random_divisible(lower_bound, upper_bound):
    if lower_bound >= upper_bound:
        raise ValueError("Lower bound must be less than upper bound")
    
    while True:
        num = random.randint(lower_bound, upper_bound)
        
        if num % 3 == 0:
            return num
        
        if num > 1:
            for i in range(2, int(num ** 0.5) + 1):
                if num % i == 0:
                    break
            else:
                return num
        
        # Find the nearest prime number larger than num
        num += 1
        while True:
            for i in range(2, int(num ** 0.5) + 1):
                if num % i == 0:
                    break
            else:
                return num
            num += 1


def remove_value(data, value):
    if isinstance(data, list):
        result = []
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result.append(remove_value(item, value))
            elif isinstance(item, dict):
                result.append(remove_value(list(item.values()), value))
            elif item != value:
                result.append(item)
        return result
    elif isinstance(data, dict):
        result = {}
        for key, item in data.items():
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result[key] = remove_value(item, value)
            elif isinstance(item, dict):
                result[key] = remove_value(list(item.values()), value)
            elif item != value:
                result[key] = item
        return result
    elif isinstance(data, tuple):
        result = ()
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result += (remove_value(item, value),)
            elif isinstance(item, dict):
                result += (remove_value(list(item.values()), value),)
            elif item != value:
                result += (item,)
        return result
    elif isinstance(data, set):
        result = set()
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result.add(remove_value(item, value))
            elif isinstance(item, dict):
                result.add(remove_value(list(item.values()), value))
            elif item != value:
                result.add(item)
        return result
    else:
        return data

# Example usage
data = [1, 2, 3, [4, 5, [6, 7]], {'a': [1, 2, 3]}, (1, 2, 3), {1, 2, 3}]
value = 3

result = remove_value(data, value)
print(result)


def k_radius_average(nums, k):
    n = len(nums)
    avgs = [-1] * n
    for i in range(k, n - k):
        sum = 0
        for j in range(i - k, i + k + 1):
            sum += nums[j]
        avgs[i] = sum // (2 * k + 1)
    return avgs


def custom_sort(s1, s2):
    if len(s1) != len(s2):
        return len(s2) - len(s1)
    else:
        return -1 if s1 > s2 else 1

def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])
    
    i = j = 0
    while i < len(left_half) and j < len(right_half):
        if custom_sort(left_half[i], right_half[j]) < 0:
            arr[i + j] = left_half[i]
            i += 1
        else:
            arr[i + j] = right_half[j]
            j += 1
    
    while i < len(left_half):
        arr[i + j] = left_half[i]
        i += 1
    
    while j < len(right_half):
        arr[i + j] = right_half[j]
        j += 1
    
    return arr

# Test case
arr = ['hello', 'hi', 'howdy', 'apple', 'banana', 'carrot', 'dog', 'elephant', 'frog', 'goat', 'horse']
sorted_arr = merge_sort(arr)
print(sorted_arr)


def is_armstrong_number(n):
    num_str = str(n)
    num_digits = len(num_str)
    sum_cubes = 0
    for i in range(num_digits):
        digit = int(num_str[i])
        sum_cubes += digit**3
    if sum_cubes == n:
        return True
    else:
        return False


def create_dictionary(lst):
    dictionary = {}

    # Build the dictionary
    for key, value in lst:
        if key in dictionary:
            dictionary[key].append(value)
        else:
            dictionary[key] = [value]

    # Sort the dictionary based on the sum of the values
    dictionary = dict(sorted(dictionary.items(), key=lambda item: sum(item[1]), reverse=True))

    return dictionary


def count_shared_characters(str1, str2):
    # Convert both strings to lowercase for case-insensitive comparison
    str1 = str1.lower()
    str2 = str2.lower()
    
    # Create sets of unique characters from each string
    set1 = set(str1)
    set2 = set(str2)
    
    # Find the intersection of the two sets to get shared characters
    shared_characters = set1.intersection(set2)
    
    # Count the number of shared characters
    count = len(shared_characters)
    
    return count

# Example usage:
str1 = "Greatest!"
str2 = "Gifted" 
print(count_shared_characters(str1, str2))


arr = [[1,2], [3,4]]

# Flatten the 2D array using list comprehension
flattened_arr = [str(num) for sublist in arr for num in sublist]

# Print the flattened array in row-wise order using join()
print(" ".join(flattened_arr))


my_dict = {"name": {"first": "John", "last": "Doe"}, "age": 27}
key_to_check = "name.first"

# Write code to check if the key_to_check exists in my_dict or not
# and print "Key exists" if it does, and "Key does not exist" if it doesn't

keys = key_to_check.split(".")
current_dict = my_dict

for key in keys:
    if key in current_dict:
        current_dict = current_dict[key]
    else:
        print("Key does not exist")
        break
else:
    print("Key exists")


from queue import PriorityQueue

def assignTasks(servers, tasks):
    n, m = len(servers), len(tasks)
    ans = [0] * m
    freeServers = PriorityQueue()

    for i in range(n):
        freeServers.put((servers[i], i))

    busyServers = PriorityQueue()
    currentTask = 0

    while currentTask < m:
        while not busyServers.empty() and busyServers.queue[0][0] <= currentTask:
            _, idx = busyServers.get()
            freeServers.put((servers[idx], idx))

        while not freeServers.empty() and currentTask < m:
            _, idx = freeServers.get()
            ans[currentTask] = idx
            busyServers.put((currentTask + tasks[currentTask], idx))
            currentTask += 1
            
        if freeServers.empty():
            currentTask = busyServers.queue[0][0]
    
    return ans


def my_function(x):
    while x > 1000 and x % 3 == 0:
        x += 1
    return x


from itertools import permutations

def find_anagrams(str):
    # Check if the length of the string is between 2 and 10 characters
    if len(str) < 2 or len(str) > 10:
        return []
    
    # Generate all permutations of the string
    perms = [''.join(p) for p in permutations(str)]
    
    # Filter the permutations to find the anagrams
    anagrams = [perm for perm in perms if perm != str and sorted(perm) == sorted(str)]
    
    # Sort the anagrams in alphabetical order
    anagrams.sort()
    
    return anagrams

str = "abc"
anagrams = find_anagrams(str)
print(anagrams)


# Create sets
A = {1, 2, 3, 4, 5}
B = {4, 5, 6, 7, 8}

# Union
union_set = A.union(B)
print(union_set)  # Output: {1, 2, 3, 4, 5, 6, 7, 8}

# Intersection
intersection_set = A.intersection(B)
print(intersection_set)  # Output: {4, 5}

# Difference
difference_set = A.difference(B)
print(difference_set)  # Output: {1, 2, 3}



def longest_palindrome(words):
    longest = ""
    for word in words:
        if word == word[::-1] and len(word) > len(longest):
            longest = word
    return longest


import numpy as np

array = [
    {'name': 'John', 'region': 'West', 'score': 6},
    {'name': 'Jane', 'region': 'West', 'score': 10},
    {'name': 'Bob', 'region': 'East', 'score': 5},
    {'name': 'Alice', 'region': 'East', 'score': 20},
    {'name': 'Charlie', 'region': 'North', 'score': 8},
    {'name': 'David', 'region': 'North', 'score': 9},
    {'name': 'Eve', 'region': 'South', 'score': 7},
    {'name': 'Frank', 'region': 'South', 'score': 12},
    {'name': 'Grace', 'region': 'South', 'score': 6},
    {'name': 'Hank', 'region': 'East', 'score': 9},
    {'name': 'Ivy', 'region': 'West', 'score': 8},
    {'name': 'Jack', 'region': 'North', 'score': 10},
    {'name': 'Kim', 'region': 'South', 'score': 11},
    {'name': 'Luke', 'region': 'West', 'score': 7},
    {'name': 'Mary', 'region': 'North', 'score': 15},
    {'name': 'Nathan', 'region': 'East', 'score': 13},
    {'name': 'Olivia', 'region': 'South', 'score': 9},
    {'name': 'Paul', 'region': 'West', 'score': 7},
    {'name': 'Quincy', 'region': 'North', 'score': 6},
    {'name': 'Rachel', 'region': 'East', 'score': 8},
    {'name': 'Sam', 'region': 'South', 'score': 10},
    {'name': 'Tina', 'region': 'West', 'score': 11},
    {'name': 'Ursula', 'region': 'North', 'score': 9},
    {'name': 'Victor', 'region': 'East', 'score': 7},
    {'name': 'Wendy', 'region': 'South', 'score': 12},
    {'name': 'Xavier', 'region': 'West', 'score': 6},
    {'name': 'Yolanda', 'region': 'North', 'score': 8},
    {'name': 'Zack', 'region': 'East', 'score': 10}
]

# Group the array by 'region' key
grouped = {}
for item in array:
    region = item['region']
    score = item['score']
    if region not in grouped:
        grouped[region] = []
    grouped[region].append(score)

# Calculate the mean for each group and exclude scores below 8
means = {}
for region, scores in grouped.items():
    scores_above_8 = [score for score in scores if score >= 8]
    mean = np.mean(scores_above_8)
    means[region] = mean

# Sort the regions by mean score in descending order
sorted_regions = sorted(means.items(), key=lambda x: x[1], reverse=True)

# Get the top 10 regions with the highest mean score
top_10_regions = sorted_regions[:10]

print(top_10_regions)


import re

def longest_word_length(string):
    # Remove whitespace and special characters
    modified_string = re.sub(r'[^a-zA-Z]', '', string)

    # Convert modified string to a list of characters
    chars = list(modified_string)

    # Sort the list of characters
    chars.sort()

    current_length = 0
    max_length = 0

    for i in range(len(chars)):
        if i > 0 and chars[i] == chars[i-1]:
            current_length += 1
        else:
            max_length = max(max_length, current_length)
            current_length = 1

    max_length = max(max_length, current_length)

    return max_length


# Step 1: Take input string from the user
input_string = input("Enter a string: ")

# Step 2: Initialize an empty string called "result"
result = ""

# Step 3: Initialize a variable called "exclamation_count"
exclamation_count = 0

# Step 6: Repeat steps 4 and 5 for a total of 7 times
for i in range(7):
    # Step 4: Iterate through each character in the input string
    for char in input_string:
        # Step 4a: Append the current character to the "result" string
        result += char
        
        # Step 4b: Increment the "exclamation_count" variable by 1
        exclamation_count += 1
        
        # Step 4c: Use nested for loop to append exclamation marks
        for j in range(exclamation_count):
            result += "!"

    # Step 5: Append a newline character "\n" to the "result" string
    result += "\n"

# Step 7: Print the "result" string
print(result)


import random

python_list = [random.randint(1, 100) for _ in range(10)]
print(python_list)


function countComponents(head: ListNode, nums: List[int]) -> int:
    hashMap = MyHashMap()
    for num in nums:
        hashMap.put(num, True)
    count = 0
    curr = head
    while curr is not None:
        if hashMap.get(curr.val) and (curr.next is None or not hashMap.get(curr.next.val)):
            count += 1
        curr = curr.next
    return count


list_nums = [1, -4, 7, 2, -9]

max_num = float('-inf')  # Initialize the maximum number to negative infinity

for num in list_nums:
    if num > max_num and num >= 0:  # Check if the number is greater than the current maximum and not negative
        max_num = num

print(max_num)


import random

def generate_password():
    length = random.randint(16, 30)
    password = [''] * length

    # Set the first character to an uppercase letter
    password[0] = random.choice(string.ascii_uppercase)

    # Set the last character to a special character
    password[-1] = random.choice('!@#$%^&*')

    # Set the remaining characters
    remaining = length - 2

    # Ensure at least five uppercase letters
    uppercase_count = 5
    while uppercase_count > 0 and remaining > 0:
        index = random.randint(1, length - 2)
        if password[index] == '':
            password[index] = random.choice(string.ascii_uppercase)
            uppercase_count -= 1
            remaining -= 1

    # Ensure at least five lowercase letters
    lowercase_count = 5
    while lowercase_count > 0 and remaining > 0:
        index = random.randint(1, length - 2)
        if password[index] == '':
            password[index] = random.choice(string.ascii_lowercase)
            lowercase_count -= 1
            remaining -= 1

    # Ensure at least five numbers
    number_count = 5
    while number_count > 0 and remaining > 0:
        index = random.randint(1, length - 2)
        if password[index] == '':
            password[index] = random.choice(string.digits)
            number_count -= 1
            remaining -= 1

    # Ensure at least four special characters
    special_count = 4
    while special_count > 0 and remaining > 0:
        index = random.randint(1, length - 2)
        if password[index] == '':
            password[index] = random.choice('!@#$%^&*')
            special_count -= 1
            remaining -= 1

    # Fill the remaining empty characters with random choices
    for i in range(1, length - 1):
        if password[i] == '':
            password[i] = random.choice(string.ascii_letters + string.digits + '!@#$%^&*')

    # Shuffle the password to distribute the characters evenly
    random.shuffle(password)

    return ''.join(password)


def count_occurrences(string, char):
    count = 0
    for c in string:
        if c == char:
            count += 1
    return count

# Example usage
string = "Hello World!"
char = 'l'
print(count_occurrences(string, char))  # Output: 3


def power(base, exponent):
    result = 1
    for _ in range(exponent):
        result *= base
    return result


def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def is_palindrome(num):
    return str(num) == str(num)[::-1]

count = 0
i = 2
primes = []

while count < 100:
    if is_prime(i) and not is_palindrome(i):
        primes.append(i)
        count += 1
    i += 1

for prime in reversed(primes):
    print(prime)


import re

def get_words_without_vowels(sentence):
    # Define a regular expression pattern to match words
    pattern = r'\b[^\W\d_]+\b'
    
    # Find all words in the sentence that match the pattern
    words = re.findall(pattern, sentence)
    
    # Exclude words that contain a vowel
    words_without_vowels = [word for word in words if not re.search(r'[aeiou]', word, re.IGNORECASE)]
    
    return words_without_vowels

# Example usage
sentence = "This is an example sentence with some words."
result = get_words_without_vowels(sentence)
print(result)


def sum_of_even_numbers(n):
    total = 0
    for num in range(2, n+1, 2):
        total += num
    return total

# Test the function
number = int(input("Enter a number: "))
result = sum_of_even_numbers(number)
print("The sum of even numbers from 1 to", number, "is:", result)


import collections
import string
def is_anagram(str1, str2):
    # Remove whitespace and convert to lowercase
    str1 = str1.translate(str.maketrans("", "", string.whitespace)).lower()
    str2 = str2.translate(str.maketrans("", "", string.whitespace)).lower()
    # Count the frequency of each character in each string
    freq1 = collections.Counter(str1)
    freq2 = collections.Counter(str2)
    # Compare the dictionaries to determine if they are anagrams
    if freq1 == freq2:
        return True
    else:
        return False


def integerToRoman(num):
    decimalValues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    romanSymbols = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]

    romanNumeral = ""
    for i in range(len(decimalValues)):
        while num >= decimalValues[i]:
            romanNumeral += romanSymbols[i]
            num -= decimalValues[i]

    return romanNumeral


def permutations(string):
    if len(string) > 20:
        return "Error: Input string is too long."

    # Set to store unique permutations
    unique_perms = set()

    # Backtracking function to generate permutations
    def backtrack(string, perm):
        if len(perm) == len(string):
            unique_perms.add("".join(perm))
        else:
            for i in range(len(string)):
                if string[i] not in perm:
                    perm.append(string[i])
                    backtrack(string, perm)
                    perm.pop()

    # Start backtracking
    backtrack(string, [])

    return list(unique_perms)


import xml.etree.ElementTree as ET
def find_equal_value_pair(strings):
    ascii_sum = {}
    for string in strings:
        sum = 0
        for char in string:
            sum += ord(char)
        if sum in ascii_sum:
            return (ascii_sum[sum], string)
        ascii_sum[sum] = string
    return None
# Example usage
xml_string = "<strings><string>abc123</string><string>123abc</string><string>456def</string></strings>"
root = ET.fromstring(xml_string)
strings = [string.text for string in root.findall('string')]
print(find_equal_value_pair(strings))


def sieve_of_eratosthenes(limit):
    primes = [True] * (limit + 1)
    primes[0] = primes[1] = False

    for i in range(2, int(limit ** 0.5) + 1):
        if primes[i]:
            for j in range(i * i, limit + 1, i):
                primes[j] = False

    return [i for i in range(limit + 1) if primes[i]]

def print_and_sum_primes(n):
    primes = sieve_of_eratosthenes(n * n)
    count = 0
    total_sum = 0

    for prime in primes:
        if count == 1000:
            break

        if prime > 1:
            print(prime)
            total_sum += prime
            count += 1

    print("Sum:", total_sum)

print_and_sum_primes(1000)


from collections import deque

class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

def levelOrder(root):
    result = []

    if not root:
        return result

    toVisit = deque([root])

    while toVisit:
        size = len(toVisit)
        level = []

        for _ in range(size):
            currentNode = toVisit.popleft()
            level.append(currentNode.val)

            for child in currentNode.children:
                toVisit.append(child)

        result.append(level)

    return result


class ClassName:
    def __init__(self, parameter1, parameter2):
        self.parameter1 = parameter1
        self.parameter2 = parameter2
    
    def class_method(self, other_parameter):
        # code goes here
        pass


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_square_of_primes(n):
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    
    squares = [prime ** 2 for prime in primes]
    sum_of_squares = sum(squares)
    
    return sum_of_squares, squares

# Test the function
n = int(input("Enter a positive integer n: "))
sum_of_squares, squares = find_square_of_primes(n)
print("List of squares:", squares)
print("Sum of squares:", sum_of_squares)


import random

def create_nim_board(n, k):
    board = []
    for _ in range(n):
        stones = random.randint(1, k)
        board.append(stones)
    return board


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def odd_prime_numbers(lst):
    return list(filter(lambda x: is_prime(x) and x % 2 != 0, lst))


def append_and_remove_duplicates(str1, str2):
    # Append the characters of str2 to str1
    result = str1 + str2

    # Remove duplicate characters using a set
    result = ''.join(set(result))

    return result


def bubble_sort_descending(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

arr = [5, 4, 3, 2, 1]
sorted_arr = bubble_sort_descending(arr)
print(sorted_arr)


def calculate_sum(dictionary):
    total_sum = 0
    for value in dictionary.values():
        if isinstance(value, int):
            total_sum += value
        elif isinstance(value, dict):
            total_sum += calculate_sum(value)
        elif isinstance(value, list):
            for item in value:
                if isinstance(item, int):
                    total_sum += item
    return total_sum


def fibonacci_generator(n):
    a, b = 0, 1
    while a < 2*n:
        if a % 3 == 0 and any(digit in [2, 3, 5, 7] for digit in map(int, str(a))):
            yield a
        a, b = b, a + b


def calculate_sum(array):
    if len(array) == 0:  # Handle empty array
        return 0
    elif len(array) == 1:  # Handle array with single element
        return array[0]
    else:
        if array[0] < 0:  # Initialize the first element of the array with the cumulative sum
            array[0] = 0
        for i in range(1, len(array)):
            if array[i] < 0:
                array[i] = array[i-1]  # If the current element is negative, set it equal to the previous cumulative sum
            array[i] += array[i-1]  # Add the current element to the previous cumulative sum
        return array[-1]  # Return the final cumulative sum

# Example usage:
arr = [1, 2, 3, 4, 5]
print(calculate_sum(arr))  # Output: 15

arr = [-1, -2, -3, -4, -5]
print(calculate_sum(arr))  # Output: -1

arr = [5, -2, 3, -4, 5]
print(calculate_sum(arr))  # Output: 7

arr = []
print(calculate_sum(arr))  # Output: 0


import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True


from bs4 import BeautifulSoup

def parse_html_to_json(html):
    soup = BeautifulSoup(html, 'html.parser')
    return parse_element(soup)

def parse_element(element):
    if element.name is None:
        return element.string.strip()

    result = {'tag': element.name}
    if element.attrs:
        result['attributes'] = element.attrs

    if element.contents:
        result['children'] = []
        for child in element.contents:
            if str(child).strip() == '':
                continue
            parsed_child = parse_element(child)
            result['children'].append(parsed_child)

    return result

# Example usage:
html_code = '''
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <div id="container">
      <h1 class="header">Hello World</h1>
      <p>This is an example</p>
      <ul>
        <li>Item 1</li>
        <li>Item 2</li>
      </ul>
    </div>
  </body>
</html>
'''

json_structure = parse_html_to_json(html_code)
print(json_structure)


def is_anagram(str1, str2):
    # Remove leading and trailing whitespace
    str1 = str1.strip()
    str2 = str2.strip()
    
    # Convert the strings to lowercase
    str1 = str1.lower()
    str2 = str2.lower()
    
    # Check if the lengths are different
    if len(str1) != len(str2):
        return False
    
    # Count the occurrences of each character in both strings
    count = {}
    for char in str1:
        count[char] = count.get(char, 0) + 1
    for char in str2:
        count[char] = count.get(char, 0) - 1
    
    # If any count is not zero, the strings are not anagrams
    for char in count:
        if count[char] != 0:
            return False
    
    # If all counts are zero, the strings are anagrams
    return True


def string_to_integer(s):
    # Remove leading and trailing whitespaces
    s = s.strip()

    # Check if the string is empty
    if len(s) == 0:
        return 0

    # Check if the first character is a valid sign
    if s[0] == '+' or s[0] == '-':
        sign = -1 if s[0] == '-' else 1
        s = s[1:]
    else:
        sign = 1

    # Convert the string to an integer
    result = 0
    for char in s:
        # Check if the character is a digit
        if char.isdigit():
            result = result * 10 + int(char)
        else:
            return 0

    # Apply the sign to the result
    result *= sign

    # Check if the result is within the valid range
    if result < -2**31 or result > 2**31 - 1:
        return 0

    return result


def delete_item(dictionary, key):
    for k, v in dictionary.items():
        if k == key:
            del dictionary[k]
            return
        elif isinstance(v, dict):
            delete_item(v, key)


import random
import string
uppercase_letter = random.choice(string.ascii_uppercase)
digits = ''.join(random.choices(string.digits, k=3))
lowercase_letters = ''.join(random.choices(string.ascii_lowercase, k=4))
special_characters = ''.join(random.choices(['@', '#'], k=2))
random_sequence = uppercase_letter + digits + lowercase_letters + special_characters
print(random_sequence)


def multiply(b, c):
    # Check if either b or c is 0
    if b == 0 or c == 0:
        return 0

    # Determine the sign of the result
    sign = 1
    if b < 0:
        sign = -sign
        b = -b
    if c < 0:
        sign = -sign
        c = -c

    result = 0
    while c > 0:
        # If the least significant bit of c is 1, add b to the result
        if c & 1:
            result += b

        # Multiply b by 2 and divide c by 2 (bitwise operations)
        b = b << 1
        c = c >> 1

    return sign * result

b = 5
c = 7
print(multiply(b, c))  # Output: 35

b = -3
c = 4
print(multiply(b, c))  # Output: -12

b = 9
c = 0
print(multiply(b, c))  # Output: 0


def is_brackets_matched(string):
    stack = []
    opening_brackets = ['(', '[', '{']
    closing_brackets = [')', ']', '}']
    bracket_pairs = {')': '(', ']': '[', '}': '{'}

    for char in string:
        if char in opening_brackets:
            stack.append(char)
        elif char in closing_brackets:
            if len(stack) == 0 or stack[-1] != bracket_pairs[char]:
                return False
            stack.pop()

    return len(stack) == 0


import math

def scale_vector(input_vector):
    scaling_factor = 101
    step_size = 100 / (len(input_vector) - 1)
    output_vector = []

    for i in range(len(input_vector)):
        scaled_value = round(input_vector[i] * scaling_factor)
        output_vector.append(scaled_value)

    return output_vector

input_vector = [i for i in range(20)]
output_vector = scale_vector(input_vector)
print(output_vector)


def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr


def remove_second_to_last(lst):
    if len(lst) >= 2:
        lst.pop(-2)
    return lst

# Example usage
lst = [1, 2, 3, 4, 5]
modified_lst = remove_second_to_last(lst)
print(modified_lst)


import math

def sieve_of_eratosthenes(n):
    primes = [True] * (n+1)
    primes[0] = primes[1] = False

    for i in range(2, int(math.sqrt(n))+1):
        if primes[i]:
            for j in range(i*i, n+1, i):
                primes[j] = False

    return [num for num, is_prime in enumerate(primes) if is_prime]


# Example usage
prime_numbers = sieve_of_eratosthenes(10000000)


def filter_even(numbers):
    even_numbers = []
    for num in numbers:
        if num % 2 == 0:
            even_numbers.append(num)
    return even_numbers

# Higher-order function example
def apply_function(numbers, function):
    result = []
    for num in numbers:
        result.append(function(num))
    return result

# New Test
def multiply_by_two(numbers):
    multiplied_numbers = []
    for num in numbers:
        multiplied_numbers.append(num * 2)
    return multiplied_numbers

# Test the new function
input_numbers = [1, 2, 3, 4]
output_numbers = multiply_by_two(input_numbers)
print(output_numbers)


import json

def clean_json(json_data):
    if isinstance(json_data, dict):
        cleaned_data = {}
        for key, value in json_data.items():
            cleaned_data[key] = clean_json(value)
        return cleaned_data
    elif isinstance(json_data, list):
        cleaned_data = []
        for item in json_data:
            cleaned_data.append(clean_json(item))
        return cleaned_data
    elif isinstance(json_data, int):
        return str(json_data)
    elif json_data is None:
        return None
    elif isinstance(json_data, str):
        return json_data
    else:
        return None  # Handle unrecognized data types

# Sample JSON data
data = '''
{
  "name": "John Doe",
  "age": 30,
  "hobbies": [
    "reading",
    null,
    {
      "name": "gardening",
      "participants": [
        {
          "firstname": "Alice",
          "lastname": "Smith"
        },
        {
          "firstname": null,
          "lastname": "Johnson"
        }
      ]
    }
  ]
}
'''

# Parse the JSON data
parsed_data = json.loads(data)

# Clean up the JSON data
cleaned_data = clean_json(parsed_data)

# Convert back to JSON string
cleaned_data_str = json.dumps(cleaned_data)

print(cleaned_data_str)


new_list = [expression for item in iterable if condition]


number = input("Input: ")

# Format the number with comma-separated thousands
formatted_number = "{:,}".format(int(number))

# Reverse the formatted number
reversed_number = formatted_number[::-1]

# Remove all digits that are divisible by 3
filtered_number = ''.join(char for char in reversed_number if int(char) % 3 != 0)

print("Output:", filtered_number)


def divide_list(lst):
    length = len(lst)
    mid = length // 2
    
    first_half = lst[:mid]
    second_half = lst[mid:]
    
    return first_half, second_half


input_list = [1, 2, 3, 4, 5, 6, 7, 8]
output = divide_list(input_list)

print(output[0])
print(output[1])


def replace_consonants(string):
    vowels = 'aeiouAEIOU'
    result = ''
    for char in string:
        if char.isalpha() and char not in vowels:
            if char == 'z':
                result += 'a'
            elif char == 'Z':
                result += 'A'
            else:
                result += chr(ord(char) + 1)
        else:
            result += char
    return result

# Example usage
input_str = 'Hello World'
output_str = replace_consonants(input_str)
print(output_str)


def spiral_traverse(matrix):
    # Initialize variables
    result = []
    top_row, bottom_row = 0, len(matrix) - 1
    left_col, right_col = 0, len(matrix[0]) - 1

    while top_row <= bottom_row and left_col <= right_col:
        # Traverse top row
        for col in range(left_col, right_col + 1):
            result.append(matrix[top_row][col])
        top_row += 1

        # Traverse right column
        for row in range(top_row, bottom_row + 1):
            result.append(matrix[row][right_col])
        right_col -= 1

        # Check if there are remaining rows and columns
        if top_row <= bottom_row:
            # Traverse bottom row
            for col in range(right_col, left_col - 1, -1):
                result.append(matrix[bottom_row][col])
            bottom_row -= 1

        if left_col <= right_col:
            # Traverse left column
            for row in range(bottom_row, top_row - 1, -1):
                result.append(matrix[row][left_col])
            left_col += 1

    return result


def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left_half = arr[:mid]
    right_half = arr[mid:]
    
    left_half = merge_sort(left_half)
    right_half = merge_sort(right_half)
    
    return merge(left_half, right_half)

def merge(left_half, right_half):
    result = []
    left_index = 0
    right_index = 0
    
    while left_index < len(left_half) and right_index < len(right_half):
        if left_half[left_index] < right_half[right_index]:
            result.append(left_half[left_index])
            left_index += 1
        else:
            result.append(right_half[right_index])
            right_index += 1
    
    result.extend(left_half[left_index:])
    result.extend(right_half[right_index:])
    
    return result

def categorize_and_sort(arr):
    odd_list = []
    even_list = []
    
    for num in arr:
        if num % 2 == 0:
            even_list.append(num)
        else:
            odd_list.append(num)
    
    odd_list = merge_sort(odd_list)
    even_list = merge_sort(even_list)
    
    return odd_list, even_list

# Test
arr = [9, 8, 7, 6, 5, 4, 3, 2, 1]
odd_list, even_list = categorize_and_sort(arr)

print("Odd Numbers (sorted):", odd_list)
print("Even Numbers (sorted):", even_list)


def convert_base(number, base, target_base):
    """
    This function converts a given number from a specified base to a target base.
    It first converts the number to base 10, then to the target base.
    The time complexity is O(logN), where N is the given number.
    """
    # Define a string of all possible digits in bases up to 36
    digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

    # Convert the number to base 10
    number_in_base_10 = 0
    for digit in str(number):
        number_in_base_10 = number_in_base_10 * base + digits.index(digit)

    # Convert the number from base 10 to the target base
    number_in_target_base = ""
    while number_in_base_10 > 0:
        number_in_target_base = digits[number_in_base_10 % target_base] + number_in_target_base
        number_in_base_10 //= target_base

    return number_in_target_base


def search_element(arr, target):
    start = 0
    end = len(arr) - 1
    indices = []
    
    while start <= end:
        middle = start + (end - start) // 2
        
        if arr[middle] == target:
            indices.append(middle)
            # Check for other occurrences to the left of middle
            i = middle - 1
            while i >= start and arr[i] == target:
                indices.append(i)
                i -= 1
            # Check for other occurrences to the right of middle
            i = middle + 1
            while i <= end and arr[i] == target:
                indices.append(i)
                i += 1
            return indices
        
        elif target < arr[middle]:
            end = middle - 1
        else:
            start = middle + 1
    
    return indices

# Test the algorithm
arr = [1, 9, 5, 8, 4, 9]
target = 9
indices = search_element(arr, target)
print(indices)  # Output: [1, 5]


decimal = 375
binary = bin(decimal)[2:]
print(binary)  # Output: 101110111


def bubble_sort_descending(arr):
    n = len(arr)
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # Traverse the array from 0 to n-i-1
            # Swap if the current element is less than the next element
            if arr[j] < arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Example usage
my_list = [3.2, 1.5, 2.7, 5.4, 4.8]
bubble_sort_descending(my_list)
print(my_list)


def retrieve_elements(arr):
    count_dict = {}
    for elem in arr:
        if elem not in count_dict:
            count_dict[elem] = 1
        else:
            count_dict[elem] += 1
    
    result = []
    for elem in arr:
        if count_dict[elem] == 1:
            result.append(elem)
    
    return result


def remove_pattern(string, pattern):
    new_string = ""
    pattern_length = len(pattern)
    i = 0
    
    while i < len(string):
        if string[i:i+pattern_length] == pattern:
            i += pattern_length
        else:
            new_string += string[i]
            i += 1
    
    return new_string


import re

def count_words(string):
    # Remove leading and trailing spaces
    string = string.strip()

    # Find all words that match the regex pattern
    matches = re.findall(r'(?<!\S)\^[\w]{3,}[\w[aeiou]]\b(?!\S)', string)

    # Initialize counters
    total_occurrences = 0
    unique_words_with_digit = set()

    # Count occurrences and check for words with digits
    counts = {}
    for word in matches:
        counts[word] = counts.get(word, 0) + 1
        total_occurrences += 1
        if any(char.isdigit() for char in word):
            unique_words_with_digit.add(word)

    # Print results
    for word, count in counts.items():
        print(f"{word} - {count} occurrence(s)")

    print("\nTotal unique words with a digit:", len(unique_words_with_digit))

# Example usage
string = "This is a ^test string with ^multiple ^words and ^characters of different lengths. Some words like ^hi2 and ^bye3 should also be counted."
count_words(string)


def caesar_cipher(text, key):
    encrypted_text = ""
    
    for char in text:
        if char.isupper():
            position = ord(char) - ord('A')
            new_position = (position + key) % 26
            new_char = chr(new_position + ord('A'))
            encrypted_text += new_char
        elif char.islower():
            position = ord(char) - ord('a')
            new_position = (position + key) % 26
            new_char = chr(new_position + ord('a'))
            encrypted_text += new_char
        else:
            encrypted_text += char
    
    return encrypted_text

# Example usage:
text = "HELLO WORLD"
key = 3
encrypted_text = caesar_cipher(text, key)
print(encrypted_text)  # Output: "KHOOR ZRUOG"


def new21Game(n: int, k: int, maxPts: int) -> float:
    if k == 0 or n >= k + maxPts:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = 1
    s, ans = 1, 0

    for i in range(1, n + 1):
        dp[i] = s / maxPts
        if i < k:
            s += dp[i]
        else:
            ans += dp[i]
        if i >= maxPts:
            s -= dp[i - maxPts]

    return ans


def reverse_string(string):
    length = len(string)
    start = 0
    end = length - 1
    
    while start < end:
        # Reverse the characters within the current group of 3
        for i in range(3):
            string[start + i], string[end - i] = string[end - i], string[start + i]
        
        # Move to the next group of 3 characters
        start += 3
        end -= 3
    
    return string


def delete_item(dictionary, key):
    if key in dictionary:
        del dictionary[key]
    for value in dictionary.values():
        if isinstance(value, dict):
            delete_item(value, key)

# Example usage:
data = {
    'a': {
        'b': {
            'c': 'value1',
            'd': 'value2'
        },
        'e': {
            'f': 'value3',
            'g': 'value4'
        }
    },
    'h': {
        'i': {
            'c': 'value5',
            'd': 'value6'
        },
        'j': {
            'f': 'value7',
            'g': 'value8'
        }
    }
}

print("Before deletion:", data)
delete_item(data, 'c')
print("After deletion:", data)


def generate_fibonacci(n):
    # Handle invalid inputs
    if not isinstance(n, int) or n < 1:
        return "Invalid input. Please enter a positive integer."
    
    # Base cases
    if n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    
    # Generate Fibonacci sequence
    fib_sequence = [0, 1]
    for i in range(2, n):
        fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2])
    
    return fib_sequence


import requests

def get_top_restaurants(address, price_range, cuisine_type):
    # Check if address, price range, and cuisine type are provided
    if not address:
        print("Error: Address is required.")
        return
    if not price_range:
        print("Error: Price range is required.")
        return
    if not cuisine_type:
        print("Error: Cuisine type is required.")
        return

    # API parameters
    api_key = "YOUR_YELP_API_KEY"
    url = "https://api.yelp.com/v3/businesses/search"
    headers = {
        "Authorization": f"Bearer {api_key}"
    }
    params = {
        "location": address,
        "categories": cuisine_type,
        "price": price_range,
        "limit": 10
    }

    try:
        # Make API request
        response = requests.get(url, headers=headers, params=params)
        data = response.json()

        # Check if the API request was successful
        if response.status_code != 200 or "businesses" not in data:
            print("Error: Failed to retrieve restaurant data from Yelp API.")
            return

        # Display restaurant information
        for restaurant in data["businesses"]:
            print("Name:", restaurant["name"])
            print("Rating:", restaurant["rating"])
            print("Review Count:", restaurant["review_count"])
            print("Phone:", restaurant["phone"])
            print("--------------------")

    except requests.exceptions.RequestException as e:
        print("Error: Failed to make the API request.")
        print(e)
        return

    except Exception as e:
        print("Error: An unexpected error occurred.")
        print(e)
        return

# Example usage
get_top_restaurants("1234 Main Street, San Francisco, CA", "$$$", "Italian")


def get_words_starting_with_vowel(sentence):
    vowels = ['a', 'e', 'i', 'o', 'u']
    words = sentence.split()
    
    # Iterate through each word in the sentence
    for word in words:
        # Check if the first character of the word is a vowel
        if word[0].lower() in vowels:
            print(word)
    
# Get the sentence from the user
sentence = input("Enter a sentence: ")

# Call the function to print the words starting with a vowel
get_words_starting_with_vowel(sentence)


def find_max_indices(arr):
    """
    This function takes an array of integers as input and returns the indices of all occurrences 
    of the maximum number in the array in ascending order. If the maximum number does not appear 
    in the array, it returns an empty list.

    The function first checks if the array is empty. If it is, it returns an empty list. 
    Then it initializes the max_num variable with the first element of the array and the max_indices 
    list with the index of the first element (0). It then iterates over the rest of the array. 
    If it finds a number greater than max_num, it updates max_num and clears max_indices. 
    If it finds a number equal to max_num, it appends the index of that number to max_indices. 
    Finally, it returns max_indices.

    The time complexity of this function is O(n), where n is the size of the input array, 
    because it makes a single pass over the array.
    """
    if not arr:  # if the array is empty, return an empty list
        return []

    max_num = arr[0]  # initialize max_num with the first element of the array
    max_indices = [0]  # initialize max_indices with the index of the first element

    for i in range(1, len(arr)):  # iterate over the rest of the array
        if arr[i] > max_num:  # if the current number is greater than max_num
            max_num = arr[i]  # update max_num
            max_indices = [i]  # clear max_indices and add the index of the current number
        elif arr[i] == max_num:  # if the current number is equal to max_num
            max_indices.append(i)  # append the index of the current number to max_indices

    return max_indices


import math
import random
import statistics
# Generate a list of 1000 random values between 0 and 100
values = [random.uniform(0, 100) for _ in range(1000)]
# Calculate the square root of 2
sqrt2 = math.sqrt(2)
# Sort the values by their distance from the square root of 2
sorted_values = sorted(values, key=lambda x: abs(x - sqrt2))
# Select the 10 values closest to the square root of 2
closest_values = sorted_values[:10]
# Calculate the mean, median, and standard deviation of the closest values
mean = statistics.mean(closest_values)
median = statistics.median(closest_values)
stdev = statistics.stdev(closest_values)
# Calculate the sum of the closest values and round it to the nearest integer
sum_closest_values = round(sum(closest_values))
# Generate a new random number between 0 and the sum of the closest values
new_number = random.randint(0, sum_closest_values)
# Print the results
print(f"Closest values to the square root of 2: {closest_values}")
print(f"Mean: {mean}")
print(f"Median: {median}")
print(f"Standard deviation: {stdev}")
print(f"Sum of closest values: {sum_closest_values}")
print(f"New random number: {new_number}")


class MinHeap:
    def __init__(self):
        self.heap = []
        self.index_dict = {}
        
    def parent(self, i):
        return (i-1) // 2
    
    def left_child(self, i):
        return 2*i + 1
    
    def right_child(self, i):
        return 2*i + 2
    
    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]
        self.index_dict[self.heap[i]] = i
        self.index_dict[self.heap[j]] = j
        
    def heapify_up(self, i):
        while i > 0 and self.heap[i] < self.heap[self.parent(i)]:
            parent = self.parent(i)
            self.swap(i, parent)
            i = parent
    
    def heapify_down(self, i):
        smallest = i
        left = self.left_child(i)
        right = self.right_child(i)
        
        if left < len(self.heap) and self.heap[left] < self.heap[smallest]:
            smallest = left
        if right < len(self.heap) and self.heap[right] < self.heap[smallest]:
            smallest = right
        
        if smallest != i:
            self.swap(i, smallest)
            self.heapify_down(smallest)
            
    def insert(self, element):
        self.heap.append(element)
        self.index_dict[element] = len(self.heap) - 1
        self.heapify_up(len(self.heap) - 1)
        
    def delete(self, element):
        if element not in self.index_dict:
            return
        
        index = self.index_dict[element]
        self.swap(index, len(self.heap) - 1)
        del self.index_dict[element]
        self.heap.pop()
        
        if index < len(self.heap):
            self.heapify_up(index)
            self.heapify_down(index)
        
    def peek(self):
        return self.heap[0] if self.heap else None
    
    def heapify(self, arr):
        self.heap = arr
        self.index_dict = {element: index for index, element in enumerate(arr)}
        
        for i in range(len(self.heap) // 2, -1, -1):
            self.heapify_down(i)


def multiply_matrices(A, B):
    num_columns_A = len(A[0])
    num_rows_B = len(B)
    
    if num_columns_A != num_rows_B:
        raise ValueError("Matrix A and matrix B cannot be multiplied. The number of columns in A must be equal to the number of rows in B.")
    
    result = []
    for i in range(len(A)):
        row = []
        for j in range(len(B[0])):
            element = 0
            for k in range(len(B)):
                element += A[i][k] * B[k][j]
            row.append(element)
        result.append(row)
    
    return result

# Example usage:
matrix_A = [[1, 2, 3], [4, 5, 6]]
matrix_B = [[7, 8], [9, 10], [11, 12]]

try:
    product = multiply_matrices(matrix_A, matrix_B)
    print("Product:", product)
except ValueError as e:
    print(e)


def arrayStringsAreEqual(word1, word2):
    return "".join(word1) == "".join(word2)


import random

def shuffle_list(lst):
    n = len(lst)
    for i in range(n):
        # Generate a random index between i and n-1
        j = random.randint(i, n - 1)
        
        # Swap elements at index i and j
        lst[i], lst[j] = lst[j], lst[i]
    
    return lst


def unique_concatenation(str1, str2):
    unique_chars = set()
    for char in str1:
        unique_chars.add(char)
    for char in str2:
        unique_chars.add(char)
    
    sorted_chars = list(unique_chars)
    # Custom sorting algorithm
    n = len(sorted_chars)
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            temp = sorted_chars[i]
            j = i
            while j >= gap and sorted_chars[j - gap] > temp:
                sorted_chars[j] = sorted_chars[j - gap]
                j -= gap
            sorted_chars[j] = temp
        gap //= 2
    
    return ''.join(sorted_chars)


import re

def get_words(sentence):
    pattern = r'\b(?![aeiouAEIOU])[a-zA-Z]{1,5}\b'
    return re.findall(pattern, sentence)

sentence = "The quick brown fox jumps over the lazy dog"
words = get_words(sentence)
print(words)


# Generate a list with odd numbers in the range 3 to 12
numbers = [num for num in range(3, 13) if num % 2 != 0]

# Print the generated list
print(numbers)


def calculate_similarity(str1, str2, dict1=None, dict2=None):
    if dict1 is None:
        dict1 = {}
    if dict2 is None:
        dict2 = {}
    
    str1 = str1.lower()
    str2 = str2.lower()

    if len(str1) == 0 or len(str2) == 0:
        return 0

    if str1[0] in dict2 and dict2[str1[0]] > 0:
        dict2[str1[0]] -= 1
        dict1[str1[0]] -= 1
        return 1 + calculate_similarity(str1[1:], str2, dict1, dict2)

    if str2[0] in dict1 and dict1[str2[0]] > 0:
        dict1[str2[0]] -= 1
        return 1 + calculate_similarity(str1, str2[1:], dict1, dict2)

    return calculate_similarity(str1[1:], str2, dict1, dict2) + calculate_similarity(str1, str2[1:], dict1, dict2)

def compare_strings(str1, str2):
    dict1 = {}
    dict2 = {}

    for char in str1:
        dict1[char] = dict1.get(char, 0) + 1

    for char in str2:
        dict2[char] = dict2.get(char, 0) + 1

    similarity_score = calculate_similarity(str1, str2, dict1, dict2)

    penalty_score = -0.2 * (sum(dict1.values()) + sum(dict2.values()))
    similarity_score += penalty_score

    return similarity_score


from itertools import chain, combinations

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def get_subsets(lst):
    subsets = []
    for r in range(len(lst) + 1):
        subsets += list(combinations(lst, r))
    return subsets

lst = [1, 2, 3, 4]
prime_subsets = [subset for subset in get_subsets(lst) if sum(subset) > 5 and all(is_prime(num) for num in subset)]
print(prime_subsets)


class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Creating an instance of the custom data type
john = Person("John", 25)

print(john.name)  # Output: John
print(john.age)   # Output: 25


class Employee:
    def __init__(self, name, employee_id, job_title, hourly_wage):
        self.name = name
        self.employee_id = employee_id
        self.job_title = job_title
        self.hourly_wage = hourly_wage
        self.work_hours = {}  # dictionary to store logged work hours, with date as key and hours worked as value

    def log_work_hours(self, date, hours):
        self.work_hours[date] = hours

    def calculate_monthly_salary(self):
        total_hours_worked = sum(self.work_hours.values())
        overtime_hours = max(total_hours_worked - 40, 0)  # calculate overtime hours, if any
        regular_hours = total_hours_worked - overtime_hours  # calculate regular hours

        # calculate salary for regular hours and overtime hours
        regular_salary = regular_hours * self.hourly_wage
        overtime_salary = overtime_hours * self.hourly_wage * 1.5

        # calculate salary for weekends (doubling the hourly wage)
        weekend_hours = sum(1 for date in self.work_hours if date.weekday() >= 5)
        weekend_salary = weekend_hours * self.hourly_wage * 2

        # calculate total monthly salary
        monthly_salary = regular_salary + overtime_salary + weekend_salary
        return monthly_salary

    def view_monthly_salary(self):
        monthly_salary = self.calculate_monthly_salary()
        return f"{self.name}'s monthly salary is {monthly_salary}"


# Example usage
employee = Employee("John Doe", 12345, "Software Developer", 15)
employee.log_work_hours("2022-01-01", 8)  # log 8 hours worked on January 1st
employee.log_work_hours("2022-01-02", 10)  # log 10 hours worked on January 2nd
employee.log_work_hours("2022-01-08", 6)  # log 6 hours worked on January 8th (weekend)
print(employee.view_monthly_salary())  # Output: John Doe's monthly salary is 370.0


class Person:
    def __init__(self, name, age, address, phone_number):
        self.name = name
        self.age = age
        self.address = address
        self.phone_number = phone_number

    def get_full_name(self):
        return self.name

    def is_adult(self):
        return self.age >= 18

    def change_address(self, new_address):
        self.address = new_address

    def change_phone_number(self, new_phone_number):
        self.phone_number = new_phone_number

    def get_contact_info(self):
        return f"Name: {self.name}\nAge: {self.age}\nAddress: {self.address}\nPhone Number: {self.phone_number}"

    def calculate_age_in_months(self):
        return self.age * 12

# Example usage:
person = Person("John Doe", 25, "123 Main St", "555-1234")
print(person.get_full_name())  # Output: John Doe
print(person.is_adult())  # Output: True

person.change_address("456 Elm St")
person.change_phone_number("555-5678")
print(person.get_contact_info())
# Output:
# Name: John Doe
# Age: 25
# Address: 456 Elm St
# Phone Number: 555-5678

print(person.calculate_age_in_months())  # Output: 300


def extract_last_element(lst):
    if len(lst) > 0:
        return lst[-1]
    else:
        return None

# Example usage
my_list = [1, 2, 3, 4, 5]
last_element = extract_last_element(my_list)
print(last_element)  # Output: 5


import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.model_selection import KFold
from sklearn.model_selection import GridSearchCV
from sklearn.pipeline import make_pipeline
import matplotlib.pyplot as plt

def train_linear_regression_model(dataset_path, target_column, test_size=0.2, regularization=None, cv=None):
    # Step 1: Load the dataset from a CSV file
    dataset = pd.read_csv(dataset_path)
    
    # Step 2: Handle missing values
    # Remove rows/columns with missing values or impute with appropriate values
    
    # Option 1: Removing rows with missing values
    # dataset.dropna(axis=0, inplace=True)
    
    # Option 2: Removing columns with missing values
    # dataset.dropna(axis=1, inplace=True)
    
    # Option 3: Impute missing values with mean
    # dataset.fillna(dataset.mean(), inplace=True)
    
    # Step 3: Perform feature scaling
    features = dataset.drop(columns=[target_column])
    target = dataset[target_column]
    scaler = StandardScaler()
    features_scaled = scaler.fit_transform(features)
    
    # Step 4: Split the dataset into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(features_scaled, target, test_size=test_size, stratify=target)
    
    # Step 5: Train a linear regression model
    if regularization == 'ridge':
        model = make_pipeline(StandardScaler(), Ridge())
    elif regularization == 'lasso':
        model = make_pipeline(StandardScaler(), Lasso())
    else:
        model = LinearRegression()
    model.fit(X_train, y_train)
    
    # Step 6: Evaluate the trained model
    y_pred = model.predict(X_test)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)
    
    # Step 7: Optionally, implement k-fold cross-validation
    if cv is not None:
        kf = KFold(n_splits=cv)
        mse_scores = []
        r2_scores = []
        for train_index, test_index in kf.split(features_scaled):
            X_train, X_test = features_scaled[train_index], features_scaled[test_index]
            y_train, y_test = target.iloc[train_index], target.iloc[test_index]
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse_scores.append(mean_squared_error(y_test, y_pred))
            r2_scores.append(r2_score(y_test, y_pred))
        mse_cv = np.mean(mse_scores)
        r2_cv = np.mean(r2_scores)
        print(f"Mean Squared Error (CV): {mse_cv}")
        print(f"R-squared (CV): {r2_cv}")
    
    # Step 8: Visualize the predicted values against the actual values
    plt.scatter(y_test, y_pred)
    plt.xlabel('Actual Values')
    plt.ylabel('Predicted Values')
    plt.show()
    
    # Step 9: Save the trained model
    model_path = 'trained_model.pkl'
    joblib.dump(model, model_path)
    
    return mse, r2


def check_divisibility(num):
    if num % 7 == 0 and num % 13 == 0 and num % 5 != 0:
        return True
    else:
        return False

# Example usage
print(check_divisibility(91))  # True, as 91 is divisible by 7 and 13 but not by 5
print(check_divisibility(35))  # False, as 35 is divisible by 5
print(check_divisibility(28))  # False, as 28 is divisible by 7 but not by 13
print(check_divisibility(65))  # False, as 65 is divisible by 5


import json

# Step 1: Read the JSON data from the input source
json_data = """
{
    "status": "SUCCESS",
    "message": "",
    "data": {
        "category": "Mathematics",
        "difficult": "Easy"
    }
}
"""

try:
    # Step 2: Parse the JSON data into a data structure
    data = json.loads(json_data)

    # Step 3: Access the 'data' key in the JSON data
    nested_data = data.get('data')

    if nested_data:
        # Step 4: Access the 'category' and 'difficulty' keys in the nested data
        category = nested_data.get('category')
        difficulty = nested_data.get('difficult')

        # Step 5: Display the values of the 'category' and 'difficulty' keys as output
        print("Category:", category)
        print("Difficulty:", difficulty)
    else:
        print("Invalid JSON data")

except json.JSONDecodeError as e:
    print("Invalid JSON format:", e)
except Exception as e:
    print("Error:", e)


def positive_numbers(numbers):
    count = 0
    maximum = float('-inf')
    minimum = float('inf')
    total_sum = 0

    for number in numbers:
        if number < 0:
            continue
        count += 1
        total_sum += number
        if number > maximum:
            maximum = number
        if number < minimum:
            minimum = number

    average = total_sum / count

    print("Sum of positive numbers:", total_sum)
    print("Maximum positive number:", maximum)
    print("Minimum positive number:", minimum)
    print("Count of positive numbers:", count)
    print("Average of positive numbers:", average)

numbers = [1, -2, 3, 4, -5, 6, 7, -8, 9]
positive_numbers(numbers)


def find_max_min(arr):
    if len(arr) == 0:
        return None
    
    maxValue = arr[0]
    minValue = arr[0]
    
    for i in range(1, len(arr)):
        if arr[i] > maxValue:
            maxValue = arr[i]
        if arr[i] < minValue:
            minValue = arr[i]
    
    return maxValue, minValue


def store_key_value(dictionary, key, value):
    # Check if key is a string containing only alphabetic characters
    if not key.isalpha():
        print("Invalid key! The key must be a string containing only alphabetic characters.")
        return

    # Check if value is a positive integer
    if not isinstance(value, int) or value <= 0:
        print("Invalid value! The value must be a positive integer.")
        return

    # Check if the key already exists in the dictionary
    if key in dictionary:
        dictionary[key] = value
        dictionary[key+"_updates"] = dictionary.get(key+"_updates", 0) + 1
    else:
        dictionary[key] = value
        dictionary[key+"_updates"] = 1

# Example usage:
my_dict = {}
store_key_value(my_dict, "key1", 10)
store_key_value(my_dict, "key2", 20)
store_key_value(my_dict, "key1", 30)
store_key_value(my_dict, "key3", 40)
print(my_dict)


from collections import Counter
import statistics

def calculate_statistics(arr):
    # Check if the input is valid
    if not isinstance(arr, list) or len(arr) == 0:
        return "Invalid input"

    # Check if all elements are positive integers
    for num in arr:
        if not isinstance(num, int) or num <= 0:
            return "Invalid input"

    # Calculate the mean
    mean = round(sum(arr) / len(arr), 2)

    # Calculate the median
    median = statistics.median(arr)

    # Calculate the mode
    count = Counter(arr)
    max_count = max(count.values())
    mode = [num for num, freq in count.items() if freq == max_count]

    # Return the result as a string
    return f"Mean: {mean}, Median: {median}, Mode: {mode}"


def roman_multiply(num1, num2):
    decimal1 = roman_to_decimal(num1)
    decimal2 = roman_to_decimal(num2)
    product = decimal1 * decimal2
    return decimal_to_roman(product)

def roman_to_decimal(roman_num):
    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    decimal_num = 0
    for i in range(len(roman_num)):
        if i > 0 and roman_values[roman_num[i]] > roman_values[roman_num[i - 1]]:
            decimal_num += roman_values[roman_num[i]] - 2 * roman_values[roman_num[i - 1]]
        else:
            decimal_num += roman_values[roman_num[i]]
    return decimal_num

def decimal_to_roman(decimal_num):
    roman_values = {1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC',
                    50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}
    roman_num = ''
    for value, symbol in roman_values.items():
        while decimal_num >= value:
            roman_num += symbol
            decimal_num -= value
    return roman_num


def find_second_most_frequent(nums):
    counts = {}
    for num in nums:
        if num in counts:
            counts[num] += 1
        else:
            counts[num] = 1

    most_frequent = None
    second_most_frequent = None

    for num, count in counts.items():
        if most_frequent is None or count > counts[most_frequent]:
            second_most_frequent = most_frequent
            most_frequent = num
        elif second_most_frequent is None or count > counts[second_most_frequent]:
            second_most_frequent = num

    return second_most_frequent


# Test case
nums = [1, 2, 3, 4, 2, 3, 4, 5, 2, 3, 4, 5, 6, 3, 4, 5, 6, 7, 4, 5, 6, 7, 8, 5, 6, 7, 8, 9, 6, 7, 8, 9, 10, 7, 8, 9, 10, 11, 8, 9, 10, 11, 12, 9, 10, 11, 12, 13, 10, 11, 12, 13, 14, 11, 12, 13, 14, 15]
print(find_second_most_frequent(nums))


# Define a function to compute the quotient and remainder of a number divided by 5
def divide_by_five(num):
    quotient = num // 5
    remainder = num % 5
    return quotient, remainder
# Define a range of numbers to divide by 5
numbers = range(1, 11)
# Initialize a variable to store the highest remainder
highest_remainder = 0
# Loop through the numbers and compute their quotients and remainders
for num in numbers:
    quotient, remainder = divide_by_five(num)
    print(f"{num} divided by 5 is {quotient} with a remainder of {remainder}")
    
    # Check if the remainder is higher than the current highest remainder
    if remainder > highest_remainder:
        highest_remainder = remainder
# Print the highest remainder
print(f"The highest remainder is {highest_remainder}")


def find_mean(numbers):
    total = len(numbers)
    sum = 0
    
    for num in numbers:
        sum += num
    
    mean = sum / total
    return mean


def longestBalancedSubstring(s):
    max_len = 0
    zeros = ones = 0
    for c in s:
        if c == '0':
            zeros += 1
        else:
            ones += 1
        if zeros == ones:
            max_len = max(max_len, zeros * 2)
        elif zeros > ones:
            zeros = ones = 0
    zeros = ones = 0
    for c in reversed(s):
        if c == '0':
            zeros += 1
        else:
            ones += 1
        if zeros == ones:
            max_len = max(max_len, zeros * 2)
        elif zeros < ones:
            zeros = ones = 0
    return max_len


class Customer:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.purchases = []

    def add_purchase(self, item, price):
        self.purchases.append((item, price))

    def display_details(self):
        print("Name: " + self.name)
        print("Email: " + self.email)

    def calculate_total_amount_spent(self):
        total_amount = 0
        for purchase in self.purchases:
            total_amount += purchase[1]
        return total_amount

# Example usage:
customer = Customer("John Doe", "johndoe@example.com")
customer.add_purchase("Shoes", 50)
customer.add_purchase("T-Shirt", 20)
customer.display_details()
print("Total amount spent:", customer.calculate_total_amount_spent())


def generate_textbox_html(input_string):
    textbox_html = f'<input type="text" id="{input_string}">'
    return textbox_html


def largest_prime_factor(N1, N2, R):
    """
    This function finds the largest prime number that is a factor of N1 and N2 and is within the range of 1 to R.

    Approach:
    1. Create a helper function to check if a number is prime.
    2. Iterate from R down to 2 (since 1 is not a prime number).
    3. If the current number is a prime number and is a factor of both N1 and N2, return it.
    4. If no such number is found, return -1.

    Edge cases:
    1. If N1 or N2 is 1, the function will return -1 since 1 has no prime factors.
    2. If N1 and N2 are equal, the function will still work correctly.
    """

    def is_prime(n):
        """Check if a number is prime."""
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0 or n % 3 == 0:
            return False
        i = 5
        while i * i <= n:
            if n % i == 0 or n % (i + 2) == 0:
                return False
            i += 6
        return True

    for i in range(R, 1, -1):
        if is_prime(i) and N1 % i == 0 and N2 % i == 0:
            return i

    return -1


def print_column_wise(arr):
    if not arr:  # Check if the array is empty
        print("The array is empty.")
        return
    
    num_rows = len(arr)
    num_cols = len(arr[0])
    
    for j in range(num_cols):
        for i in range(num_rows):
            if len(arr[i]) != num_cols:  # Check if the row has the same number of columns as the first row
                print("Error: Row", i+1, "has a different number of columns.")
                break
            if not isinstance(arr[i][j], int):  # Check if the element is an integer
                print("Error: Element at position (", i+1, ",", j+1, ") is not an integer.")
                continue
            print(arr[i][j], end=" ")
        print()  # Print a new line after printing each column


def binary_search_duplicates(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # If the middle element is the target
        if arr[mid] == target:
            return True

        # Check if the middle element is a duplicate
        if arr[mid] == arr[left] == arr[right]:
            left += 1
            right -= 1

        # If the left side is sorted
        elif arr[left] <= arr[mid]:
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1

        # If the right side is sorted
        else:
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1

    return False


dict1 = {chr(x): x for x in range(ord('z'), ord('a')-1, -1) if x % 2 != 0 and x % 3 != 0}


import re
text = "hipvinylster"
pattern = r"^hip(.*)(tea|vinyl|beard|tweed|glasses|vegan)ster$"
match = re.search(pattern, text)
if match:
 username = match.group(0)
 print(username)
else:
 print("No match found.")


def prime_factors(n):
    factors = []
    d = 2
    while d * d <= n:
        if n % d == 0:
            factors.append(d)
            n //= d
        else:
            d += 1
    if n > 1:
        factors.append(n)
    return factors


s = "Hello World"

# Remove all occurrences of 'l' from the original string
s = s.replace('l', '')

# Create a dictionary to store the counts of each character
char_counts = {}

# Iterate over characters in reverse order
for char in reversed(s):
    # Check if the character is already in the dictionary
    if char in char_counts:
        # Increment the count of the character
        char_counts[char] += 1
    else:
        # Add the character to the dictionary with a count of 1
        char_counts[char] = 1

# Print the counts of each character
for char, count in char_counts.items():
    print(char, ":", count)


arr = [12, 34, 56, 78, 90, 23, 45, 67, 89, 10]
element = 100

# Function to insert element at the beginning of the array and shift other elements to the right
def insert_element(arr, element):
    # Remove the oldest element if the array is full
    if len(arr) == 10:
        oldest = arr.pop(0)
        print(f"Removing oldest element: {oldest}")
    
    # Shift all other elements to the right
    arr = [element] + arr

    # Count the occurrences of each integer in the array
    counts = {}
    for num in arr:
        counts[num] = counts.get(num, 0) + 1
    
    # Display the count of each integer after insertion
    print(f"Count of each integer: {counts}")

    return arr

# Insert element at the beginning of the array and display the updated array
arr = insert_element(arr, element)
print(f"Updated array: {arr}")


import random
# Define the rhyming pattern
rhyme_pattern = ["A", "A", "B", "B", "C", "C", "D", "D"]
# Define the syllable counts for each line
syllables = [8, 8, 6, 6, 10, 10, 8, 8]
# Define the possible words for each rhyme group
rhyme_words = {
    "A": ["fight", "might", "right", "tight"],
    "B": ["team", "dream", "scheme", "seem"],
    "C": ["goal", "soul", "role", "pole"],
    "D": ["win", "grin", "spin", "chin"]
}
# Define the user's desired chant length, tempo, and syllables per line
chant_length = 16
tempo = 120
syllables_per_line = 8
# Calculate the number of lines needed for the desired chant length
num_lines = int(chant_length / len(rhyme_pattern))
# Initialize the chant as an empty list
chant = []
# Generate the chant
for i in range(num_lines):
    for j in range(len(rhyme_pattern)):
        rhyme_group = rhyme_pattern[j]
        syllable_count = syllables[j]
        word_list = rhyme_words[rhyme_group]
        word = random.choice(word_list)
        line = f"{i+1}, {j+1}, {syllable_count}, {word}"
        chant.append(line)
# Format the chant as a table
table = "Line, Rhyme, Syllables, Word\n"
for line in chant:
    table += line + "\n"
# Print the table and the tempo
print(table)
print(f"Tempo: {tempo} BPM")


def find_minimum_positive_odd(arr):
    min_odd = float('inf')
    found_odd = False

    for num in arr:
        if num > 0 and num % 2 != 0:
            if num < min_odd:
                min_odd = num
            found_odd = True

    if not found_odd:
        return -1
    else:
        return min_odd

# Test the function with the given example
arr = [-3, 0, 2, 7, 4, 9, 1]
print(find_minimum_positive_odd(arr))  # Output: 1


import requests
from bs4 import BeautifulSoup
import sqlite3
from urllib.parse import urljoin

# Set the base URL of the website
base_url = "https://www.example.com/"

# Set the starting page URL
starting_page = base_url

# Initialize the database connection
conn = sqlite3.connect('products.db')
c = conn.cursor()

# Create a table to store the collected data
c.execute('''CREATE TABLE IF NOT EXISTS products
             (name TEXT, price TEXT)''')

# Function to scrape the data from a webpage and store it in the database
def scrape_page(url):
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    # Scrape the required data from the webpage
    products = soup.find_all('div', class_='product')
    for product in products:
        name = product.find('h3').text.strip()
        price = product.find('span', class_='price').text.strip()

        # Store the scraped data in the database
        c.execute("INSERT INTO products (name, price) VALUES (?, ?)", (name, price))
    
    # Commit the changes to the database
    conn.commit()

# Function to handle dynamic content loading using AJAX requests
def scrape_dynamic_content(url):
    response = requests.get(url)
    json_data = response.json()
    
    # Extract the URLs of the subpages containing "products"
    product_urls = [urljoin(base_url, product['url']) for product in json_data['products']]
    
    # Scrape the data from each subpage
    for product_url in product_urls:
        scrape_page(product_url)

# Function to handle pagination and scrape all relevant subpages
def scrape_website():
    # Start with the initial page
    current_page = starting_page
    
    while True:
        try:
            # Scrape the current page
            scrape_page(current_page)

            # Send AJAX request to get the URL of the next page
            response = requests.get(current_page)
            json_data = response.json()
            next_page = urljoin(base_url, json_data['nextPageUrl'])

            # Check if the next page is valid and contains "products" in the URL
            if next_page != current_page and 'products' in next_page:
                current_page = next_page
            else:
                break
        except Exception as e:
            # Handle any errors or exceptions that occur during the scraping process
            print("An error occurred:", e)
            break

# Function to display the collected data on a webpage with pagination
def display_data(page):
    items_per_page = 20
    offset = (page - 1) * items_per_page

    # Retrieve the required data from the database
    c.execute("SELECT name, price FROM products LIMIT ? OFFSET ?", (items_per_page, offset))
    products = c.fetchall()

    # Display the data on the webpage
    for product in products:
        print(product[0], product[1])

# Scrape the website and store the data in the database
scrape_website()

# Display the data on the webpage with pagination
page = 1
display_data(page)

# Close the database connection
conn.close()


def compare_strings(str1, str2):
    # Remove leading and trailing whitespace
    str1 = str1.strip()
    str2 = str2.strip()
    
    # Make both strings lowercase
    str1 = str1.lower()
    str2 = str2.lower()
    
    # Compare each character of the strings
    for i in range(min(len(str1), len(str2))):
        if str1[i] < str2[i]:
            return "smaller"
        elif str1[i] > str2[i]:
            return "bigger"
    
    # If all characters are equal, compare the lengths of the strings
    if len(str1) < len(str2):
        return "smaller"
    elif len(str1) > len(str2):
        return "bigger"
    else:
        return "equal"


def get_linked_list_length(head):
    count = 0
    current = head
    while current:
        count += 1
        current = current.next
    return count


def longest_string(strings, k):
    max_length = -1
    smallest_lex = ""
    
    for string in strings:
        if len(string) <= k:
            if len(string) > max_length:
                max_length = len(string)
                smallest_lex = string
            elif len(string) == max_length and string < smallest_lex:
                smallest_lex = string
    
    return smallest_lex


palindromes = ["deed", "level", "radar", "rotor", "madam", "stats", "refer", "noon", "civic", "tenet"]

for palindrome in palindromes:
    print(palindrome)


def reverse_list(lst):
    left = 0
    right = len(lst) - 1
    
    while left < right:
        lst[left], lst[right] = lst[right], lst[left]
        left += 1
        right -= 1
    
    return lst.copy()


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def contains_digit_1(n):
    while n > 0:
        if n % 10 == 1:
            return True
        n //= 10
    return False

for i in range(1, 101):
    if i % 3 == 0 and i % 5 != 0 and is_prime(i) and not contains_digit_1(i):
        print(i)


def find_common_elements(list1, list2):
    # Create sets from the input lists to remove duplicates
    set1 = set(list1)
    set2 = set(list2)
    
    # Find the common elements by taking the intersection of the sets
    common_elements = set1.intersection(set2)
    
    # Convert the set back to a list and return the result
    return list(common_elements)

list1 = [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
list2 = [1, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200]

common_elements = find_common_elements(list1, list2)
print(common_elements)


def rotate_array(arr, positions):
    if len(arr) <= 1:
        return arr
    
    # Normalize the number of positions
    positions = positions % len(arr)
    
    if positions == 0:
        return arr
    
    if positions < 0:
        positions = len(arr) + positions
    
    # Reverse the entire array
    reverse_array(arr, 0, len(arr)-1)
    
    # Reverse the first part of the array
    reverse_array(arr, 0, positions-1)
    
    # Reverse the second part of the array
    reverse_array(arr, positions, len(arr)-1)
    
    return arr

def reverse_array(arr, start, end):
    while start < end:
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1


def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]
    
    merge_sort(left)
    merge_sort(right)
    
    merge(arr, left, right)
    
def merge(arr, left, right):
    i = j = k = 0
    
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    
    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1
    
    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1

# Example usage:
arr = [5, 2, 8, 3, 1]
merge_sort(arr)
print(arr)


def sum_array(arr):
    total = 0  # initialize the running sum to 0
    
    for num in arr:
        total += num  # add each element to the running sum
    
    return total


import time

def generate_random_string():
    # Use current time as the seed for pseudo-random number generation
    seed = int(time.time())
    
    # Set the alphabet for the random string generation
    alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    
    # Initialize the random string
    random_string = ""
    
    # Generate the random string
    for _ in range(10):
        # Multiply the seed by a large prime number to make it less predictable
        seed = (seed * 1103515245 + 12345) & 0x7fffffff
        
        # Use the seed modulo the alphabet length to get a random index
        index = seed % len(alphabet)
        
        # Append the character at the random index to the random string
        random_string += alphabet[index]
    
    return random_string

# Generate and print a random string
print(generate_random_string())


import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def remove_outliers(x, y, threshold):
    z_scores = np.abs(stats.zscore(y))
    filtered_indices = np.where(z_scores < threshold)
    return x[filtered_indices], y[filtered_indices]

def calculate_correlation_coefficient(x, y):
    return np.corrcoef(x, y)[0, 1]

def calculate_p_value(x, y):
    _, p_value = stats.pearsonr(x, y)
    return p_value

def visualize_data(x, y, regression_line=False):
    plt.scatter(x, y, color='b', label='Data Points')
    if regression_line:
        slope, intercept, _, _, _ = stats.linregress(x, y)
        plt.plot(x, slope*x + intercept, color='r', label='Regression Line')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend()
    plt.show()

def calculate_least_squares(x, y, threshold=None, visualize=False):
    if threshold is not None:
        x, y = remove_outliers(x, y, threshold)
    correlation_coefficient = calculate_correlation_coefficient(x, y)
    p_value = calculate_p_value(x, y)
    if visualize:
        visualize_data(x, y, regression_line=True)
    return correlation_coefficient, p_value


import xml.etree.ElementTree as ET

# The XML code
xml_code = '''
<employees>
    <employee>
        <name>John</name>
        <age>25</age>
    </employee>
    <employee>
        <name>David</name>
        <age>35</age>
    </employee>
    <employee>
        <name>Alice</name>
        <age>45</age>
    </employee>
    <employee>
        <name>Sarah</name>
        <age>30</age>
    </employee>
    <employee>
        <name>Michael</name>
        <age>38</age>
    </employee>
</employees>
'''

# Parse the XML code
root = ET.fromstring(xml_code)

# Find employees with age between 30 and 40
employees = root.findall(".//employee[age >= 30 and age <= 40]")

# Extract and sort their names
names = sorted([employee.find('name').text for employee in employees], reverse=True)

# Print the names
for name in names:
    print(name)


import random
import string
# Define the special characters and numeric values to be used
special_chars = ['@', '#', '$', '%', '&']
numeric_values = [str(i) for i in range(10)]
# Define a function to generate a random string
def generate_random_string(length):
 # Choose a random combination of special character and numeric value
 special_char = random.choice(special_chars)
 numeric_value = random.choice(numeric_values)
 # Choose random letters from the alphabet to fill out the rest of the string
 letters = string.ascii_lowercase
 random_letters = ''.join(random.choice(letters) for i in range(length-2))
 # Combine the special character, numeric value, and random letters into a string
 random_string = special_char + numeric_value + random_letters
 return random_string
# Generate five unique random strings
random_strings = set()
while len(random_strings) < 5:
 random_string = generate_random_string(random.randint(10, 15))
 random_strings.add(random_string)
# Sort the strings in lexicographic order
sorted_strings = sorted(random_strings)
# Print the sorted strings
for string in sorted_strings:
 print(string)


def longest_common_substring(s1, s2):
    m = len(s1)
    n = len(s2)

    # Initialize matrix
    matrix = [[0] * (n + 1) for _ in range(m + 1)]

    # Variables to track longest substring
    max_length = 0
    end_index = 0

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1].lower() == s2[j - 1].lower():
                matrix[i][j] = matrix[i - 1][j - 1] + 1
                if matrix[i][j] > max_length:
                    max_length = matrix[i][j]
                    end_index = i

    # Extract longest common substring from s1
    longest_substring = s1[end_index - max_length: end_index]

    return longest_substring

# Test the function
s1 = "Tangible"
s2 = "Non-Tangible"
print(longest_common_substring(s1, s2))  # Output: "Tangible"

s1 = "abcde"
s2 = "xyz"
print(longest_common_substring(s1, s2))  # Output: ""


def find_top_3_highest_numbers(arr):
    max1 = float('-inf')
    max2 = float('-inf')
    max3 = float('-inf')

    for num in arr:
        if num > max1:
            max3 = max2
            max2 = max1
            max1 = num
        elif num > max2:
            max3 = max2
            max2 = num
        elif num > max3:
            max3 = num

    return [max1, max2, max3]


A = [9, 4, 18, 24, 7, 22, 11]
top_3_numbers = find_top_3_highest_numbers(A)
print(top_3_numbers)


def count_alphabets(string):
    # Convert the string to lowercase
    string = string.lower()

    # Initialize a dictionary to store the frequency of each character
    frequency = {}

    # Iterate over each character in the string
    for char in string:
        # Check if the character is an alphabet
        if char.isalpha():
            # Update the frequency of the character
            frequency[char] = frequency.get(char, 0) + 1

    # Sort the frequency dictionary in descending order of values
    sorted_frequency = sorted(frequency.items(), key=lambda x: x[1], reverse=True)

    return sorted_frequency


# Test the function
input_string = input("Enter a string: ")
result = count_alphabets(input_string)
print("Character frequencies (in descending order):")
for char, freq in result:
    print(char, "-", freq)


def is_brackets_matched(string):
    stack = []
    opening_brackets = ['(', '[', '{']
    closing_brackets = [')', ']', '}']
    bracket_pairs = {')': '(', ']': '[', '}': '{'}

    for char in string:
        if char in opening_brackets:
            stack.append(char)
        elif char in closing_brackets:
            if len(stack) == 0 or stack[-1] != bracket_pairs[char]:
                return False
            stack.pop()

    return len(stack) == 0


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

prime_sum = 0
for num in range(1, 1001):
    if is_prime(num):
        prime_sum += num

print("The sum of all prime numbers between 1 and 1000 is:", prime_sum)


def print_full_name(firstName, lastName):
    full_name = lastName + " " + firstName
    print(full_name)


import re

def parse_string(string):
    # Remove punctuation marks
    string = re.sub(r'[^\w\s]', '', string)

    # Convert string to lowercase and split into words
    words = string.lower().split()

    return words

# Test the implementation
string = "This is a Test String!"
print(parse_string(string))


import datetime

class BankAccount:
    interest_rate = 0.05

    def __init__(self, balance=0):
        self.balance = balance
        self.transaction_history = []

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError("Amount to deposit must be greater than zero.")
        self.balance += amount
        self.transaction_history.append({"type": "deposit", "amount": amount, "timestamp": datetime.datetime.now()})
        return self.balance

    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("Amount to withdraw must be greater than zero.")
        if amount > self.balance:
            raise InsufficientFundsError("Insufficient funds to withdraw.")
        self.balance -= amount
        self.transaction_history.append({"type": "withdrawal", "amount": amount, "timestamp": datetime.datetime.now()})
        return self.balance

    def transfer(self, amount, account):
        if amount <= 0:
            raise ValueError("Amount to transfer must be greater than zero.")
        if amount > self.balance:
            raise InsufficientFundsError("Insufficient funds to transfer.")
        self.balance -= amount
        account.balance += amount
        self.transaction_history.append({"type": "transfer", "amount": amount, "timestamp": datetime.datetime.now()})
        return self.balance

    def apply_interest(self):
        interest = self.balance * BankAccount.interest_rate
        self.balance += interest
        self.transaction_history.append({"type": "interest", "amount": interest, "timestamp": datetime.datetime.now()})
        return self.balance


class InsufficientFundsError(Exception):
    pass


import re
from html import unescape

def remove_html_tags(input_string):
    # Remove HTML tags and content inside the tags
    clean_string = re.sub('<.*?>', '', input_string)
    # Convert HTML entities to characters
    clean_string = unescape(clean_string)
    # Capitalize each word
    clean_string = clean_string.title()
    # Remove duplicate words
    clean_string = ' '.join(sorted(set(clean_string.split())))
    return clean_string

input_string = "<h1>Hello &amp; <strong>World</strong></h1>"
output_string = remove_html_tags(input_string)
print(output_string)


def is_palindrome(s):
    i, j = 0, len(s) - 1
    while i < j:
        while i < j and not s[i].isalnum():
            i += 1
        while i < j and not s[j].isalnum():
            j -= 1
        if s[i].lower() != s[j].lower():
            return False
        i += 1
        j -= 1
    return True


import tensorflow as tf
from tensorflow.keras import layers

# Define the neural network architecture
def create_model(input_shape):
    model = tf.keras.Sequential()
    model.add(layers.Embedding(input_dim=10000, output_dim=16, input_length=input_shape))
    model.add(layers.GlobalAveragePooling1D())
    model.add(layers.Dense(16, activation='relu'))
    model.add(layers.BatchNormalization())
    model.add(layers.Dropout(0.5))
    model.add(layers.Dense(1, activation='sigmoid'))
    return model

# Define the custom loss function
def custom_loss(y_true, y_pred):
    pos_weight = 5  # Weight for misclassifying positive reviews as negative
    neg_weight = 1  # Weight for misclassifying negative reviews as positive
    
    loss = tf.reduce_mean(
        neg_weight * (1 - y_true) * tf.math.log(1 - y_pred) +
        pos_weight * y_true * tf.math.log(y_pred))
    return -loss

# Create an instance of the model
model = create_model(input_shape=100)

# Compile the model with the custom loss function
model.compile(optimizer='adam', loss=custom_loss, metrics=['accuracy'])

# Train the model
model.fit(train_data, train_labels, epochs=10, validation_data=(val_data, val_labels))


def remove_duplicates(input_string):
    seen = ''
    result = ''
    for char in input_string:
        if char == ' ':
            if seen not in result:
                result += seen + ' '
            seen = ''
        else:
            seen += char
    if seen not in result:
        result += seen
    return result.rstrip()

# Example usage:
input_string = "hello world hello world"
print(remove_duplicates(input_string))  # Output: "hello world"


class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def maxSumBST(root):
    def helper(node):
        if not node:
            return float('inf'), float('-inf'), 0, True

        left_min, left_max, left_sum, is_left_bst = helper(node.left)
        right_min, right_max, right_sum, is_right_bst = helper(node.right)

        if is_left_bst and is_right_bst and node.val > left_max and node.val < right_min:
            sum_ = node.val + left_sum + right_sum
            max_sum[0] = max(max_sum[0], sum_)
            return min(node.val, left_min), max(node.val, right_max), sum_, True

        return 0, 0, 0, False

    max_sum = [0]
    helper(root)
    return max_sum[0]


def capitalize_words(string):
    # Remove leading and trailing whitespace
    string = string.strip()
    
    # Split the string into words using whitespace as the delimiter
    words = string.split()
    
    # Capitalize the first letter of each word while maintaining the original casing of the rest of the word
    capitalized_words = [word[0].upper() + word[1:] for word in words]
    
    # Join the words back together with whitespace as the delimiter
    capitalized_string = ' '.join(capitalized_words)
    
    return capitalized_string


import time

def logger(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        elapsed_time = end_time - start_time
        
        arg_str = ', '.join([repr(arg) for arg in args] +
                           [f"{key}={repr(value)}" for key, value in kwargs.items()])
        
        print(f"Called {func.__name__}({arg_str})")
        print(f"Returned: {result}")
        print(f"Time taken: {elapsed_time:.6f} seconds\n")
        
        return result
    return wrapper


numbers = [1, 2, 3, 4, 5]
result = []

for num in numbers:
    result.append(num * 2)


import re

def longest_substring(string):
    # Find all substrings that match the pattern
    matches = re.findall(r'\d*[A-Z]\d*[A-Z]\d*', string)

    # If no matches are found, return an empty string
    if not matches:
        return ''

    # Find the longest match
    longest_match = max(matches, key=len)

    return longest_match

# Example usage:
print(longest_substring('abc123DEF456ghi789'))  # Output: DEF456ghi
print(longest_substring('abc123DEFghi789'))  # Output: DEF
print(longest_substring('abc123defghi789'))  # Output: ''


def bubble_sort(arr):
    n = len(arr)
    
    # Traverse through all array elements
    for i in range(n):
        
        # Last i elements are already in place
        for j in range(0, n-i-1):
            
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    
    return arr

# Test the program
arr1 = [7, 3, 1, 9, 2]
print(bubble_sort(arr1))  # Output: [1, 2, 3, 7, 9]

arr2 = [7, 3, 1, 9, 2, -5, -2]
print(bubble_sort(arr2))  # Output: [-5, -2, 1, 2, 3, 7, 9]

arr3 = [7, 3, 1, 9, 2, -5, -2, 2, 7]
print(bubble_sort(arr3))  # Output: [-5, -2, 1, 2, 2, 3, 7, 7, 9]


def find_triangle_area(base, height):
    # Check if base and height are positive integers
    if type(base) != int or type(height) != int or base <= 0 or height <= 0:
        return "Invalid input"

    # Calculate the area using the formula
    area = 0.5 * base * height

    # Round the area to the nearest integer
    area = round(area)

    return area


import requests
from collections import OrderedDict

cache = OrderedDict()
api_calls = 0

def get_movie_rating(movie_title):
    global cache, api_calls

    # Check if the movie rating is already in the cache
    if movie_title in cache:
        # Move the movie title to the end of the queue
        cache.move_to_end(movie_title)
        return cache[movie_title], api_calls

    # Make API call to fetch the movie rating
    response = requests.get(f'http://api.example.com/movie/{movie_title}')
    api_calls += 1

    # Handle case where movie title does not exist
    if response.status_code == 404:
        return 'Movie not found in IMDB database', api_calls

    # Extract the rating from the API response
    rating = response.json()['rating']

    # Store the movie rating in the cache
    if len(cache) >= 10:
        # Remove the least recently used entry from the cache
        cache.popitem(last=False)
    cache[movie_title] = rating

    return rating, api_calls


def remove_oldest_elements(lst):
    count_removed = len(lst) - 100
    oldest_elements = lst[:count_removed]
    lst[:] = lst[count_removed:]
    print(f"Removed {count_removed} elements")


import re

def normalize_string(string):
    # Convert string to lowercase
    string = string.lower()
    
    # Remove punctuation using regular expressions
    string = re.sub(r'[^\w\s]', '', string)
    
    return string

def count_word_frequency(string):
    # Normalize string
    string = normalize_string(string)
    
    # Define stop words
    stop_words = ['and', 'the', 'is']
    
    # Split string into words
    words = string.split()
    
    # Count word frequency
    frequency = {}
    for word in words:
        if word not in stop_words:
            if word in frequency:
                frequency[word] += 1
            else:
                frequency[word] = 1
    
    return frequency


import csv
import os
def concatenate_first_column(input_file_path, delimiter=',', encoding='utf-8'):
    if not os.path.isfile(input_file_path):
        return 'Error: Invalid file path'
    with open(input_file_path, 'r', encoding=encoding) as input_file:
        reader = csv.reader(input_file, delimiter=delimiter)
        data = list(reader)
        if len(data) == 0:
            return 'Error: Empty table'
        first_column = [row[0] for row in data]
        first_column.sort(reverse=True)
        output = ''
        for value in first_column:
            if 'keyword1' in value:
                output += '\\textbf{\\textit{' + value + '}}\n'
            elif 'keyword2' in value:
                output += '\\textit{' + value + '}\n'
            else:
                output += value + '\n'
        return output
# Example usage
input_file_path = 'data.csv'
delimiter = ';'
encoding = 'iso-8859-1'
output = concatenate_first_column(input_file_path, delimiter, encoding)
print(output)


import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

def validate_text_field():
    # Initialize WebDriver
    driver = webdriver.Chrome()
    
    # Open the webpage
    driver.get("https://example.com")
    
    try:
        # Find the text field element
        text_field = WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.ID, "myTextField")))
        
        # Verify that the text field is not editable
        assert not text_field.is_enabled(), "Error: Text field is editable!"
        
        # Verify that the text field is visible
        assert text_field.is_displayed(), "Error: Text field is not visible!"
        
        # Get the initial value of the text field
        initial_value = text_field.get_attribute("value")
        
        # Wait for the text field to be populated with "Hello World!"
        WebDriverWait(driver, 1).until(EC.text_to_be_present_in_element_value((By.ID, "myTextField"), "Hello World!"))
        
        # Get the final value of the text field
        final_value = text_field.get_attribute("value")
        
        # Verify that the text field value is "Hello World!"
        assert final_value == "Hello World!", "Error: Text field value is not 'Hello World!'"
        
        # Verify that the text field value has changed
        assert final_value != initial_value, "Error: Text field value was not changed"
        
        print("Text field validation successful!")
        
    except AssertionError as e:
        print(str(e))
        
    finally:
        # Close the browser
        driver.quit()

# Run the test
validate_text_field()


def square_dict_values(input_dict):
    new_dict = {}
    
    for key, value in input_dict.items():
        if isinstance(key, int) and isinstance(value, int) and value > 0:
            squared_value = value ** 2
            new_dict[key] = squared_value
    
    return new_dict


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def max_difference(arr):
    max_diff = -1
    smallest_divisible_by_3 = float('inf')

    for i in range(1, len(arr), 2):
        if arr[i] % 3 == 0:
            smallest_divisible_by_3 = min(smallest_divisible_by_3, arr[i])
        else:
            diff = arr[i] - smallest_divisible_by_3
            if is_prime(diff):
                max_diff = max(max_diff, diff)

    return max_diff


def fibonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        fib = [0, 1]  # store previously calculated Fibonacci numbers
        for i in range(2, n+1):
            fib.append(fib[i-1] + fib[i-2])
        return fib[n]


def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = arr[:mid]
    right = arr[mid:]

    left = merge_sort(left)
    right = merge_sort(right)

    return merge(left, right)


def merge(left, right):
    result = []
    i = 0
    j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            # Find the correct position for right[j] in the sorted subarray left[i:]
            pos = binary_search(left, right[j], i)
            result.extend(left[i:pos])
            result.append(right[j])
            i = pos
            j += 1

    # Append the remaining elements from either left or right
    result.extend(left[i:])
    result.extend(right[j:])

    return result


def binary_search(arr, target, start):
    low = start
    high = len(arr) - 1

    while low <= high:
        mid = (low + high) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1

    return low


# Example usage:
arr = [9, 3, 6, 1, 5, 8, 2, 7, 4]
sorted_arr = merge_sort(arr)
print(sorted_arr)


def calculate_sum(numbers):
    total = 0
    for num in numbers:
        total += num
    return total


def count_characters(string):
    # Create an empty dictionary to store the character counts
    char_count = {}
    
    # Iterate through each character in the string
    for char in string:
        # If the character is already a key in the dictionary, increment its count
        if char in char_count:
            char_count[char] += 1
        # If the character is not a key in the dictionary, add it with a count of 1
        else:
            char_count[char] = 1
    
    # Return the dictionary of character counts
    return char_count


def get_unique_values_descending(numbers):
    unique_values = list(set(numbers))
    unique_values.sort(reverse=True)
    return unique_values

numbers = [3, 5, -7, 3, 4, -6, 7, 8]
result = get_unique_values_descending(numbers)
print(result)


import math

def calculate_correlation(x, y):
    n = len(x)
    x_mean = sum(x) / n
    y_mean = sum(y) / n
    x_stddev = math.sqrt(sum((xi - x_mean)**2 for xi in x) / n)
    y_stddev = math.sqrt(sum((yi - y_mean)**2 for yi in y) / n)
    
    correlation = sum((xi - x_mean) * (yi - y_mean) for xi, yi in zip(x, y)) / (n * x_stddev * y_stddev)
    
    return round(correlation, 4)


class MyQueue:

    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, x: int) -> None:
        self.stack1.append(x)

    def pop(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

    def peek(self) -> int:
        if not self.stack2:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2[-1]

    def empty(self) -> bool:
        return not self.stack1 and not self.stack2


def f(x):
    # Define the function to be integrated
    return x**2

def simpsons_rule(a, b, n):
    # Simpson's rule for numerical integration
    h = (b - a) / n
    integral = f(a) + f(b)

    for i in range(1, n):
        x = a + i * h
        if i % 2 == 0:
            integral += 2 * f(x)
        else:
            integral += 4 * f(x)

    integral *= h / 3
    return integral

# Example usage
a = 0  # Lower limit of integration
b = 1  # Upper limit of integration
n = 100  # Number of intervals

integral = simpsons_rule(a, b, n)
print("Numerical integration using Simpson's rule:", integral)


def spiral_print(matrix):
    # Get the size of the matrix
    rows = len(matrix)
    cols = len(matrix[0])
    
    # Initialize the boundaries
    top = 0
    bottom = rows - 1
    left = 0
    right = cols - 1
    
    # Initialize the direction and count
    direction = 0
    count = 0
    
    # Iterate through the matrix in a spiral form
    while (top <= bottom and left <= right):
        # Print the top row
        if direction == 0:
            for i in range(left, right + 1):
                print(matrix[top][i], end=' ')
            top += 1
        
        # Print the right column
        elif direction == 1:
            for i in range(top, bottom + 1):
                print(matrix[i][right], end=' ')
            right -= 1
        
        # Print the bottom row
        elif direction == 2:
            for i in range(right, left - 1, -1):
                print(matrix[bottom][i], end=' ')
            bottom -= 1
        
        # Print the left column
        elif direction == 3:
            for i in range(bottom, top - 1, -1):
                print(matrix[i][left], end=' ')
            left += 1
        
        # Update the direction and count
        direction = (direction + 1) % 4
        count += 1
    
    # Print a newline character
    print()

# Test the solution with the given example
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
spiral_print(matrix)


def recursive_delete(dictionary, key, deleted):
    for k in list(dictionary.keys()):
        if isinstance(dictionary[k], dict):
            deleted = recursive_delete(dictionary[k], key, deleted)
        elif k == key:
            deleted = True
            dictionary.pop(k)
    return deleted

# Example usage
my_dict = {
    'a': {
        'b': {
            'c': 1,
            'd': 2
        },
        'e': 3
    },
    'f': 4
}

deleted = False
result = recursive_delete(my_dict, 'd', deleted)

if result:
    print("Item deleted:", my_dict)
else:
    print("Item not found:", my_dict)


planets = ["Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"]

def get_planet_name(num):
    if num > len(planets):
        return "Invalid input: There are only " + str(len(planets)) + " planets in the solar system."
    else:
        return planets[num - 1]

input_num = 5
planet_name = get_planet_name(input_num)
print(planet_name)


def count_males(data):
    data.sort(key=lambda x: x.get("age", float('inf')))  # Sort by age
    low = binary_search(data, 20)  # Find the first index with age >= 20
    high = binary_search(data, 41)  # Find the first index with age > 40
    males = 0
    for person in data[low:high]:
        if person.get("gender") == "male":
            males += 1
    return males

def binary_search(data, target):
    low = 0
    high = len(data) - 1
    while low <= high:
        mid = (low + high) // 2
        if data[mid].get("age", float('inf')) < target:
            low = mid + 1
        else:
            high = mid - 1
    return low


def print_divisible_by_3(num):
    if not isinstance(num, int) or num <= 0:
        raise ValueError("Input must be a positive integer")

    for i in range(num, -1, -1):
        if i % 3 == 0:
            print(i)


def fahrenheit_to_celsius(fahrenheit):
    try:
        # Convert the input to a float
        fahrenheit = float(fahrenheit)
    except ValueError:
        return "Invalid input. Please enter a numeric value."
    
    if fahrenheit < -459.67 or fahrenheit > 1000:
        return "Invalid temperature value. Please enter a value between -459.67Â°F and 1000Â°F."
    
    # Calculate the Celsius value
    celsius = (fahrenheit - 32) * 5/9
    # Round to the nearest tenth
    celsius = round(celsius, 1)
    
    return celsius


def search_element(array, element):
    for i in range(len(array)):
        if array[i] == element:
            return i
    return -1


def beautifulArray(n: int) -> List[int]:
    result = [1]
    while len(result) < n:
        temp = []
        for i in result:
            if i * 2 - 1 <= n:
                temp.append(i * 2 - 1)
        for i in result:
            if i * 2 <= n:
                temp.append(i * 2)
        result = temp
    return result


def is_palindrome(string):
    # Convert the string to lowercase
    string = string.lower()
    
    # Remove whitespace and punctuation characters
    string = ''.join(char for char in string if char.isalnum())
    
    # Compare characters at corresponding positions
    for i in range(len(string)//2):
        if string[i] != string[-i-1]:
            return False
    
    return True

# Test the function
string = "racecar"
print(is_palindrome(string))  # True

string = "hello"
print(is_palindrome(string))  # False


def check_parentheses(input_string: str) -> bool:
    stack = []
    for char in input_string:
        if char == '(':
            stack.append(char)
        elif char == ')':
            if not stack:
                return False
            stack.pop()
    return len(stack) == 0


import heapq
from collections import defaultdict

def calculate_frequency(string):
    frequency = defaultdict(int)
    for char in string:
        frequency[char] += 1
    return frequency

def build_tree(frequency):
    pq = [[weight, [char, ""]] for char, weight in frequency.items()]
    heapq.heapify(pq)
    while len(pq) > 1:
        lo = heapq.heappop(pq)
        hi = heapq.heappop(pq)
        for pair in lo[1:]:
            pair[1] = '0' + pair[1]
        for pair in hi[1:]:
            pair[1] = '1' + pair[1]
        heapq.heappush(pq, [lo[0] + hi[0]] + lo[1:] + hi[1:])
    return pq[0]

def build_huffman_codes(tree):
    codes = {}
    for char, code in tree[1:]:
        codes[char] = code
    return codes

def encode_string(string, codes):
    encoded_string = ""
    for char in string:
        encoded_string += codes[char]
    return encoded_string

def compress_string(encoded_string):
    binary_string = ""
    for char in encoded_string:
        binary_string += "{0:08b}".format(ord(char))
    return binary_string

def decompress_string(binary_string, codes):
    encoded_string = ""
    current_code = ""
    for bit in binary_string:
        current_code += bit
        if current_code in codes.values():
            char = [key for key, value in codes.items() if value == current_code][0]
            encoded_string += char
            current_code = ""
    return encoded_string

def main():
    string = "abacabadabacaba"
    frequency = calculate_frequency(string)
    tree = build_tree(frequency)
    codes = build_huffman_codes(tree)
    
    encoded_string = encode_string(string, codes)
    binary_string = compress_string(encoded_string)
    
    print("Encoded String:", encoded_string)
    print("Binary String:", binary_string)
    
    decoded_string = decompress_string(binary_string, codes)
    print("Decoded String:", decoded_string)

if __name__ == '__main__':
    main()


def backtrack(permutation, unused, n):
    if len(permutation) == n:
        return 1

    count = 0
    for element in unused:
        if len(permutation) == 0 or element > permutation[-1]:
            new_permutation = permutation + [element]
            new_unused = unused.copy()
            new_unused.remove(element)
            count += backtrack(new_permutation, new_unused, n)

    return count

n = 5
elements = [1, 2, 3, 4, 5]
permutations = backtrack([], elements, n)
print("Number of valid permutations:", permutations)


import string

class WordCounter:
    def __init__(self, k=10):
        self.k = k
        self.word_counts = {}
        self.stop_words = set(["the", "and", "is", "a"])  # Example list of stop words

    def count_words(self, document):
        translator = str.maketrans("", "", string.punctuation)
        words = document.translate(translator).lower().split()
        
        for word in words:
            if word not in self.stop_words:
                self.word_counts[word] = self.word_counts.get(word, 0) + 1
        
        self._update_top_k()

    def _update_top_k(self):
        top_k = sorted(self.word_counts.items(), key=lambda x: x[1], reverse=True)[:self.k]
        self.word_counts = dict(top_k)

    def get_top_k(self):
        return self.word_counts

    def process_documents(self, file_paths):
        for file_path in file_paths:
            with open(file_path, 'r') as file:
                for line in file:
                    self.count_words(line)


import json
# JSON data for fruits and their prices
data = '''
{
  "fruits": [
    {
      "name": "apple",
      "price": 2.50,
      "quantity": 4
    },
    {
      "name": "orange",
      "price": 1.50,
      "quantity": 2
    }
  ]
}
'''
# Load the JSON data
fruits_data = json.loads(data)
# Calculate the total price of the purchase
total_price = 0
for fruit in fruits_data['fruits']:
    total_price += fruit['price'] * fruit['quantity']
# Print the total price of the purchase
print("Total price of the purchase: $", total_price)


import math

def factorial(n):
    if n < 0:
        return "Factorial is not defined for negative numbers"
    elif n == 0 or n == 1:
        return 1
    else:
        return math.factorial(n)

# Taking input from user
n = int(input("Enter a number (1 <= n <= 20): "))

print("Factorial of", n, "is:", factorial(n))


class TreeNode:
    def __init__(self, value):
        self.val = value
        self.left = None
        self.right = None


def findMaxElement(root):
    maxElement = float('-inf')  # Initialize maxElement to negative infinity
    current = root

    while current:
        if current.val > maxElement:
            maxElement = current.val
        
        if current.right:
            current = current.right
        else:
            current = current.left

    return maxElement


# Test the algorithm
# Create a BST
root = TreeNode(10)
root.left = TreeNode(5)
root.right = TreeNode(15)
root.left.left = TreeNode(2)
root.left.right = TreeNode(7)
root.right.left = TreeNode(12)
root.right.right = TreeNode(17)

# Find the maximum element
maxElement = findMaxElement(root)
print("Maximum element in the BST:", maxElement)  # Output: Maximum element in the BST: 17


def remove_extremes(input_string):
    # Step 1: Split the input string into individual numbers
    numbers = input_string.split(", ")

    # Step 2: Convert each number from string to integer
    numbers = [int(num) for num in numbers]

    # Step 3: Sort the numbers in ascending order
    numbers.sort()

    # Step 4: Remove the first two numbers (smallest values) and the last two numbers (largest values)
    numbers = numbers[2:-2]

    # Step 5: Convert the remaining numbers back to strings
    numbers = [str(num) for num in numbers]

    # Step 6: Join the numbers into a string using the comma as the separator
    output_string = ", ".join(numbers)

    # Step 7: Output the resulting string
    return output_string

# Example usage:
input_string = "8, 12, 5, 2, 18, 12, 5, 18"
output_string = remove_extremes(input_string)
print(output_string)


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_of_digits(n):
    return sum(int(digit) for digit in str(n))

prime_number = None
for num in range(11, 100):
    if is_prime(num) and num % 5 == 0:
        prime_number = num
        break

if prime_number:
    digit_sum = sum_of_digits(prime_number)
    print("Prime number:", prime_number)
    print("Sum of digits:", digit_sum)
else:
    print("No prime number found in the given range.")


import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num))+1):
        if num % i == 0:
            return False
    return True

def merge_lists(list1, list2):
    merged_list = []
    
    # Add elements from list1
    for num in list1:
        if num >= 0 and not is_prime(num) and num % 2 == 0:
            merged_list.append(float(num))
    
    # Add elements from list2
    for num in list2:
        if num >= 0 and not is_prime(num) and num % 2 == 0:
            merged_list.append(float(num))
    
    # Sort the merged list
    merged_list.sort()
    
    # Add remaining odd numbers from list1
    for num in list1:
        if num >= 0 and not is_prime(num) and num % 2 != 0:
            merged_list.append(float(num))
    
    # Add remaining odd numbers from list2
    for num in list2:
        if num >= 0 and not is_prime(num) and num % 2 != 0:
            merged_list.append(float(num))
    
    # Ensure the length is within the desired range
    if len(merged_list) < 10:
        merged_list.extend([0.0] * (10 - len(merged_list)))
    elif len(merged_list) > 100:
        merged_list = merged_list[:100]
    
    return merged_list


def reorder_array(arr):
    unique_arr = list(set(arr))
    unique_arr.sort(reverse=True)
    array_sum = sum(unique_arr)
    
    if len(unique_arr) % 2 == 0:
        median = (unique_arr[len(unique_arr)//2] + unique_arr[(len(unique_arr)//2)-1]) / 2
    else:
        median = unique_arr[len(unique_arr)//2]
    
    return unique_arr, array_sum, median

# Example Input
arr = [21, 12, 8, 36, 33, 21, 12, 8, 36, 33]

# Function Call
final_array, array_sum, median = reorder_array(arr)

# Print Output
print("Final Array:", final_array)
print("Sum:", array_sum)
print("Median:", median)


def reverse_string(string):
    words = string.split()  # Split the string into a list of words
    reversed_words = []  # List to store the reversed words
    
    # Iterate over the list of words
    for word in words:
        # Reverse each word using a two-pointer approach
        start = 0
        end = len(word) - 1
        word_list = list(word)  # Convert the word to a list of characters
        
        # Swap characters at the two pointers until they meet in the middle
        while start < end:
            word_list[start], word_list[end] = word_list[end], word_list[start]
            start += 1
            end -= 1
        
        # Add the reversed word to the list
        reversed_words.append(''.join(word_list))
    
    # Join the reversed words using a space as the delimiter
    reversed_string = ' '.join(reversed_words)
    return reversed_string


# Example usage
input_string = "Hello World, how are you?"
reversed_string = reverse_string(input_string)
print(reversed_string)


def calculate_median(array):
    sorted_array = sorted(array)
    length = len(sorted_array)
    
    if length % 2 == 1:
        return sorted_array[length // 2]
    else:
        mid1 = sorted_array[length // 2]
        mid2 = sorted_array[length // 2 - 1]
        return (mid1 + mid2) / 2

# Test case
array = [3, 5, 4, 1, -7, 4, -3]
median = calculate_median(array)
print("Median:", median)


import re

def count_words(string):
    # Remove punctuation marks and special characters
    string = re.sub(r'[^\w\s]', '', string)

    # Split the string into words
    words = string.split()

    # Count the occurrences of each word
    word_count = {}
    for word in words:
        # Consider only words that are at least three characters long
        if len(word) >= 3:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

    return word_count

string = "I have 2 apples and 3 bananas. Apples are delicious, and so are bananas!"
word_count = count_words(string)
print(word_count)


def minimum_working_time(jobs, k):
    max_job = max(jobs)
    sum_jobs = sum(jobs)
    
    left, right = max_job, sum_jobs
    while left < right:
        mid = left + (right - left) // 2
        count, current_sum = 1, 0

        for job in jobs:
            if current_sum + job > mid:
                count += 1
                current_sum = 0
            current_sum += job

        if count <= k:
            right = mid
        else:
            left = mid + 1

    return left


import heapq

class SeatManager:
    def __init__(self, n: int):
        self.available_seats = [i for i in range(1, n + 1)]
        heapq.heapify(self.available_seats)

    def reserve(self) -> int:
        return heapq.heappop(self.available_seats)

    def unreserve(self, seatNumber: int) -> None:
        heapq.heappush(self.available_seats, seatNumber)


import math

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

def get_prime_numbers(input_list):
    if not isinstance(input_list, list) or any(not isinstance(num, int) or num <= 0 for num in input_list):
        raise TypeError("Input must be a list of positive integers")

    return [num for num in input_list if is_prime(num)]


def factorial(n):
    # Base case: 0! = 1
    if n == 0:
        return 1
    # Recursive case: n! = n * (n-1)!
    else:
        return n * factorial(n-1)


# Function to check if a number is prime
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Create the array of integers ranging from -50 to 50
arr = list(range(-50, 51))

# Filter and print the prime numbers in reverse order
prime_numbers = [num for num in arr if is_prime(num)]
prime_numbers.reverse()
print(prime_numbers)


import re

def repeat_characters(string, n):
    # Remove special characters and numbers from the string
    string = re.sub('[^A-Za-z]', '', string)
    
    # Remove duplicate characters
    string = ''.join(set(string))
    
    # Repeat each character n times
    repeated_string = ''.join([char * n for char in string])
    
    return repeated_string


import random

def generate_numbers(N):
    if N < 0:
        return []
    elif N > 100:
        print("N should be less than or equal to 100.")
        return []
    
    numbers = []
    for i in range(N):
        num = random.randint(0, 100)
        while num in numbers:
            num = random.randint(0, 100)
        numbers.append(num)
    
    numbers.sort()
    return numbers


import random

def generate_password(N):
    possible_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?"
    password = ""
    counter = 0

    while counter < N:
        index = random.randint(0, len(possible_chars) - 1)
        char = possible_chars[index]

        if char in password or (counter > 0 and ord(char) == ord(password[counter - 1]) + 1):
            continue

        password += char
        counter += 1

    return password


def transform_list_to_dict(numbers):
    # Remove duplicates and sort the list
    numbers = sorted(list(set(numbers)))
    
    # Create an empty dictionary
    result = {}
    
    # Iterate through the numbers
    for num in numbers:
        # Check if the number is divisible by 2
        if num % 2 == 0:
            # Calculate the square of the number and add it to the dictionary
            result[num] = num ** 2
    
    return result


def get_factors(num):
    factors = []
    for i in range(2, num):
        if num % i == 0:
            factors.append(i)
    return factors


def count_specific_value(array, specific_value):
    count = 0
    for element in array:
        if element == specific_value:
            count += 1
    return count


import random

def generate_random_string():
    consonants = 'bcdfghjklmnpqrstvwxyz'
    string = ''
    
    while len(string) < 5:
        letter = random.choice(consonants)
        
        if len(string) == 0 or string[-1] != letter:
            string += letter
    
    return string


def merge_lists(list1, list2):
    merged_list = list1 + list2
    merged_list.sort(reverse=True)
    return merged_list


from typing import List

class Student:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
        self.grades = {}
    
    def set_grades(self, math: float, science: float, english: float):
        self.grades['math'] = math
        self.grades['science'] = science
        self.grades['english'] = english
    
    def get_average_grade(self) -> float:
        total = sum(self.grades.values())
        return total / len(self.grades)
    
    def is_passing(self) -> bool:
        average_grade = self.get_average_grade()
        return average_grade >= 60
    
    def get_details(self) -> str:
        average_grade = self.get_average_grade()
        return f"Name: {self.name}, Age: {self.age}, Average Grade: {average_grade}"
    
    def add_subject(self, subject: str):
        self.grades[subject] = None
    
    def remove_subject(self, subject: str):
        del self.grades[subject]
    
    def get_subjects(self) -> List[str]:
        return list(self.grades.keys())

# Erroneous code
student = Student("John", 18)
student.set_grades(70, 80, 90)
student.get_subjects().append("history")
print(student.get_subjects())  # Output: ['math', 'science', 'english', 'history']


import random

def create_matrix(n):
    matrix = [[random.randint(1, 10) for _ in range(n)] for _ in range(n)]
    matrix_sum = sum(sum(row) for row in matrix)
    return matrix, matrix_sum


def is_palindrome(string):
    # Convert the string to lowercase for case-insensitive comparison
    string = string.lower()
    
    # Define two pointers, one starting from the beginning and the other from the end of the string
    left = 0
    right = len(string) - 1
    
    # Compare characters from the beginning and the end of the string
    while left < right:
        # If the characters at both pointers are not equal, the string is not a palindrome
        if string[left] != string[right]:
            return False
        
        # Move the pointers towards the center of the string
        left += 1
        right -= 1
    
    # If all characters have been compared and they are equal, the string is a palindrome
    return True


from math import acos, cos, sin, sqrt

def max_number_of_darts(darts, r):
    n = len(darts)
    max_darts = 1

    for i in range(n):
        for j in range(i + 1, n):
            dist = sqrt((darts[j][0] - darts[i][0])**2 + (darts[j][1] - darts[i][1])**2)
            if dist > 2.0 * r: continue

            angle = acos(dist / (2.0 * r))
            for k in range(2):
                loc_angle = angle * (1 if k == 0 else -1)
                cx = darts[i][0] + r * (darts[j][0] - darts[i][0]) / dist * cos(loc_angle) - r * (darts[j][1] - darts[i][1]) / dist * sin(loc_angle)
                cy = darts[i][1] + r * (darts[j][0] - darts[i][0]) / dist * sin(loc_angle) + r * (darts[j][1] - darts[i][1]) / dist * cos(loc_angle)

                cnt = 0
                for l in range(n):
                    new_dist = sqrt((darts[l][0] - cx)**2 + (darts[l][1] - cy)**2)
                    if new_dist <= r + 1e-5: cnt += 1

                max_darts = max(max_darts, cnt)

    return max_darts


def is_anagram(s1, s2):
    # Initialize a dictionary to store the frequency of characters in s1
    freq_dict = {}
    
    # Calculate the frequency of each character in s1
    for char in s1:
        if char in freq_dict:
            freq_dict[char] += 1
        else:
            freq_dict[char] = 1
    
    # Check if the frequency of characters in s2 matches the frequency in s1
    for char in s2:
        if char in freq_dict:
            freq_dict[char] -= 1
        else:
            return False
    
    # Check if all characters in s1 have been accounted for
    for count in freq_dict.values():
        if count != 0:
            return False
    
    # Check if there are any characters in s1 that are not in s2
    if len(s1) != len(s2):
        return False
    
    return True


def sum_odd_indexed_items(*args):
    odd_indexed_sum = 0
    odd_indices = []

    for arg in args:
        if isinstance(arg, list) and len(arg) % 2 != 0:
            for i, item in enumerate(arg):
                if i % 2 != 0 and item not in arg[:i]:
                    odd_indexed_sum += max(0, item)
                    odd_indices.append(i)

    return odd_indexed_sum, odd_indices


import re

text = "The dog ran away, but the cat1 stayed and the cat2 came back."
pattern = r"cat[0-9]*[1-9](?![0-9]*[3-9])"
matches = re.findall(pattern, text)
print(matches)


def get_largest_sum(num_list):
    # Initialize the largest sum to be the sum of the first two numbers in the list
    largest_sum = num_list[0] + num_list[1]

    # Iterate through the list starting from the third number
    for i in range(2, len(num_list)):
        # Check if the sum of the current number and the largest sum so far is greater than the current largest sum
        if num_list[i] + largest_sum > largest_sum:
            # Update the largest sum if the condition is met
            largest_sum = num_list[i] + largest_sum

    return largest_sum

num_list = [10, 20, 30, 40, 50]
result = get_largest_sum(num_list)
print(result)


def count_occurrences(text):
    occurrences = {}
    for char in text:
        if char.isalnum():
            if char in occurrences:
                occurrences[char] += 1
            else:
                occurrences[char] = 1
    return {k: v for k, v in sorted(occurrences.items(), key=lambda item: ord(item[0]))}


class PrimeNumberIterator:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def is_prime(self, num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    def __iter__(self):
        self.num = self.start
        return self

    def __next__(self):
        while self.num <= self.end:
            if self.is_prime(self.num):
                prime_num = self.num
                self.num += 1
                return prime_num
            self.num += 1
        raise StopIteration


prime_iterator = PrimeNumberIterator(1, 100)
for prime in prime_iterator:
    print(prime)


def cell_range(s):
    r1 = int(s[1])
    r2 = int(s[4])
    c1 = ord(s[0]) - ord('A') + 1
    c2 = ord(s[3]) - ord('A') + 1

    res = []
    for c in range(c1, c2 + 1):
        for r in range(r1, r2 + 1):
            res.append(chr(ord('A') + c - 1) + str(r))
    return res


def xor_binary_numbers(num1, num2):
    # Make sure both binary numbers have the same length
    max_length = max(len(num1), len(num2))
    num1 = num1.zfill(max_length)
    num2 = num2.zfill(max_length)

    # Perform XOR operation
    result = ''
    for i in range(max_length):
        if num1[i] != num2[i]:
            result += '1'
        else:
            result += '0'

    return result


import math

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

def remove_duplicates(arr):
    unique_arr = list(set(arr))
    primes = []
    for num in unique_arr:
        if is_prime(num):
            primes.append(num)
    primes.sort()
    return primes

arr = [1, 2, 3, 3, 4, 4, 5, 6]
result = remove_duplicates(arr)
print(result)


def find_divisible_numbers(numbers):
    count = {}
    divisible_nums = []

    for num in numbers:
        if num % 3 == 0 and num % 7 == 0:
            divisible_nums.append(num)
            if num not in count:
                count[num] = 1
            else:
                count[num] += 1

    divisible_nums = sorted(divisible_nums)
    average = sum(divisible_nums) / len(divisible_nums)
    minimum = min(divisible_nums)
    maximum = max(divisible_nums)

    print("Average:", average)
    print("Minimum:", minimum)
    print("Maximum:", maximum)

    for num, occurrences in count.items():
        print("Number", num, "occurs", occurrences, "time(s)")

# Example usage:
numbers = [21, 7, 42, 14, 9, 63, 35, 18, 49, 6]
find_divisible_numbers(numbers)


import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def is_fibonacci(num):
    a, b = 0, 1
    while b < num:
        a, b = b, a + b
    return b == num

def has_perfect_square_root(num):
    sqrt = math.isqrt(num)
    return sqrt * sqrt == num

def is_divisible_by_5(num):
    return num % 5 == 0

def separate_arrays(nums):
    prime_nums = []
    fibonacci_nums = []
    perfect_square_nums = []
    divisible_by_5_nums = []

    for num in nums:
        if is_prime(num):
            prime_nums.append(num)
        if is_fibonacci(num):
            fibonacci_nums.append(num)
        if has_perfect_square_root(num):
            perfect_square_nums.append(num)
        if is_divisible_by_5(num):
            divisible_by_5_nums.append(num)

    prime_nums.sort(reverse=True)
    fibonacci_nums.sort()
    perfect_square_nums.sort()
    divisible_by_5_nums.sort()

    return prime_nums, fibonacci_nums, perfect_square_nums, divisible_by_5_nums

# Test case
nums = [9, 4, 57, 28, 24, 10, 3, 5, 16, 33]
prime_nums, fibonacci_nums, perfect_square_nums, divisible_by_5_nums = separate_arrays(nums)

print("Prime numbers:", prime_nums)
print("Fibonacci numbers:", fibonacci_nums)
print("Numbers with perfect square roots:", perfect_square_nums)
print("Numbers divisible by 5:", divisible_by_5_nums)


def validate_integer(string):
    if len(string) == 0:
        return False

    string = string.strip()
    if len(string) > 10:
        return False

    if string[0] == '+' or string[0] == '-':
        string = string[1:]

    if len(string) == 0:
        return False

    if string[0] == '0' and len(string) > 1:
        return False

    for char in string:
        if not char.isdigit():
            return False

    return True


def binary_search(secret_number):
    low = 1
    high = 1000
    guesses = 0

    while low <= high:
        mid = (low + high) // 2
        guesses += 1

        if mid == secret_number:
            return guesses
        elif mid < secret_number:
            low = mid + 1
        else:
            high = mid - 1

    return -1  # If the secret number is not found, return -1

# Generate a random secret number between 1 and 1000
import random
secret_number = random.randint(1, 1000)

print("Guessing the secret number between 1 and 1000...")
guesses = binary_search(secret_number)
print(f"The secret number is {secret_number} and it took {guesses} guesses to find it.")


class EqualNumbersException(Exception):
    pass

def max_of_two_numbers(a, b):
    if a == b:
        raise EqualNumbersException("The numbers are equal")

    return max(a, b)


import numpy as np

def mean(arr):
    n = len(arr)
    if n == 0:
        return None
    sum = 0
    for num in arr:
        sum += num
    return sum / n

arr = [1, 2, 3, 4, 5]
print(mean(arr))  # Output: 3.0


import re

text = "Device information:\nType: Laptop\nManufacturer: Dell\nSerial Number: 12345\nName: Inspiron 15"

# Search for the device name
match = re.search(r"Name: (.*)", text)
if match:
    # Extract the device name from the match object
    name = match.group(1)
    print("Device name:", name)
else:
    print("Device name not found")


def update_array(arr):
    n = len(arr)
    for i in range(n):
        arr[i] = arr[i] ** 3
    return arr


def find_max_number(numbers):
    if len(numbers) == 0:
        return "List is empty."
    
    max_number = float('-inf')
    for num in numbers:
        if num > max_number:
            max_number = num
    
    return max_number


import datetime
import hashlib

def generate_response(sentence):
    unique_id = datetime.datetime.now().strftime("%Y-%m-%d_%H:%M:%S")
    encoded_sentence = sentence.encode('utf-8')
    hashed_sentence = hashlib.sha256(encoded_sentence).hexdigest()
    response = f"Unique ID: {unique_id}\nResponse: {hashed_sentence}"
    return response


def insert_elements(lst):
    n = len(lst)
    for i in range(n):
        lst.insert(i, "x" + str(n-i))
    return lst

# Test the function
input_lst = ["a", "b", "c", "d"]
output_lst = insert_elements(input_lst)
print(output_lst)


import random
import string

def generate_password():
    # Define the required number of each character type
    required_uppercase = 4
    required_special = 4
    required_numbers = 4

    # Define all possible characters
    uppercase_letters = string.ascii_uppercase
    lowercase_letters = string.ascii_lowercase
    special_symbols = string.punctuation
    numbers = string.digits

    # Generate random characters for each character type
    uppercase = random.sample(uppercase_letters, required_uppercase)
    special = random.sample(special_symbols, required_special)
    numbers = random.sample(numbers, required_numbers)
    lowercase = random.sample(lowercase_letters, 20 - required_uppercase - required_special - required_numbers)

    # Combine all characters
    password = uppercase + special + numbers + lowercase

    # Shuffle the password to make it random
    random.shuffle(password)

    # Convert the password list to a string
    password = ''.join(password)

    return password

# Generate a random password
password = generate_password()
print(password)


arr = [3, 9, 15, 21, 27]

for i in range(len(arr)-1, -1, -1):
    if arr[i] % 2 == 1 and arr[i] % 3 == 0:
        print(arr[i])


def permute(s):
    # Convert the string to a list to make it mutable
    s = list(s)
    # Sort the string in lexicographically increasing order
    s.sort()
    # Initialize an empty list to store the permutations
    result = []
    
    # Define a recursive helper function to generate permutations
    def backtrack(start):
        # If we have reached the end of the string, add it to the result list
        if start == len(s):
            result.append(''.join(s))
            return
        
        # Iterate through all possible characters to place at the current position
        for i in range(start, len(s)):
            # Skip duplicates
            if i > start and s[i] == s[i-1]:
                continue
            
            # Place the current character at the current position
            s[start], s[i] = s[i], s[start]
            
            # Recursively generate permutations for the remaining positions
            backtrack(start + 1)
            
            # Backtrack by swapping the characters back to their original positions
            s[start], s[i] = s[i], s[start]
    
    # Call the helper function to generate permutations
    backtrack(0)
    
    return result


def generate_prime_numbers(start, end):
    # Step 1
    isPrime = [True] * (end + 1)
    
    # Step 2
    p = 2
    
    # Step 3
    while p * p <= end:
        if isPrime[p]:
            for i in range(p * p, end + 1, p):
                isPrime[i] = False
        p += 1
    
    # Step 4
    primes = []
    for i in range(start, end + 1):
        # Step 5
        if i >= 2 and isPrime[i]:
            primes.append(i)
    
    # Step 6
    return primes


def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def sum_of_primes(n):
    if n < 2:
        print("No prime numbers up to", n)
        return
    primes = [2]
    prime_sum = 2
    for num in range(3, n + 1, 2):
        if is_prime(num):
            primes.append(num)
            prime_sum += num
    print("Sum of prime numbers up to", n, ":", prime_sum)


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def distance_to_origin(self):
        return ((self.x - 0)**2 + (self.y - 0)**2)**0.5
    
    def distance_to_point(self, point):
        return ((self.x - point.x)**2 + (self.y - point.y)**2)**0.5
    
    def is_collinear(self, point1, point2):
        slope1 = (self.y - point1.y) / (self.x - point1.x)
        slope2 = (self.y - point2.y) / (self.x - point2.x)
        return slope1 == slope2
    
    def is_within_triangle(self, point1, point2, point3):
        def orientation(p1, p2, p3):
            return (p2.y - p1.y) * (p3.x - p2.x) - (p2.x - p1.x) * (p3.y - p2.y)

        d1 = orientation(self, point1, point2)
        d2 = orientation(self, point2, point3)
        d3 = orientation(self, point3, point1)
        
        return (d1 >= 0 and d2 >= 0 and d3 >= 0) or (d1 <= 0 and d2 <= 0 and d3 <= 0)
    
    def is_within_circle(self, center, radius):
        return ((self.x - center.x)**2 + (self.y - center.y)**2) <= radius**2


def binary_search(database, target, start, end):
    if start > end:
        return
    
    mid = (start + end) // 2
    username = database[mid]
    
    if target in username:
        matching_usernames.append(username)
    
    if target < username:
        binary_search(database, target, start, mid - 1)
    else:
        binary_search(database, target, mid + 1, end)

# Assuming the database is a list of usernames
database = ["JohnDoe", "johndoe", "JaneJohn", "MaryJohn", "jackson", "MikeJohnson", "Alice"]

target = "John"
matching_usernames = []

# Sort the database
database.sort()

# Perform binary search
binary_search(database, target, 0, len(database) - 1)

# Print the matching usernames
print(matching_usernames)


def generate_sequence(k, n):
    sequence = []
    for i in range(k, n+1):
        sequence.append(i**2)
        sequence.append(i**3)
    return sequence

k = int(input("Enter the starting number (k): "))
n = int(input("Enter the ending number (n): "))

sequence = generate_sequence(k, n)
print(sequence)


import time
def trigger_sequence():
 print("Lights flickering...")
 time.sleep(5)
 print("Curtains billowing...")
 time.sleep(10)
 print("Vase toppling over...")
 time.sleep(2)


def repeat_characters(string, n):
    repeated_string = ""
    for char in string:
        repeated_string += char * n
    return repeated_string


def bubble_sort(lst):
    n = len(lst)
    
    for i in range(n):
        for j in range(0, n-i-1):
            if lst[j] < lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]


import requests
import json
import time
from datetime import datetime, timedelta

API_URL = "https://api.example.com/users"
AUTH_TOKEN = "your-auth-token"
CACHE_EXPIRY = timedelta(minutes=30)
RATE_LIMIT_DELAY = timedelta(seconds=1)

def make_api_call(url, headers=None, params=None):
    response = requests.get(url, headers=headers, params=params)
    if response.status_code == 200:
        return response.json()
    else:
        raise Exception(f"API request failed with status code {response.status_code}")

def get_all_users():
    headers = {"Authorization": f"Bearer {AUTH_TOKEN}"}
    users = []
    page = 1

    while True:
        params = {"page": page}
        response = make_api_call(API_URL, headers=headers, params=params)
        users.extend(response["data"])

        if "next_page" not in response:
            break

        page += 1
        time.sleep(RATE_LIMIT_DELAY.total_seconds())

    return users

def get_user_info(user):
    name = user.get("name")
    age = user.get("age")
    email = user.get("email")
    address = user.get("address")

    if not name or not age or not email or not address:
        raise Exception("Incomplete user data")

    # Validate user attributes
    if not isinstance(name, str):
        raise Exception("Invalid name attribute")

    if not isinstance(age, int) or age <= 0:
        raise Exception("Invalid age attribute")

    if not isinstance(email, str) or "@" not in email:
        raise Exception("Invalid email attribute")

    if not isinstance(address, str):
        raise Exception("Invalid address attribute")

    return {
        "Name": name,
        "Age": age,
        "Email": email,
        "Address": address
    }

def display_user_info(user_info):
    for key, value in user_info.items():
        print(f"{key}: {value}")
    print()

def main():
    # Check cache
    cache_data = read_cache()
    if cache_data and cache_data["expiry"] > datetime.now():
        users = cache_data["users"]
    else:
        users = get_all_users()
        write_cache(users)

    for user in users:
        try:
            user_info = get_user_info(user)
            display_user_info(user_info)
        except Exception as e:
            print(f"Error: {str(e)}")

def read_cache():
    # Read cache data from file or database
    pass

def write_cache(users):
    cache_data = {
        "users": users,
        "expiry": datetime.now() + CACHE_EXPIRY
    }
    # Write cache data to file or database
    pass

if __name__ == "__main__":
    main()


import math
a = 5
b = 7
c = 10
s = (a + b + c) / 2
area = math.sqrt(s * (s - a) * (s - b) * (s - c))
print("The area of the triangle is:", area)


import json

def print_names(data):
    if isinstance(data, dict):
        if 'age' in data and data['age'] > 30:
            print(data['name'].upper())
        for value in data.values():
            print_names(value)
    elif isinstance(data, list):
        for item in data:
            print_names(item)

# JSON string
json_string = '''
{
    "name": "John",
    "age": 35,
    "children": [
        {
            "name": "Alice",
            "age": 28
        },
        {
            "name": "Bob"
        },
        {
            "name": "Charlie",
            "age": 42
        }
    ]
}
'''

# Parse the JSON string
data = json.loads(json_string)

# Print names of objects where age is greater than 30
print_names(data)


import math

def generate_primes(n):
    primes = []
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False

    for i in range(2, int(math.sqrt(n)) + 1):
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False

    for i in range(n, 1, -1):
        if is_prime[i]:
            primes.append(i)

    return primes


def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # Swap if the current element is smaller than the next element
            if arr[j] < arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

# Given array
arr = [8, 6, 7, 5, 4, 3, 1]

# Sort the array in descending order
bubble_sort(arr)

# Print the sorted array
print("Sorted array in descending order:", arr)


def sum_of_cube_even_numbers(n):
    if not isinstance(n, int) or n < 0:
        raise ValueError("Input must be a positive integer")

    sum_of_cubes = 0
    for num in range(2, n+1, 2):
        sum_of_cubes += num**3

    return sum_of_cubes


for num in range(1, 101):
    if num % 3 != 0 and num % 5 != 0:
        square = num ** 2
        print(square)


def reverse_string(string):
    # convert the string to a list of characters
    string_list = list(string)
    
    # get the length of the string
    length = len(string)
    
    # reverse the characters in-place
    for i in range(length // 2):
        string_list[i], string_list[length - i - 1] = string_list[length - i - 1], string_list[i]
    
    # convert the list of characters back to a string
    reversed_string = ''.join(string_list)
    
    return reversed_string


MOD = 10**9 + 7

def corridor_ways(corridor):
    n = len(corridor)
    dp = [0] * (n + 1)
    dp[0] = 1

    seats = 0
    for i in range(n):
        if corridor[i] == 'S':
            seats += 1
            if seats % 2 == 0:
                dp[i + 1] = dp[max(0, i - 1)]
            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD
        else:
            dp[i + 1] = dp[i]

    return dp[n]


class Student:
    def __init__(self, name, grade, age):
        self.name = name
        self.grade = grade
        self.age = age


class School:
    def __init__(self, name):
        self.name = name
        self.students = []

    def add_student(self, student):
        self.students.append(student)

    def remove_student(self, student):
        self.students.remove(student)

    def get_students_in_grade(self, grade):
        return [student for student in self.students if student.grade == grade]

    def get_students_by_age(self, min_age, max_age):
        return [student for student in self.students if min_age <= student.age <= max_age]

    def calculate_average_grade(self):
        valid_students = [student for student in self.students if student.grade >= 60]
        if valid_students:
            total = sum([student.grade for student in valid_students])
            return total / len(valid_students)
        return 0

    def get_student_with_highest_grade(self):
        sorted_students = sorted(self.students, key=lambda student: student.grade, reverse=True)
        return sorted_students[:3]


# Create an instance of the School class
school = School("ABC School")

# Create multiple instances of the Student class
student1 = Student("John", 80, 16)
student2 = Student("Emma", 90, 15)
student3 = Student("Michael", 75, 16)
student4 = Student("Sophia", 95, 14)
student5 = Student("William", 70, 15)

# Add students to the school
school.add_student(student1)
school.add_student(student2)
school.add_student(student3)
school.add_student(student4)
school.add_student(student5)

# Calculate the average grade of the students in the school
average_grade = school.calculate_average_grade()
print("Average Grade:", average_grade)

# Get the student with the highest grade in the school
top_students = school.get_student_with_highest_grade()
print("Top Students:")
for student in top_students:
    print(student.name, "-", student.grade)

# Get students in a specific grade level
grade_15_students = school.get_students_in_grade(15)
print("Grade 15 Students:")
for student in grade_15_students:
    print(student.name)

# Get students within a specific age range
age_14_to_16_students = school.get_students_by_age(14, 16)
print("Students aged 14 to 16:")
for student in age_14_to_16_students:
    print(student.name)


for num in range(2, 101):
    is_prime = True

    if num == 2 or num == 3:
        continue

    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            is_prime = False
            break

    if is_prime:
        print(num)


def calculate_sum(array, N, M, K):
    # Calculate the sum of N even numbers
    sum_of_numbers = N * (2 + 2 * N) / 2
    
    # Calculate the total sum
    total_sum = sum_of_numbers + M
    
    # Check if total sum is greater than K
    if total_sum > K:
        return total_sum
    else:
        return "Not possible"

# Example usage
array = [2, 4, 6, 8, 10]
N = 5
M = 7
K = 30

print(calculate_sum(array, N, M, K))


def gcd_recursive(n1, n2):
    # Convert negative numbers to positive
    n1 = abs(n1)
    n2 = abs(n2)
    
    # Base case: if one of the numbers is zero, return the other number
    if n1 == 0:
        return n2
    elif n2 == 0:
        return n1
    
    # Recursive case: calculate the GCD using the Euclidean algorithm
    if n1 > n2:
        return gcd_recursive(n1 % n2, n2)
    else:
        return gcd_recursive(n1, n2 % n1)


numbers = [11, 9, 7, 5]
numbers.sort(reverse=True)
largest_number = numbers[0] + numbers[1]

print(largest_number)


def find_closest_pair(arr, num):
    if len(arr) < 2:
        return "Error: Array should have at least 2 elements"
    
    arr.sort()  # Sort the array in ascending order
    closest_pair = (arr[0], arr[1])  # Initialize the closest pair with first two elements
    
    # Iterate through the array to find the closest pair
    for i in range(len(arr)-1):
        curr_pair = (arr[i], arr[i+1])
        
        # If the given number is between the pair, return the pair
        if arr[i] <= num <= arr[i+1]:
            return curr_pair
        
        # If the pair is closer to the given number than the current closest pair
        if abs(sum(curr_pair) - num) < abs(sum(closest_pair) - num):
            closest_pair = curr_pair
    
    return closest_pair

# Test the function
arr = [3, 6, 9, 12, 15]
num = 10
result = find_closest_pair(arr, num)
print("Closest pair:", result)


def reverse_array(arr):
    for i in range(len(arr) - 1, -1, -1):
        print(arr[i])


def max_chosen_integers(banned, n, max_sum):
    banned_set = set(banned)
    count = 0
    total_sum = 0
    for i in range(n, 0, -1):
        if i not in banned_set and max_sum - total_sum >= i:
            total_sum += i
            count += 1
    return count


def merge_sort_tuples(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    left_half = lst[:mid]
    right_half = lst[mid:]

    left_half = merge_sort_tuples(left_half)
    right_half = merge_sort_tuples(right_half)

    return merge_tuples(left_half, right_half)


def merge_tuples(left_half, right_half):
    merged = []
    i = 0
    j = 0

    while i < len(left_half) and j < len(right_half):
        if left_half[i][0] <= right_half[j][0]:
            merged.append(left_half[i])
            i += 1
        else:
            merged.append(right_half[j])
            j += 1

    while i < len(left_half):
        merged.append(left_half[i])
        i += 1

    while j < len(right_half):
        merged.append(right_half[j])
        j += 1

    return merged


# Usage example:
tuples_list = [(3, 'b'), (2, 'c'), (3, 'a'), (1, 'd')]
sorted_list = merge_sort_tuples(tuples_list)
print(sorted_list)


def minimizeTheDifference(mat, target):
    m, n = len(mat), len(mat[0])
    dp, new_dp = [1] + [0] * 4900, [0] * 4901
    for i in range(m):
        for j in range(n):
            for k in range(4900 - mat[i][j] + 1):
                new_dp[k + mat[i][j]] |= dp[k]
        dp, new_dp = new_dp, [0] * 4901
    for i in range(4901):
        if dp[i]:
            return abs(target - i)
    return float('inf')


class InvalidDayError(Exception):
    pass

class Day:
    DAYS_OF_WEEK = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    PUBLIC_HOLIDAYS = ['New Year\'s Day', 'Christmas Day']

    instances = 0

    def __init__(self, day_name):
        if day_name not in self.DAYS_OF_WEEK:
            raise InvalidDayError(f'Invalid day name: {day_name}')
        self._day_name = day_name
        self.__class__.instances += 1

    def get_day_name(self):
        return self._day_name

    def is_weekend(self):
        return self._day_name in ['Saturday', 'Sunday']

    def is_weekday(self):
        return self._day_name in ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']

    def is_public_holiday(self):
        if self._day_name not in self.DAYS_OF_WEEK:
            raise InvalidDayError(f'Invalid day: {self._day_name}')
        return self._day_name in self.PUBLIC_HOLIDAYS

    @classmethod
    def get_instance_count(cls):
        return cls.instances


# Example usage
try:
    day1 = Day('Monday')
    print(day1.get_day_name())  # Output: Monday
    print(day1.is_weekend())  # Output: False
    print(day1.is_weekday())  # Output: True
    print(day1.is_public_holiday())  # Output: False

    day2 = Day('Saturday')
    print(day2.get_day_name())  # Output: Saturday
    print(day2.is_weekend())  # Output: True
    print(day2.is_weekday())  # Output: False
    print(day2.is_public_holiday())  # Output: False

    day3 = Day('InvalidDay')  # Raises InvalidDayError
except InvalidDayError as e:
    print(e)

print(Day.get_instance_count())  # Output: 2


import re

def split_string(string, separator):
    # Split the string based on the separator, but preserve the separator within quotes
    regex = r'"[^"]*"|[^' + re.escape(separator) + ']+'
    substrings = re.findall(regex, string)
    
    # Remove any leading or trailing whitespace from each substring
    substrings = [substring.strip() for substring in substrings]
    
    return substrings


def get_number():
    number = int(input("Please enter an integer number greater than 1 and less than 100, divisible by 3: "))
    while number <= 1 or number >= 100 or number % 3 != 0:
        number = int(input("Invalid input! Please enter an integer number greater than 1 and less than 100, divisible by 3: "))
    return number

def calculate_sum(number):
    total = 0
    for i in range(1, number):
        total += i
    return total

number = get_number()
sum_of_numbers = calculate_sum(number)
print(f"The sum of all preceding numbers from 1 to {number - 1} is {sum_of_numbers}.")


import re

text = "Device information:\nType: Laptop\nManufacturer: Dell\nSerial Number: 12345\nName: Inspiron 15"

# Search for the device name
match = re.search(r"Name: (.*)", text)
if match:
    # Extract the device name from the match object
    name = match.group(1)
    print("Device name:", name)
else:
    print("Device name not found")


def sum_of_odd_cubes(nums):
    odd_cubes_sum = 0
    for num in nums:
        if num % 2 != 0:
            odd_cubes_sum += num ** 3
    return odd_cubes_sum


def find_divisible_numbers(numbers):
    divisible_numbers = [num for num in numbers if num % 3 == 0 and num < 100]
    sum_of_divisible_numbers = sum(divisible_numbers)
    count_of_divisible_numbers = len(divisible_numbers)
    
    return sum_of_divisible_numbers, count_of_divisible_numbers


# Example usage
input_list = [1, 5, 9, 12, 15, 20, 33, 50, 60, 75, 90, -6, -9, -18, -27]
sum_of_divisible_numbers, count_of_divisible_numbers = find_divisible_numbers(input_list)

print("Sum of divisible numbers:", sum_of_divisible_numbers)
print("Count of divisible numbers:", count_of_divisible_numbers)


def is_divisible(num, divisor):
    while num >= divisor:
        num -= divisor
    return num == 0

for i in range(1, 101):
    if is_divisible(i, 15):
        print("FizzBuzz")
    elif is_divisible(i, 3):
        print("Fizz")
    elif is_divisible(i, 5):
        print("Buzz")
    else:
        print(i)


def count_unique_characters(string):
    unique_chars = set()
    for char in string:
        if char.isalnum():
            unique_chars.add(char)
    return len(unique_chars)

# Prompt the user for a string
string = input("Enter a string: ")

# Count the number of unique alphanumeric characters
count = count_unique_characters(string)

# Print the result
print("Number of unique alphanumeric characters:", count)


def reverse_string(string):
    length = 0
    while string[length:]:  # loop until the substring is empty
        length += 1

    index = length - 1  # initialize index to the last character
    while index >= 0:  # loop until index is less than 0
        char = string[index]
        print(char, end="")
        index -= 1

# Example usage
reverse_string("Hello, World!")  # Output: "!dlroW ,olleH"


# Initializing a dictionary with key-value pairs
student_scores = {
    "John": 90,
    "Jane": 85,
    "Alex": 95,
    "Sarah": 88
}

# Accessing values using keys
print(student_scores["John"])  # Output: 90
print(student_scores["Sarah"])  # Output: 88


from collections import defaultdict

def helper(node, counts):
    if not node: return 0
    val = node.val + helper(node.left, counts) + helper(node.right, counts)
    counts[val] += 1
    return val

def findFrequentTreeSum(root):
    counts = defaultdict(int)
    helper(root, counts)
    max_count = max(counts.values(), default=0)
    return [s for s, c in counts.items() if c == max_count]


import requests
import string
import random

def make_api_call(url, header_name, header_value):
    headers = {header_name: header_value}
    response = requests.get(url, headers=headers)
    return response.content.decode('utf-8')

def generate_random_string(length):
    characters = string.ascii_letters + string.digits
    return ''.join(random.choice(characters) for _ in range(length))

# Example usage
url = "https://example.com/api"
header_name = "X-Custom-Header"
header_value = generate_random_string(10)

response_content = make_api_call(url, header_name, header_value)
print(response_content)


def count_occurrences(arr, target, lengthThreshold):
    count = 0  # Variable to store the count of occurrences

    # Base case 1: If the given array is empty, return 0
    if len(arr) == 0:
        return 0

    # Base case 2: If the current sub-array's length is less than or equal to lengthThreshold, skip it
    if len(arr[0]) <= lengthThreshold:
        return count_occurrences(arr[1:], target, lengthThreshold)

    # Recursive case: If the current sub-array's length is greater than lengthThreshold
    for element in arr[0]:
        if element == target:
            count += 1

    # Recursive call: Count occurrences in the remaining sub-arrays
    count += count_occurrences(arr[1:], target, lengthThreshold)

    return count


def filter_strings(data, n):
    result = []
    for string in data:
        if len(string) > n and any(char.isupper() for char in string):
            result.append(string)
    return result


def find_max_difference_pair(A):
    A.sort()  # Sort the array in non-decreasing order
    min_element = A[0]  # Initialize min_element to the first element
    max_element = A[-1]  # Initialize max_element to the last element

    for i in range(1, len(A)-1):
        if A[i] < min_element:
            min_element = A[i]
        if A[i] > max_element:
            max_element = A[i]

    return [min_element, max_element]

# Test the solution
A = [4, 2, 1, 7, 5, 9]
print(find_max_difference_pair(A))  # Output: [1, 9]


def find_max_min(arr):
    max_val = arr[0]
    min_val = arr[0]

    for i in range(1, len(arr)):
        if arr[i] > max_val:
            max_val = arr[i]
        if arr[i] < min_val:
            min_val = arr[i]

    return max_val, min_val


def generate_permutations(string):
    if len(string) <= 1:
        return [string]

    permutations = []
    for i in range(len(string)):
        char = string[i]
        remaining_string = string[:i] + string[i+1:]
        sub_permutations = generate_permutations(remaining_string)

        for sub_permutation in sub_permutations:
            new_permutation = char + sub_permutation
            if new_permutation not in permutations:
                permutations.append(new_permutation)

    return sorted(permutations)

def longest_common_subsequence(string1, string2):
    if len(string1) == 0 or len(string2) == 0:
        return ""
    if string1[0] == string2[0]:
        return string1[0] + longest_common_subsequence(string1[1:], string2[1:])
    else:
        lcs1 = longest_common_subsequence(string1, string2[1:])
        lcs2 = longest_common_subsequence(string1[1:], string2)
        return lcs1 if len(lcs1) > len(lcs2) else lcs2

def find_lcs_of_permutations(string):
    permutations = generate_permutations(string)
    lcs = ""
    for i in range(len(permutations)):
        for j in range(i+1, len(permutations)):
            current_lcs = longest_common_subsequence(permutations[i], permutations[j])
            if len(current_lcs) > len(lcs):
                lcs = current_lcs
    return lcs

string = input("Enter a string: ")
permutations = generate_permutations(string)
print("Permutations:")
for permutation in permutations:
    print(permutation)
lcs = find_lcs_of_permutations(string)
print("Longest Common Subsequence: " + lcs)


import json

# Assuming you have the JSON data stored in a variable named 'data'
data = {
    "outerObj": {
        "innerObj": {
            "nestedArray": [1, 2, 3, 4, 5]
        }
    }
}

# Convert the JSON object to a dictionary
data_dict = json.loads(json.dumps(data))

# Access the third element of the nested array within the nested object
third_element = data_dict['outerObj']['innerObj']['nestedArray'][2]

# Print the retrieved data
print(third_element)


def round_robin(processes, time_slice):
    queue = processes.copy()
    while queue:
        process = queue.pop(0)
        process_id, execution_time, priority, max_execution_time = process
        if execution_time <= time_slice:
            print(f"Process {process_id} (ID: {process_id}) executed for {execution_time} units of time.")
        else:
            print(f"Process {process_id} (ID: {process_id}) executed for {time_slice} units of time.")
            execution_time -= time_slice
            if execution_time > max_execution_time:
                print(f"Process {process_id} (ID: {process_id}) terminated due to exceeding maximum allowed execution time.")
                continue
            process = (process_id, execution_time, priority, max_execution_time)
            queue.append(process)
        queue.sort(key=lambda x: x[2])  # Sort queue based on priority


import random
import string

def generate_password():
    # Define the character sets
    lowercase_letters = string.ascii_lowercase
    uppercase_letters = string.ascii_uppercase
    special_characters = string.punctuation
    digits = string.digits
    
    # Create a list of character sets to choose from
    character_sets = [lowercase_letters, uppercase_letters, special_characters, digits]
    
    # Generate a random length for the password between 10 and 20 characters
    password_length = random.randint(10, 20)
    
    # Initialize an empty password string
    password = ""
    
    # Choose one character randomly from each character set
    for char_set in character_sets:
        password += random.choice(char_set)
        
    # Fill the remaining characters randomly from any character set
    for _ in range(4, password_length):
        char_set = random.choice(character_sets)
        
        # Generate a random character from the chosen character set
        char = random.choice(char_set)
        
        # Check if adding the character violates the consecutive repeating characters rule
        if char == password[-1]:
            # Generate a new character until it is different from the last one
            while char == password[-1]:
                char = random.choice(char_set)
        
        # Check if adding the character violates the consecutive characters rule
        if len(password) >= 2 and ord(char) == ord(password[-1]) + 1 == ord(password[-2]) + 2:
            # Generate a new character until it breaks the sequence
            while ord(char) == ord(password[-1]) + 1 == ord(password[-2]) + 2:
                char = random.choice(char_set)
        
        # Add the character to the password
        password += char
    
    # Shuffle the password string to make it more random
    password = ''.join(random.sample(password, len(password)))
    
    return password

# Generate a random password
password = generate_password()

# Print the generated password
print(password)


def find_two_largest(numbers):
    if len(numbers) < 2:
        return "Error: List must have at least two elements."
    
    largest = float('-inf')
    second_largest = float('-inf')
    
    for num in numbers:
        if num > largest:
            second_largest = largest
            largest = num
        elif num > second_largest:
            second_largest = num
    
    return largest, second_largest


def is_prime(number):
    if number < 2:  # Numbers less than 2 are not prime
        return False
    
    for i in range(2, int(number**0.5) + 1):
        if number % i == 0:  # If the number is divisible by any number from 2 to sqrt(number), it is not prime
            return False
    
    return True  # If the number is not divisible by any number from 2 to sqrt(number), it is prime


class Person:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age

    def is_teenager(self):
        """
        Checks if the person is a teenager (between the ages of 15 and 19, inclusive).
        Returns True if the person is a teenager, and False otherwise.
        """
        return 15 <= self.age <= 19

    def get_full_name(self):
        """
        Returns the person's full name (including both the first name and last name), separated by a space.
        Time complexity: O(1)
        """
        return f"{self.first_name} {self.last_name}"

    def is_palindrome_name(self):
        """
        Checks if the person's name is a palindrome. Ignore spaces, capitalization, and punctuation marks when checking for a palindrome.
        Returns True if the name is a palindrome, and False otherwise.
        Time complexity: O(n), where n is the length of the name.
        """
        name = "".join(filter(str.isalpha, self.first_name.lower() + self.last_name.lower()))
        return name == name[::-1]

    def get_age_in_weeks(self):
        """
        Calculates and returns the person's age in weeks.
        Time complexity: O(1)
        """
        return self.age * 52

    def has_vowel_in_name(self):
        """
        Checks if the person's name contains any vowels (a, e, i, o, u).
        Returns True if the name contains at least one vowel, and False otherwise.
        Time complexity: O(n), where n is the length of the name.
        """
        vowels = {'a', 'e', 'i', 'o', 'u'}
        name = self.first_name.lower() + self.last_name.lower()
        return any(letter in vowels for letter in name)

    def is_name_proper_noun(self):
        """
        Checks if the person's name is a proper noun.
        A proper noun starts with a capital letter and all other letters are lowercase.
        Returns True if the name is a proper noun, and False otherwise.
        Time complexity: O(1)
        """
        return self.first_name[0].isupper() and self.first_name[1:].islower() and self.last_name[0].isupper() and self.last_name[1:].islower()

    def get_age_category(self):
        """
        Returns the age category of the person.
        - "Child" if the person is under 10 years old
        - "Teenager" if the person is between 10 and 19 years old, inclusive
        - "Adult" if the person is between 20 and 59 years old, inclusive
        - "Senior" if the person is 60 years old or older
        """
        if self.age < 10:
            return "Child"
        elif 10 <= self.age <= 19:
            return "Teenager"
        elif 20 <= self.age <= 59:
            return "Adult"
        else:
            return "Senior"


import re

def xml_to_json(xml):
    # Remove any leading/trailing whitespace and newline characters
    xml = xml.strip()

    # Check if the XML document is empty
    if not xml:
        return {}

    # Check if the XML document is a single empty element
    if re.match(r"<[^/>]+/>", xml):
        return {}

    # Get the root element name
    root_start = xml.find("<") + 1
    root_end = xml.find(">")
    root_name = xml[root_start:root_end]

    # Initialize the result dictionary
    result = {root_name: {}}

    # Extract the content inside the root element
    content_start = root_end + 1
    content_end = xml.rfind("<")
    content = xml[content_start:content_end].strip()

    # Check if the content is a single element or multiple nested elements
    if re.match(r"<[^/>]+>[^<]+</[^>]+>", content):
        # Single element case
        element_start = content.find("<") + 1
        element_end = content.find(">")
        element_name = content[element_start:element_end]

        element_content_start = element_end + 1
        element_content_end = content.rfind("<")
        element_content = content[element_content_start:element_content_end].strip()

        result[root_name][element_name] = parse_element(element_content)
    else:
        # Multiple nested elements case
        while content:
            # Find the start and end tags of the next element
            element_start = content.find("<") + 1
            element_end = content.find(">")

            # Extract the name of the next element
            element_name = content[element_start:element_end]

            # Find the start and end tags of the next element's content
            element_content_start = element_end + 1
            element_content_end = content.find("</{}>".format(element_name))

            # Extract the content of the next element
            element_content = content[element_content_start:element_content_end].strip()

            # Parse the element's content and add it to the result dictionary
            if element_name in result[root_name]:
                # If the element already exists in the result dictionary, convert it to a list
                if type(result[root_name][element_name]) is not list:
                    result[root_name][element_name] = [result[root_name][element_name]]
                result[root_name][element_name].append(parse_element(element_content))
            else:
                result[root_name][element_name] = parse_element(element_content)

            # Remove the processed element from the content
            content = content[element_content_end + len("</{}>".format(element_name)):].strip()

    return result


def parse_element(element):
    # Check if the element is an empty element
    if not element:
        return {}

    # Check if the element has attributes
    if re.match(r"<[^/>]+\s[^<]+/>", element):
        # Extract the attributes from the element
        attributes_start = element.find(" ") + 1
        attributes_end = element.find(">")
        attributes_str = element[attributes_start:attributes_end]

        # Split the attributes string into individual attribute strings
        attribute_list = re.split(r"\s+", attributes_str)

        # Create a dictionary to store the attributes
        attributes = {}
        for attribute in attribute_list:
            # Split each attribute string into name and value
            name, value = attribute.split("=")

            # Remove any leading/trailing whitespace and quote characters from the value
            value = value.strip("\"'")

            # Add the attribute to the attributes dictionary
            attributes[name] = value

        return attributes

    # Check if the element has nested elements
    if re.match(r"<[^/>]+>[^<]+</[^>]+>", element):
        # Extract the content inside the element
        content_start = element.find(">") + 1
        content_end = element.rfind("<")
        content = element[content_start:content_end].strip()

        # Parse the content recursively and return it
        return xml_to_json(content)

    # Check if the element has a boolean value
    if element in ["true", "false"]:
        return bool(element)

    # Check if the element has an integer value
    if re.match(r"[-+]?\d+$", element):
        return int(element)

    # Default case: return the element's value as a string
    return element


# Example usage:
xml = """
<root>
    <element attribute1="value1" attribute2="value2">Text</element>
    <element attribute3="value3">123</element>
    <element attribute4="value4">
        <nested_element>True</nested_element>
    </element>
    <empty_element></empty_element>
</root>
"""

json = xml_to_json(xml)
print(json)


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def create_linked_list(numbers):
    head = None
    for num in numbers:
        node = ListNode(num)
        if not head:
            head = node
        else:
            current = head
            while current.next:
                current = current.next
            current.next = node
    return head

numbers = [2, 4, 5, 6, 7, 8, 9]
linked_list = create_linked_list(numbers)

current = linked_list
while current:
    print(current.val, "->", end=" ")
    current = current.next
print("None")


def sum_of_digits(n):
    total = 0
    
    while n > 0:
        total += n % 10
        n //= 10
        
    return total


import math

def remove_primes(input_list):
    output_list = []
    
    for num in input_list:
        is_prime = True
        
        for i in range(2, math.isqrt(num) + 1):
            if num % i == 0:
                is_prime = False
                break
        
        if not is_prime:
            output_list.append(num)
    
    return output_list

input_list = [4, 8, 15, 16, 23, 42, 7, 9, 11]
output_list = remove_primes(input_list)
print(output_list)


def calculate_surface_area(radius):
    surface_area = 4 * 3.14159 * (radius ** 2)
    return round(surface_area, 2)


def print_odd_multiplication_table(n):
    # Check if the input is a positive integer
    if not isinstance(n, int) or n <= 0:
        print("Error: Input must be a positive integer")
        return

    # Print the multiplication table
    for i in range(1, n+1):
        for j in range(1, n+1):
            result = i * j
            if result % 2 != 0:
                print(result, end="\t")
            else:
                print("-", end="\t")
        print()


def find_positions(string):
    # Split the string into words
    words = string.split()
    positions = []
    
    # Iterate over each word in the string
    for i in range(len(words)):
        # Check if the word is equal to "is" ignoring case
        if words[i].lower() == "is":
            # If the word is "is" and it is not part of another word, add its position to the list
            if (i == 0 or not words[i-1][-1].isalpha()) and (i == len(words)-1 or not words[i+1][0].isalpha()):
                positions.append(sum(len(words[j])+1 for j in range(i)))
    
    return positions

# Test the function with the given example
string = "This is an example string, and it is an example of a string that contains the substring 'is' multiple times. However, it should ignore any words like 'this', 'island', or 'crisis'."
positions = find_positions(string)
print(positions)


import numpy as np
import pandas as pd
from sklearn.utils import shuffle

def generate_dataset(num_samples, num_features, outlier_level, class_imbalance, noise_level):
    # Generate features
    features = np.random.uniform(-1000, 1000, size=(num_samples, num_features))

    # Generate labels based on non-linear relationships with features
    labels = np.zeros(num_samples)
    for i in range(num_features):
        labels += np.sin(features[:, i]) + 0.5 * np.cos(2 * features[:, i])

    # Introduce outliers
    num_outliers = int(num_samples * outlier_level)
    outlier_indices = np.random.choice(num_samples, num_outliers, replace=False)
    features[outlier_indices] = np.random.uniform(-10000, 10000, size=(num_outliers, num_features))
    labels[outlier_indices] = np.random.randint(0, 5, size=num_outliers)

    # Introduce class imbalance
    num_samples_per_class = int(num_samples * (1 - class_imbalance) / 4)
    class_labels = np.repeat(np.arange(5), num_samples_per_class)
    class_indices = []
    for i in range(5):
        class_indices.append(np.random.choice(np.where(labels == i)[0], num_samples_per_class, replace=False))
    class_indices = np.concatenate(class_indices)
    features = features[class_indices]
    labels = labels[class_indices]

    # Add noisy labels
    num_noisy_labels = int(num_samples * noise_level)
    noisy_indices = np.random.choice(num_samples, num_noisy_labels, replace=False)
    noisy_labels = np.random.randint(0, 5, size=num_noisy_labels)
    labels[noisy_indices] = noisy_labels

    # Shuffle the dataset
    features, labels = shuffle(features, labels)

    return features, labels

# Generate the dataset
num_samples = 10000000
num_features = 10000
outlier_level = 0.1
class_imbalance = 0.7
noise_level = 0.3

features, labels = generate_dataset(num_samples, num_features, outlier_level, class_imbalance, noise_level)

# Convert the dataset to a pandas DataFrame and save it as a CSV file
dataset = pd.DataFrame(features)
dataset['label'] = labels
dataset.to_csv('dataset.csv', index=False)


class Multiverse:
    def __init__(self):
        self.realities = []
    
    def discover(self, limit):
        count = 0
        while count < limit:
            new_reality = Reality()
            self.realities.append(new_reality)
            count += 1
    
    def appreciate(self):
        print(f"Total number of realities discovered: {len(self.realities)}")
        marvels = []
        for reality in self.realities:
            for marvel in reality.marvels:
                marvels.append(marvel)
        marvels.sort(key=lambda marvel: marvel.reality_number)
        print("Marvels discovered so far:")
        for marvel in marvels:
            print(f"{marvel.name} in reality {marvel.reality_number}")


def merge(nums1, m, nums2, n):
    # Initialize pointers and resulting vector
    i = j = 0
    res = []

    # Iterate through both vectors
    while i < m and j < n:
        if nums1[i] < nums2[j]:
            # Check for duplicates
            if not res or nums1[i] != res[-1]:
                res.append(nums1[i])
            i += 1
        else:
            # Check for duplicates
            if not res or nums2[j] != res[-1]:
                res.append(nums2[j])
            j += 1

        # Stop iteration if resulting vector reaches maximum size
        if len(res) == m + n:
            break

    # Add remaining elements to resulting vector
    while i < m:
        if not res or nums1[i] != res[-1]:
            res.append(nums1[i])
        i += 1
        if len(res) == m + n:
            break

    while j < n:
        if not res or nums2[j] != res[-1]:
            res.append(nums2[j])
        j += 1
        if len(res) == m + n:
            break

    return res


import re

pets = ["Henry: 12 dogs", "Eric: 2 cats, 1 dog", "David: 7 birds, 3 cats", "Alice: 5 snakes, 2 dogs", "Bob: 3 hamsters, 1 cat", "Emily: 10 rabbits", "Frank: 4 turtles, 2 cats, 1 dog", "Grace: 8 fish, 4 cats", "Hannah: 6 lizards, 2 snakes, 1 cat", "Ian: 9 guinea pigs, 3 cats, 2 dogs", "Jack: 15 horses, 5 dogs", "Kate: 20 cows, 10 cats, 5 dogs", "Liam: 18 pigs, 9 cats, 4 dogs", "Megan: 13 sheep, 6 dogs", "Nathan: 11 chickens, 4 cats, 3 dogs", "Olivia: 16 goats, 8 dogs, 2 cats", "Patrick: 14 ducks, 7 cats, 5 dogs", "Quinn: 17 geese, 8 dogs, 3 cats", "Ryan: 19 swans, 9 cats, 4 dogs", "Sophia: 25 elephants, 12 dogs", "Tom: 22 spiders, 13 dogs", "Zoe: 30 mice, 10 cats", "Sarah: 11 squirrels, 6 dogs", "Jake: 16 frogs, 8 cats", "Rachel: 23 snakes, 11 dogs", "Ben: 14 fish, 5 cats", "Emma: 19 birds, 9 cats", "Jason: 17 turtles, 7 dogs", "Sophie: 20 rabbits, 10 cats"]

pet_owners = {}

for pet in pets:
    # Extract the owner's name
    match = re.match(r"([A-Za-z]+):", pet)
    if match:
        owner = match.group(1)
        pet_info = re.findall(r"(\d+)\s+([A-Za-z]+)", pet)
        if pet_info:
            pet_owners[owner] = [(int(count), animal) for count, animal in pet_info]

print(pet_owners)


def closest_decimal_approximation(n, precision):
    # Base case: if the desired precision is reached, return the current approximation
    if precision == 0:
        return n

    # Recursive case: add decimal places by multiplying n by 10
    return closest_decimal_approximation(n * 10, precision - 1)

# Call the function with the initial approximation of 0.875 and maximum precision of 100 decimal places
approximation = closest_decimal_approximation(0.875, 100)
print(approximation)


def check_unique_ascending(lst):
    # Check for uniqueness using a set
    if len(lst) != len(set(lst)):
        return False
    
    # Check for ascending order using a for loop
    for i in range(len(lst) - 1):
        if lst[i] >= lst[i + 1]:
            return False
    
    return True


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.length = 0

    def insert(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        self.length += 1

    def append(self, data):
        new_node = Node(data)
        if self.tail is None:
            self.head = new_node
            self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        self.length += 1

    def delete(self, data):
        current = self.head
        while current:
            if current.data == data:
                if current == self.head and current == self.tail:
                    self.head = None
                    self.tail = None
                elif current == self.head:
                    self.head = current.next
                    self.head.prev = None
                elif current == self.tail:
                    self.tail = current.prev
                    self.tail.next = None
                else:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                self.length -= 1
                return
            current = current.next

    def search(self, data):
        current = self.head
        while current:
            if current.data == data:
                return True
            current = current.next
        return False

    def size(self):
        return self.length

    def get_head(self):
        if self.head:
            return self.head.data
        return None

    def get_tail(self):
        if self.tail:
            return self.tail.data
        return None


# Example usage:
dll = DoublyLinkedList()
dll.insert(1)
dll.append(2)
dll.insert(3)
dll.delete(2)
print(dll.search(1))  # Output: True
print(dll.size())  # Output: 2
print(dll.get_head())  # Output: 3
print(dll.get_tail())  # Output: 1


def calculate_length(lst):
    count = 0
    for item in lst:
        count += 1
    return count


import numpy as np
from scipy import stats


def sum_even_recursive(n):
    if n <= 0:  # base case: stop recursion when n becomes non-positive
        return 0
    elif n % 2 == 0:  # if n is even, add it to the sum
        return n + sum_even_recursive(n-2)
    else:  # if n is odd, skip it and move to the next even number
        return sum_even_recursive(n-1)


class Car:
    def __init__(self, make, year, mileage, fuel_level, fuel_efficiency, max_fuel_capacity):
        self.make = make
        self.year = year
        self.mileage = mileage
        self.fuel_level = fuel_level
        self.fuel_efficiency = fuel_efficiency
        self.max_fuel_capacity = max_fuel_capacity

    def calculate_range(self):
        return self.fuel_level * self.fuel_efficiency

    def update_fuel_level(self, new_fuel_level):
        if new_fuel_level > self.max_fuel_capacity:
            raise ValueError("Fuel level cannot exceed the car's maximum fuel capacity.")
        self.fuel_level = new_fuel_level


def minOperations(logs):
    depth = 0
    for log in logs:
        if log == "../":
            depth = max(0, depth - 1)
        elif log != "./":
            depth += 1
    return depth


import math

def calculate_triangle_area(a, b, c):
    s = (a + b + c) / 2
    d1 = s - a
    d2 = s - b
    d3 = s - c
    product = d1 * d2 * d3
    area = math.sqrt(product)
    return area


import re

def check_string(string):
    # Check if the string contains only alphabetical characters and has a length of at least 10 characters
    if not string.isalpha() or len(string) < 10:
        return False

    # Check if the string contains at least two uppercase letters, two lowercase letters, and two digits
    uppercase_count = len(re.findall(r'[A-Z]', string))
    lowercase_count = len(re.findall(r'[a-z]', string))
    digit_count = len(re.findall(r'\d', string))

    if uppercase_count < 2 or lowercase_count < 2 or digit_count < 2:
        return False

    return True

# Test the logic
print(check_string("AbCdefGHiJ1"))  # True
print(check_string("AbCdeFGHij"))  # False (does not contain at least two digits)
print(check_string("ABCDEFGHIJ"))  # False (does not contain at least two lowercase letters)
print(check_string("1234567890"))  # False (does not contain at least two uppercase letters)
print(check_string("AbC12de"))     # False (length is less than 10 characters)


def reverse_string(string):
    # Convert the string into a list of characters
    string = list(string)

    # Initialize two pointers, one at the start and one at the end of the string
    start = 0
    end = len(string) - 1

    # Swap characters from both ends until the pointers meet in the middle
    while start < end:
        # Ignore special characters and whitespace by moving the pointers
        if not string[start].isalnum():
            start += 1
        elif not string[end].isalnum():
            end -= 1
        else:
            # Swap the characters
            string[start], string[end] = string[end], string[start]
            start += 1
            end -= 1

    # Convert the list of characters back into a string
    return ''.join(string)


import random

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def generate_even_prime():
    while True:
        num = random.randint(1, 50)
        num *= 2  # Generate even number
        if is_prime(num):
            return num

# Generate even prime number
even_prime = generate_even_prime()

# Print corresponding statement based on the generated number
if even_prime <= 25:
    print("Very low even prime number")
elif even_prime <= 50:
    print("Low even prime number")
elif even_prime <= 75:
    print("Medium even prime number")
elif even_prime <= 90:
    print("High even prime number")
else:
    print("Very high even prime number")


import re

def filter_strings(string_list, length):
    """
    This function filters a given list of strings and returns a new list with strings having length greater than the given number.
    It also ignores any strings that contain special characters.

    Parameters:
    string_list (list): The list of strings to filter.
    length (int): The minimum length of the strings to include in the returned list.

    Returns:
    list: A list of strings from the original list that are longer than the specified length and do not contain special characters.

    Approach:
    The function uses a list comprehension to iterate over the input list and checks two conditions for each string:
    1. The length of the string is greater than the input length.
    2. The string only contains alphanumeric characters (i.e., no special characters).
    """

    # Use a list comprehension to filter the list based on the two conditions
    return [s for s in string_list if len(s) > length and bool(re.match('^[a-zA-Z0-9]*$', s))]

# Test the function
string_list = ['Example', 'cat!', 'dog?', 'hello', 'word']
length = 4
print(filter_strings(string_list, length))


def max_running_time(n, batteries):
    batteries.sort(reverse=True)
    total_time = sum(batteries[:n])
    return total_time // n


def decimal_to_binary(decimal_number):
    binary = ""
    
    while decimal_number > 0:
        if decimal_number & 1:
            binary += '1'
        else:
            binary += '0'
        decimal_number >>= 1
    
    return binary[::-1]


import math
# Solve x^2 - 2x = 0
a = 1
b = -2
c = 0
# Calculate the discriminant
discriminant = b**2 - 4*a*c
# Check if the discriminant is positive, negative or zero
if discriminant > 0:
 # There are two real roots
 x1 = (-b + math.sqrt(discriminant)) / (2*a)
 x2 = (-b - math.sqrt(discriminant)) / (2*a)
 print("The roots are", x1, "and", x2)
elif discriminant == 0:
 # There is one real root
 x = -b / (2*a)
 print("The root is", x)
else:
 # There are two complex roots
 real_part = -b / (2*a)
 imaginary_part = math.sqrt(-discriminant) / (2*a)
 print("The roots are", real_part, "+", imaginary_part, "i and", real_part, "-", imaginary_part, "i")


import re

def validate_email(email):
    if len(email) > 50:
        return False

    local_part, domain_part = email.split('@')

    if not re.match(r'^[a-zA-Z0-9._-]+$', local_part):
        return False

    if not re.match(r'^[a-zA-Z0-9.]+$', domain_part):
        return False

    if not re.search(r'\.', domain_part):
        return False

    if not re.match(r'.+\.(com|org|net|edu|gov)$', domain_part):
        return False

    return True

# Testing the program
print(validate_email("john.doe@example.com"))  # True
print(validate_email("johndoe@example.com"))  # True
print(validate_email("john.doe@example.org"))  # True
print(validate_email("john_doe@example.net"))  # True
print(validate_email("john-doe@example.edu"))  # True
print(validate_email("john_doe@example.gov"))  # True
print(validate_email("john.doe@com"))  # False (missing dot before top-level domain)
print(validate_email("john.doe@example"))  # False (missing top-level domain)
print(validate_email("john.doe@example.com."))  # False (dot at the end of domain part)
print(validate_email("john.doe@example.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm"))  # False (exceeds maximum length)
print(validate_email(".johndoe@example.com"))  # False (starts with a dot)
print(validate_email("-johndoe@example.com"))  # False (starts with a hyphen)
print(validate_email("_johndoe@example.com"))  # False (starts with an underscore)
print(validate_email("johndoe.@example.com"))  # False (ends with a dot)


import heapq

class FrequencyCounter:
    def __init__(self):
        self.counter = {}
        self.heap = []
    
    def add_number(self, number):
        if number in self.counter:
            self.counter[number] += 1
        else:
            self.counter[number] = 1
            heapq.heappush(self.heap, (1, number))
    
    def remove_number(self, number):
        if number in self.counter:
            self.counter[number] -= 1
            if self.counter[number] == 0:
                del self.counter[number]
            self._rebuild_heap()
    
    def update_frequency(self, number, frequency):
        if number in self.counter:
            self.counter[number] = frequency
            self._rebuild_heap()
    
    def get_frequency(self, number):
        if number in self.counter:
            return self.counter[number]
        return 0
    
    def find_highest_frequency(self):
        if self.heap:
            max_frequency = self.heap[-1][0]
            return [number for frequency, number in self.heap if frequency == max_frequency]
        return []
    
    def find_lowest_frequency(self):
        if self.heap:
            min_frequency = self.heap[0][0]
            return [number for frequency, number in self.heap if frequency == min_frequency]
        return []
    
    def _rebuild_heap(self):
        self.heap = [(frequency, number) for number, frequency in self.counter.items()]
        heapq.heapify(self.heap)


import math

def is_even(number):
    return number % 2 == 0

def is_prime(number):
    if number < 2:
        return False
    for i in range(2, int(math.sqrt(number)) + 1):
        if number % i == 0:
            return False
    return True

def is_perfect_square(number):
    sqrt = math.sqrt(number)
    return sqrt == int(sqrt)

def is_fibonacci(number):
    a, b = 0, 1
    while a < number:
        a, b = b, a + b
    return a == number

def is_divisible_by(number, divisor):
    return number % divisor == 0

def analyze_sum(num1, num2):
    sum = num1 + num2
    
    if is_even(sum):
        print("The sum is even")
    else:
        print("The sum is odd")
        
    if is_prime(sum):
        print("The sum is a prime number")
        
    if is_perfect_square(sum):
        print("The sum is a perfect square")
        
    if is_fibonacci(sum):
        print("The sum is a Fibonacci number")
        
    if is_divisible_by(sum, num1) and is_divisible_by(sum, num2):
        print("The sum is divisible by both numbers")
    elif is_divisible_by(sum, num1) or is_divisible_by(sum, num2):
        print("The sum is divisible by one of the numbers")
    else:
        print("The sum is not divisible by either of the numbers")

num1 = int(input("Enter the first number: "))
num2 = int(input("Enter the second number: "))

analyze_sum(num1, num2)


import math

class Point3D:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def distance_to(self, other):
        dx = self.x - other.x
        dy = self.y - other.y
        dz = self.z - other.z
        return math.sqrt(dx ** 2 + dy ** 2 + dz ** 2)

    def angle_between(self, other):
        dot_product = self.x * other.x + self.y * other.y + self.z * other.z
        magnitude_self = math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)
        magnitude_other = math.sqrt(other.x ** 2 + other.y ** 2 + other.z ** 2)
        cos_angle = dot_product / (magnitude_self * magnitude_other)
        return math.acos(cos_angle)

# Example usage
point1 = Point3D(1, 2, 3)
point2 = Point3D(4, 5, 6)
distance = point1.distance_to(point2)
angle = point1.angle_between(point2)

print("Distance between point1 and point2:", distance)
print("Angle between the vectors formed by connecting the origin to point1 and point2:", angle)


import math
# Parameters for the Gurney equation
Kc = 1.2
Zc = 0.3
E = 100 # in kJ/mol
# Input parameters for the material
molar_mass = 100 # in g/mol
density = 2 # in g/cm^3
crystal_structure = 'fcc'
# Calculate the molar volume
Vc = molar_mass / density
# Calculate the critical pressure
if crystal_structure == 'fcc':
    Pc = Kc * (Zc / Vc) * (E / Vc) ** (1/3)
else:
    Pc = None
print('Critical pressure: {} GPa'.format(Pc))


def multiply_and_exclude_negative(lst):
    new_lst = [item * 2 for item in lst if item >= 0]
    return new_lst

original_lst = [1, -2, 3, -4, 5]
result_lst = multiply_and_exclude_negative(original_lst)
print(result_lst)


def concatenate_strings(string1, string2):
    # Concatenate the strings
    result = string1 + string2
    
    # Remove special characters and numbers, and convert to lowercase
    result = ''.join([c.lower() for c in result if c.isalpha()])
    
    # Sort the string alphabetically
    result = ''.join(sorted(result))
    
    # Remove duplicate characters
    result = ''.join([c for i, c in enumerate(result) if c not in result[:i]])
    
    return result


def greet(name):
    if isinstance(name, str):
        print(f"Hello {name}!")

def greeting():
    greet("World")

greeting()


def get_prime_numbers(numbers):
    def is_prime(num):
        if num < 2:
            return False
        for i in range(2, int(num**0.5) + 1):
            if num % i == 0:
                return False
        return True

    def contains_digit_seven(num):
        return '7' in str(num)

    prime_numbers = [num for num in numbers if is_prime(num) and not contains_digit_seven(num)]
    prime_numbers.sort(reverse=True)
    return prime_numbers

numbers = [17, 37, 42, 53, 67, 79, 81, 91]
output = get_prime_numbers(numbers)
print(output)


students = [('John', 'Doe'), ('Max', 'Smith'), ('Alice', 'Brown')]

sorted_students = sorted(students, key=lambda x: (x[1], x[0], len(x[0])))

print(sorted_students)


def check_string(s):
    vowels = ['a', 'e', 'i', 'o', 'u']
    has_vowel = False

    # Check if all characters are lowercase alphabetic
    if s.islower():
        # Check if the string contains at least one vowel
        for char in s:
            if char in vowels:
                has_vowel = True
                break

    return s.islower() and has_vowel


def is_prime_with_three_factors(num):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    prime_factors = []
    for i in range(2, num+1):
        if is_prime(i) and num % i == 0:
            prime_factors.append(i)

    if len(prime_factors) == 3 and sum(prime_factors) > num:
        return True
    else:
        return False


import math
def is_perfect_cube(n):
    return math.isqrt(n) ** 3 == n
def generate_prime_squares(limit):
    primes = [2]
    for i in range(3, limit, 2):
        for j in range(2, int(math.sqrt(i)) + 1):
            if i % j == 0:
                break
        else:
            for a in range(1, int(math.sqrt(i))):
                for b in range(a, int(math.sqrt(i))):
                    if a**2 + b**2 == i and is_perfect_cube(i * a**2 * b**2):
                        primes.append(i)
                        break
    return primes
primes = generate_prime_squares(10000)
print("Sequence of prime numbers that are the sum of two perfect squares and whose product is a perfect cube:")
print(primes)
print("Smallest prime number in the sequence:", min(primes))
print("Largest prime number in the sequence:", max(primes))


def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def sum_even_greater_than_10(dictionary):
    total = 0
    has_even_greater_than_10 = False
    for value in dictionary.values():
        if isinstance(value, str):
            value = int(value)
        if isinstance(value, int) and value > 10 and value % 2 == 0 and not is_prime(value):
            total += value
            has_even_greater_than_10 = True

    if has_even_greater_than_10:
        return total
    else:
        return -1

# Example usage:
my_dict = {
    "a": "12",
    "b": 15,
    "c": 8,
    "d": 20,
    "e": "13",
    "f": 16
}

print(sum_even_greater_than_10(my_dict))  # Output: 48


arr = ['apple', 'banana', 'cherry', 'durian', 'elderberry']

total_length = 0

for element in arr:
    if isinstance(element, str) and 'a' in element and len(element) > 3:
        total_length += len(element)

print(total_length)


def add_item_to_list(lst, item, index=None):
    # Check if item already exists in the list
    if item in lst:
        return "Item already exists in the list."
    
    # Check if item is of the correct data type
    if not isinstance(item, int):
        return "Item is not of the correct data type."
    
    # Check if list has reached its maximum capacity
    if len(lst) >= 10:
        return "List has reached its maximum capacity."
    
    # Check if index is valid
    if index is not None and (index < 0 or index > len(lst)):
        return "Invalid index specified."
    
    # Add item at the specified index or at the end of the list
    if index is None:
        lst.append(item)
    else:
        lst.insert(index, item)
    
    # Return the updated list
    return lst


def print_list_reverse(lst, index):
    if index < 0:  # Base case: stop when index is negative
        return
    print(lst[index])  # Print the element at the current index
    print_list_reverse(lst, index - 1)  # Recursively call the function with the next index

my_list = [1, 2, 3, 4, 5]
print_list_reverse(my_list, len(my_list) - 1)


def find_maximum_path_sum(test_array):
    rows = len(test_array)
    cols = len(test_array[0])
    
    # Create a 2D table to store the maximum sum at each cell
    dp = [[0] * cols for _ in range(rows)]
    
    # Initialize the first cell
    dp[0][0] = test_array[0][0]
    
    # Initialize the first row
    for j in range(1, cols):
        dp[0][j] = dp[0][j-1] + test_array[0][j]
    
    # Initialize the first column
    for i in range(1, rows):
        dp[i][0] = dp[i-1][0] + test_array[i][0]
    
    # Calculate the maximum sum for each cell
    for i in range(1, rows):
        for j in range(1, cols):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + test_array[i][j]
    
    # Find the maximum sum path that includes at least one odd and one even number
    max_sum = float('-inf')
    for i in range(rows):
        for j in range(cols):
            if (dp[i][j] > max_sum) and (test_array[i][j] % 2 != 0) and (dp[i][j] % 2 == 0):
                max_sum = dp[i][j]
    
    return max_sum

# Test the function with the given example
test_array = [[5, 6, 1],
              [4, 2, 3],
              [7, 8, 9]]
print(find_maximum_path_sum(test_array))


def sum_odd_indexed_items(*args):
    odd_indexed_sum = 0
    odd_indices = []

    for arg in args:
        if isinstance(arg, list) and len(arg) % 2 != 0:
            for i, item in enumerate(arg):
                if i % 2 != 0 and item not in arg[:i]:
                    odd_indexed_sum += max(0, item)
                    odd_indices.append(i)

    return odd_indexed_sum, odd_indices


def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)


class BraceChecker:
    def __init__(self):
        self.open_braces = {"(", "[", "{"}
        self.close_braces = {")", "]", "}"}

    def check_expression(self, expression):
        stack = []
        for char in expression:
            if char in self.open_braces:
                stack.append(char)
            elif char in self.close_braces:
                if not stack:
                    raise InvalidExpressionError("Mismatched closing brace for '{}'".format(char))
                opening_brace = stack.pop()
                if not self.is_matching_braces(opening_brace, char):
                    raise InvalidExpressionError("Mismatched closing brace for '{}'".format(opening_brace))
        
        if stack:
            raise InvalidExpressionError("Missing closing brace for '{}'".format(stack[-1]))
        
        return True
    
    def is_matching_braces(self, opening_brace, closing_brace):
        if opening_brace == "(" and closing_brace == ")":
            return True
        elif opening_brace == "[" and closing_brace == "]":
            return True
        elif opening_brace == "{" and closing_brace == "}":
            return True
        return False

class InvalidExpressionError(Exception):
    pass


import re

class WebComponent:
    def __init__(self, identifier, component_type, purpose, functionality):
        self.identifier = identifier
        self.component_type = component_type
        self.purpose = purpose
        self.functionality = functionality

    def __str__(self):
        return f"Identifier: {self.identifier}\nType: {self.component_type}\nPurpose: {self.purpose}\nFunctionality: {self.functionality}\n"

def add_component(components):
    identifier = input("Enter the identifier of the component: ")
    component_type = input("Enter the type of the component (header, navigation menu, content section, sidebar, footer): ")
    purpose = input("Enter the purpose of the component: ")
    functionality = input("Enter the functionality of the component: ")
    components.append(WebComponent(identifier, component_type, purpose, functionality))

def delete_component(components):
    identifier = input("Enter the identifier of the component you want to delete: ")
    for component in components:
        if component.identifier == identifier:
            components.remove(component)
            return
    print("Error: Component identifier not found.")

def edit_component(components):
    identifier = input("Enter the identifier of the component you want to edit: ")
    for component in components:
        if component.identifier == identifier:
            purpose = input("Enter the new purpose of the component: ")
            functionality = input("Enter the new functionality of the component: ")
            component.purpose = purpose
            component.functionality = functionality
            return
    print("Error: Component identifier not found.")

def search_component(components):
    search_term = input("Enter the search term: ")
    matches = []
    for component in components:
        if re.search(search_term, component.purpose, re.IGNORECASE) or re.search(search_term, component.functionality, re.IGNORECASE):
            matches.append(component)
    if len(matches) > 0:
        for match in matches:
            print(match)
    else:
        print("No matching components found.")

def sort_components(components):
    components.sort(key=lambda x: x.identifier)

def display_components(components):
    for component in components:
        print(component)

def validate_component_type(component_type):
    valid_types = ["header", "navigation menu", "content section", "sidebar", "footer"]
    return component_type.lower() in valid_types

def validate_identifier(components, identifier):
    for component in components:
        if component.identifier == identifier:
            return True
    return False

def menu():
    components = []
    while True:
        print("1. Add a component")
        print("2. Delete a component")
        print("3. Edit a component")
        print("4. Search for a component")
        print("5. Sort components")
        print("6. Display components")
        print("7. Quit")
        choice = input("Enter your choice: ")
        if choice == "1":
            add_component(components)
        elif choice == "2":
            delete_component(components)
        elif choice == "3":
            edit_component(components)
        elif choice == "4":
            search_component(components)
        elif choice == "5":
            sort_components(components)
        elif choice == "6":
            display_components(components)
        elif choice == "7":
            break
        else:
            print("Error: Invalid choice.")

if __name__ == "__main__":
    menu()


def min_penalty(customers: str) -> int:
    n = len(customers)
    open_penalty, closed_penalty = 0, 0

    for c in customers:
        if c == 'N':
            open_penalty += 1
        else:
            closed_penalty += 1

    result = closed_penalty
    penalty = closed_penalty

    for c in customers:
        if c == 'N':
            penalty -= 1
        else:
            penalty += 1

        result = min(result, penalty)

    return result


def partition_string(s, k, fill):
    partitions = []
    current_partition = ''
    for c in s:
        current_partition += c
        if len(current_partition) == k:
            partitions.append(current_partition)
            current_partition = ''
    if current_partition:
        current_partition += fill * (k - len(current_partition))
        partitions.append(current_partition)
    return partitions


def combine_lists(list1, list2):
    result_dict = {}
    
    # Iterate over the elements of list1 and list2 simultaneously
    for item1, item2 in zip(list1, list2):
        if item2 % 3 == 0:
            if item1 not in result_dict:
                # If the key is not already in the dictionary, add it with a list as the value
                result_dict[item1] = [item2]
            else:
                # If the key is already in the dictionary, append the value to the existing list
                result_dict[item1].append(item2)
    
    # Sort the dictionary based on the keys in ascending order
    sorted_dict = dict(sorted(result_dict.items()))
    
    return sorted_dict

# Test the function
list1 = ['a', 'b', 'b', 'c']
list2 = [2, 3, 6, 4]
result = combine_lists(list1, list2)
print(result)


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)

            if node.left:
                queue.append(node.left)

            if node.right:
                queue.append(node.right)

            level.append(node.val)

        result.append(level)

    return result


def delete_third_element(arr):
    # Check if the array is empty or has less than 3 elements
    if len(arr) < 3:
        return arr

    # Delete the third element by shifting all elements after it to the left
    for i in range(2, len(arr)-1):
        arr[i] = arr[i+1]

    # Reduce the length of the array by 1
    arr.pop()

    return arr


def multiply_by_two(x):
    return x * 2

def apply_function(numbers, function):
    result = []
    for num in numbers:
        result.append(function(num))
    return result

numbers = [1, 2, 3, 4, 5]
result = apply_function(numbers, multiply_by_two)
print(result)  # Output: [2, 4, 6, 8, 10]


def gcd(a, b):
    a = abs(a)
    b = abs(b)
    
    if b == 0:
        return a
    
    return gcd(b, a % b)


my_list = [1, 2, 3, 4, 5]

for element in my_list:
    print(element)


def calculate_sum(arr):
    total = 0
    for num in arr:
        total += num
    return total


def count_vowels(string):
    vowels = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}
    vowels_positions = {'a': [], 'e': [], 'i': [], 'o': [], 'u': []}

    for i, char in enumerate(string):
        if char.lower() in vowels:
            vowels[char.lower()] += 1
            vowels_positions[char.lower()].append(i)

    return {'count': vowels, 'positions': vowels_positions}


print((lambda s: len(s) if s.isalnum() and len(s) <= 50 else 'Invalid input')(input()))


def cartesian_product(A: set, B: set) -> list:
    result = []
    for a in A:
        for b in B:
            result.append((a, b))
    return result


def delete_common_chars(A, B):
    # Remove characters in B from A
    A = ''.join(char for char in A if char.lower() not in B.lower())
    
    # Remove consecutively repeated characters
    modified_A = ''
    for i in range(len(A)):
        if i == 0 or A[i] != A[i-1]:
            modified_A += A[i]
    
    return modified_A


import math

def generate_primes(n):
    m = int(n * math.log(n))  # Estimate m as an upper bound for the largest prime number in the array
    primes = [True] * (m + 1)
    primes[0] = primes[1] = False

    for i in range(2, int(math.sqrt(m)) + 1):
        if primes[i]:
            for j in range(i*i, m+1, i):
                primes[j] = False

    count = primes.count(True)
    result = [0] * n
    num = 0

    for i in range(2, m + 1):
        if primes[i]:
            result[num] = i
            num += 1
            if num == n:
                break

    return result


def find_string_length(string):
    length = 0
    index = 0
    
    while string[index] != '\0':
        length += 1
        index += 1
    
    return length


def check_string(string, specific_string):
    if string == specific_string:
        if any(char.isupper() for char in string):
            return True
        else:
            return False
    else:
        return False


import re

def extract_urls(strings):
    urls = []
    pattern = r"(http://|https://)[^\s\/$.?#].[^\s]*"

    for string in strings:
        matches = re.findall(pattern, string)
        urls.extend(matches)

    return urls

# Example usage
input_strings = [
    "Visit my website at http://example.com for more information",
    "Click here: https://www.example.com to download the file",
    "Invalid URL: http://example com",
    "Invalid URL: http://example.com?param=1",
]

urls = extract_urls(input_strings)
print(urls)


def bubble_sort(nums):
    # If the list is empty or has only one element, return the list
    if len(nums) <= 1:
        return nums
    
    # Bubble sort algorithm
    n = len(nums)
    for i in range(n):
        # Flag to check if any swaps were made in the current pass
        swapped = False
        for j in range(n-1-i):
            # Swap adjacent elements if they are in the wrong order
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
                swapped = True
        # If no swaps were made in the current pass, the list is already sorted
        if not swapped:
            break
    
    # Return the sorted list in reverse order
    return nums[::-1]


import pandas as pd
import random


def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

# Example usage
strings = ["banana", "apple", "cherry", "date", "berry"]
bubble_sort(strings)
print(strings)


def custom_sort(lst):
    length = len(lst)
    
    if length <= 1:
        return lst
    
    # Sort in ascending order
    for i in range(length - 1):
        for j in range(0, length - i - 1):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
    
    # Sort in descending order
    lst.reverse()
    
    return lst


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def fibonacci_prime(n):
    count = 0
    num = 2
    while count < n:
        if is_prime(num) and num > 1:
            count += 1
        num += 1
    return num - 1


import math

def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return False
    return True

def delete_primes(arr, n):
    primes = []
    for i in range(n):
        if is_prime(arr[i]):
            primes.append(arr[i])
    modified_arr = []
    for num in arr:
        if num not in primes:
            modified_arr.append(num)
    return modified_arr


def determine_order(arr):
    # Check if the array is strictly increasing
    if all(arr[i] < arr[i + 1] for i in range(len(arr) - 1)):
        return "Strictly Increasing"

    # Check if the array is strictly decreasing
    if all(arr[i] > arr[i + 1] for i in range(len(arr) - 1)):
        return "Strictly Decreasing"

    # Check if the array is non-decreasing
    if all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)):
        return "Non-decreasing"

    # Check if the array is non-increasing
    if all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)):
        return "Non-increasing"

    # If none of the above conditions are met, the array is unordered
    return "Unordered"

# Example usage
array1 = [1, 2, 3, 4, 5]
print(determine_order(array1))  # Output: Strictly Increasing

array2 = [5, 4, 3, 2, 1]
print(determine_order(array2))  # Output: Strictly Decreasing

array3 = [1, 2, 2, 4, 5]
print(determine_order(array3))  # Output: Non-decreasing

array4 = [5, 4, 2, 2, 1]
print(determine_order(array4))  # Output: Non-increasing

array5 = [1, 5, 3, 2, 4]
print(determine_order(array5))  # Output: Unordered


numbers = [15, 20, 12, 18, 10]
numbers.sort(reverse=True)

print(numbers)


# List comprehension to create the dictionary
my_dict = {chr(97+i): 97+i for i in range(26) if chr(97+i).islower()}

# Sorting the keys in descending order
sorted_dict = {k: my_dict[k] for k in sorted(my_dict, reverse=True)}

# Printing the resulting dictionary
print(sorted_dict)


import os
import pandas as pd
from tabulate import tabulate
from fpdf import FPDF

class PDFReportGenerator:
    def __init__(self):
        self.data = None
    
    def prompt_file_path(self):
        file_path = input("Enter the file path of the dataset: ")
        while not self.validate_file_path(file_path):
            print("Invalid file path or format.")
            file_path = input("Please re-enter the file path: ")
        return file_path
    
    def validate_file_path(self, file_path):
        if not os.path.exists(file_path):
            return False
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension not in ['.csv', '.json', '.xlsx']:
            return False
        return True
    
    def load_data(self, file_path):
        file_extension = os.path.splitext(file_path)[1].lower()
        if file_extension == '.csv':
            self.data = pd.read_csv(file_path)
        elif file_extension == '.json':
            self.data = pd.read_json(file_path)
        elif file_extension == '.xlsx':
            self.data = pd.read_excel(file_path)
    
    def prompt_report_options(self):
        print("Select information to include in the PDF report:")
        print("1. Customer Name")
        print("2. Order Date")
        print("3. Product Name")
        print("4. Quantity")
        print("Enter the numbers of the selected options, separated by commas (e.g., 1,3,4):")
        options = input("Options: ")
        selected_options = options.split(',')
        if not self.validate_report_options(selected_options):
            print("Invalid options selected.")
            return self.prompt_report_options()
        return selected_options
    
    def validate_report_options(self, selected_options):
        valid_options = ['1', '2', '3', '4']
        for option in selected_options:
            if option.strip() not in valid_options:
                return False
        return True
    
    def generate_pdf_report(self, selected_options, output_path):
        pdf = FPDF()
        pdf.add_page()
        pdf.set_font('Arial', 'B', 16)
        pdf.cell(0, 10, "Customer Orders Report", 0, 1, 'C')
        pdf.set_font('Arial', 'B', 12)
        
        headers = []
        if '1' in selected_options:
            headers.append("Customer Name")
        if '2' in selected_options:
            headers.append("Order Date")
        if '3' in selected_options:
            headers.append("Product Name")
        if '4' in selected_options:
            headers.append("Quantity")
            
        data = self.data[headers].values.tolist()
        
        pdf.cell(0, 10, "Report Details:", 0, 1, 'L')
        pdf.set_font('Arial', '', 10)
        pdf.multi_cell(0, 10, tabulate(data, headers=headers, tablefmt='grid'))
        
        pdf.output(output_path)
    
    def prompt_output_path(self):
        output_path = input("Enter the desired file path and name for the PDF report: ")
        while not self.validate_output_path(output_path):
            print("Invalid file path or file already exists.")
            output_path = input("Please re-enter the file path and name: ")
        return output_path
    
    def validate_output_path(self, output_path):
        output_directory = os.path.dirname(output_path)
        if not os.path.exists(output_directory):
            return False
        if os.path.exists(output_path):
            return False
        return True
    
    def save_pdf_report(self, output_path):
        self.pdf.output(output_path)
    
    def run(self):
        file_path = self.prompt_file_path()
        self.load_data(file_path)
        selected_options = self.prompt_report_options()
        output_path = self.prompt_output_path()
        self.generate_pdf_report(selected_options, output_path)
        print("PDF report has been created and saved successfully.")

report_generator = PDFReportGenerator()
report_generator.run()


import math

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def get_prime_numbers(numbers):
    if not isinstance(numbers, list):
        raise TypeError("Input must be a list")
    if len(numbers) < 10 or len(numbers) > 1000:
        raise ValueError("Input list must contain between 10 and 1000 integers")
    primes = []
    for num in numbers:
        if not isinstance(num, int):
            raise TypeError("Input list must only contain integers")
        if is_prime(num):
            primes.append(num)
    return primes


def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def prime_multiplication_table(n):
    primes = []
    num = 2
    while len(primes) < n:
        if is_prime(num):
            primes.append(num)
        num += 1
    
    table = [[0] * (n + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            table[i][j] = primes[i - 1] * primes[j - 1]
    
    sum_of_numbers = sum(sum(row) for row in table)
    
    for row in table:
        for num in row:
            print(num, end='\t')
        print()
    
    print("Sum of all numbers in the multiplication table:", sum_of_numbers)

# Example usage
n = int(input("Enter the value of N: "))
prime_multiplication_table(n)


import math

def print_greetings():
    n = input("Enter an odd prime number: ")

    while True:
        try:
            n = int(n)
            if n < 1 or n > 10**6 or n % 2 == 0:
                raise ValueError
            break
        except ValueError:
            print("Invalid input. Please enter an odd prime number between 1 and 10^6.")
            n = input("Enter an odd prime number: ")

    count = 1
    for i in range(n):
        print("Greeting {}: Hello, World!".format(count))
        count += 1

print_greetings()


def extract_last_three_words(string):
    # Remove leading and trailing spaces
    string = string.strip()
    
    # Split the string into words
    words = string.split()
    
    # Remove any punctuation marks from the words
    words = [word.strip(',.!') for word in words]
    
    # Convert all words to lowercase
    words = [word.lower() for word in words]
    
    # Remove any duplicate words
    words = list(set(words))
    
    # Extract the last three words
    last_three_words = words[-3:]
    
    return last_three_words


import uuid

class Queue:
    def __init__(self):
        self.queue = []
    
    def enqueue(self, element):
        unique_id = str(uuid.uuid4())
        self.queue.append((element, unique_id))
    
    def dequeue(self):
        if self.is_empty():
            return None
        element, unique_id = self.queue.pop(0)
        self._log_element(element, unique_id)
        return element
    
    def get_front(self):
        if self.is_empty():
            return None
        return self.queue[0][0]
    
    def is_empty(self):
        return len(self.queue) == 0
    
    def size(self):
        return len(self.queue)
    
    def clear(self):
        self.queue = []
    
    def _log_element(self, element, unique_id):
        with open("queue_logs.txt", "a") as file:
            file.write(f"Element: {element}, Unique ID: {unique_id}\n")


import random
import time
import threading

def generate_random_list(size, range_start, range_end):
    return [random.randint(range_start, range_end) for _ in range(size)]

def delete_even_numbers_inplace(lst):
    i = 0
    while i < len(lst):
        if lst[i] % 2 == 0:
            lst.pop(i)
        else:
            i += 1

def delete_even_numbers_new_list(lst):
    return [num for num in lst if num % 2 != 0]

def validate_list_size(size):
    return size >= 1000 and size <= 10000

def validate_option(option):
    return option in ['1', '2']

def delete_even_numbers():
    size = 0
    while not validate_list_size(size):
        size = int(input("Enter the size of the list (between 1000 and 10000): "))
        if not validate_list_size(size):
            print("Invalid list size. Please enter a valid size.")

    range_start = int(input("Enter the start of the range: "))
    range_end = int(input("Enter the end of the range: "))

    lst = generate_random_list(size, range_start, range_end)
    print("Original list:")
    print(lst)

    option = ""
    while not validate_option(option):
        option = input("Enter 1 to delete even numbers in-place, or 2 to create a new list without even numbers: ")
        if not validate_option(option):
            print("Invalid option. Please enter a valid option.")

    start_time = time.time()

    if option == '1':
        delete_even_numbers_inplace(lst)
    else:
        lst = delete_even_numbers_new_list(lst)

    end_time = time.time()
    execution_time = (end_time - start_time) * 1000

    print("List after deleting even numbers:")
    print(lst)
    print("Execution time: {} milliseconds".format(execution_time))

    repeat = input("Enter Y to repeat the operation, or any other key to exit: ")
    if repeat.lower() == 'y':
        delete_even_numbers()

if __name__ == "__main__":
    delete_even_numbers()


items = [1, 2, 3, 4, 5]

def remove_elements(array):
    return list(filter(lambda element: False, array))

modified_array = remove_elements(items)
print(modified_array)


def print_nested_dict(dictionary, indent='\t', separate_lines=True, include_quotes=True):
    def _print_value(value):
        data_type = type(value).__name__
        if isinstance(value, (dict, list)):
            print_value(value, indent + '\t', separate_lines, include_quotes)
        else:
            if include_quotes and isinstance(value, str):
                value = f'"{value}"'
            print(f'{value} ({data_type})')

    def print_value(value, current_indent, separate_lines, include_quotes):
        if isinstance(value, dict):
            for key, val in value.items():
                print(f'{current_indent}{key}:', end=' ')
                if separate_lines:
                    print()
                _print_value(val)
        elif isinstance(value, list):
            for item in value:
                print(current_indent, end='')
                _print_value(item)

    try:
        print_value(dictionary, '', separate_lines, include_quotes)
    except AttributeError:
        print('Error: The input is not a valid nested dictionary.')
    except Exception as e:
        print(f'Error: An unexpected error occurred: {e}')


# Example usage:
nested_dict = {
    'key1': 'value1',
    'key2': {
        'subkey1': [1, 2, 3],
        'subkey2': 'value2',
    },
    'key3': {
        'subkey3': {
            'subsubkey1': 'value3',
        }
    }
}

print_nested_dict(nested_dict)


def is_prime(num):
    if num < 2:
        return False
    for i in range(2, num):
        if num % i == 0:
            return False
    return True

def get_prime_numbers(lst):
    prime_numbers = []
    for num in lst:
        if is_prime(num):
            prime_numbers.append(num)
    return prime_numbers


my_list = [3, 5, -7, 3, 4, -6, 7, 8]
unique_values = list(set(my_list))
print(unique_values)


def length_of_longest_substring(string):
    start = 0
    end = 0
    maxLen = 0
    upper = False
    lower = False
    digit = False
    charSet = set()

    while end < len(string):
        if string[end].isupper():
            upper = True
        elif string[end].islower():
            lower = True
        elif string[end].isdigit():
            digit = True

        if upper and lower and digit:
            maxLen = max(maxLen, end - start)

        while string[end] in charSet:
            charSet.remove(string[start])
            start += 1

        charSet.add(string[end])
        end += 1

    return maxLen


def count_valid_triplets(nums):
    n = len(nums)
    count = 0

    # Sort the array in non-decreasing order
    for i in range(n - 1):
        for j in range(i + 1, n):
            if nums[i] > nums[j]:
                nums[i], nums[j] = nums[j], nums[i]

    # Fix the first element and use two pointers to find the valid triplets
    for i in range(n - 2):
        k = i + 2
        for j in range(i + 1, n - 1):
            while k < n and nums[i] + nums[j] > nums[k]:
                k += 1
            count += k - j - 1

    return count

# Test the program with some sample inputs
nums = [4, 3, 5, 7, 6]
print(count_valid_triplets(nums))  # Output: 6

nums = [1, 2, 3, 4, 5]
print(count_valid_triplets(nums))  # Output: 10

nums = [1, 1, 1, 2, 2, 3]
print(count_valid_triplets(nums))  # Output: 12


import re

def convert_char_stream(char_stream):
    numbers = re.findall(r'-?\d+', char_stream)  # Extract all numbers from the character stream
    return sum(int(number) for number in numbers)  # Convert the numbers to integers and sum them

char_stream = "8kk573-32op49$16"
result = convert_char_stream(char_stream)
print(result)  # Output: 614


class Employee:
    def __init__(self, employee_id: int, first_name: str, last_name: str, salary: float):
        self.employee_id = employee_id
        self.first_name = first_name
        self.last_name = last_name
        self.salary = salary

    def get_employee_id(self) -> int:
        return self.employee_id

    def get_full_name(self) -> str:
        return f"{self.first_name} {self.last_name}"

    def get_salary(self) -> float:
        return self.salary

    def set_salary(self, new_salary: float):
        if new_salary < 0:
            raise ValueError("Salary cannot be negative.")
        self.salary = new_salary

    def calculate_yearly_bonus(self) -> float:
        return self.salary * 0.1

    def promote(self, new_title: str):
        self.title = new_title

# Example usage:
employee = Employee(1, "John", "Doe", 5000.0)
print(employee.get_full_name())  # Output: John Doe
print(employee.get_salary())  # Output: 5000.0
employee.set_salary(6000.0)
print(employee.get_salary())  # Output: 6000.0
print(employee.calculate_yearly_bonus())  # Output: 600.0
employee.promote("Manager")
print(employee.title)  # Output: Manager


def binary_to_integer(binary_list):
    # Check if the binary list is empty
    if not binary_list:
        return 0

    # Check if the binary list contains invalid elements
    if not all(bit == 0 or bit == 1 for bit in binary_list):
        return 0

    # Convert the binary list to a string
    binary_string = ''.join(str(bit) for bit in binary_list)

    # Convert the binary string to an integer
    integer_value = int(binary_string, 2)

    return integer_value

# Test the program
binary_list = [1, 0, 1, 0]
print(binary_to_integer(binary_list))


def aliceWins(piles):
    n = len(piles)
    dp = [[0] * n for _ in range(n)]
    for gap in range(n):
        for i in range(n - gap):
            j = i + gap
            x = dp[i + 2][j] if i + 2 <= j else 0
            y = dp[i + 1][j - 1] if i + 1 <= j - 1 else 0
            z = dp[i][j - 2] if i <= j - 2 else 0
            dp[i][j] = max(piles[i] + min(x, y), piles[j] + min(y, z))
    sum_of_piles = sum(piles)
    return dp[0][n - 1] > (sum_of_piles - dp[0][n - 1])


import re

def validate_string(s):
    if len(s) < 5:
        return False
    if not re.match("^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$", s):
        return False
    return True

# Example usage:
input_string = "Abc123!"
if validate_string(input_string):
    print("Valid string")
else:
    print("Invalid string")


# Erroneous code
def kmeans(data, k):
    # Initialize centroids randomly
    centroids = np.random.rand(k, data.shape[1])
    
    # Iterate until convergence
    while True:
        # Assign each data point to the nearest centroid
        assignments = np.argmin(np.linalg.norm(data - centroids[:, np.newaxis], axis=2), axis=0)
        
        # Update centroids
        for i in range(k):
            # Compute the mean of the assigned data points
            assigned_points = data[assignments == i]
            new_centroid = np.mean(assigned_points, axis=0)
            
            # Update the centroid
            centroids[i] = new_centroid
            
        # Check for convergence
        if np.allclose(old_centroids, centroids):
            break
    
    return centroids, assignments


def quicksort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]
        less = [x for x in arr[1:] if x <= pivot]
        greater = [x for x in arr[1:] if x > pivot]
        return quicksort(less) + [pivot] + quicksort(greater)


class Node:
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None

# Create the nodes
node1 = Node(5)
node2 = Node(6)
node3 = Node(2)
node4 = Node(9)
node5 = Node(0)

# Link the nodes together
node1.next = node2
node2.prev = node1

node2.next = node3
node3.prev = node2

node3.next = node4
node4.prev = node3

node4.next = node5
node5.prev = node4

# Print the doubly linked list
current = node1
while current:
    print(current.data)
    current = current.next


def print_multiplication_table(x, n):
    # Step 1: Check if x is positive
    if x <= 0:
        print("Error: x must be a positive number")
        return
    
    # Step 2: Check if n is positive
    if n <= 0:
        print("Error: n must be a positive number")
        return
    
    # Step 3: Iterate from 1 to n
    for i in range(1, n+1):
        # Step 3a: Print the value of i followed by a colon
        print(str(i) + ":", end="")
        
        # Step 3b: Iterate from 1 to x
        for j in range(1, x+1):
            # Step 3bi: Calculate the product of i and j
            product = i * j
            # Step 3bii: Print the product followed by a tab character
            print(str(product) + "\t", end="")
        
        # Step 3c: Print a new line character
        print()

# Testing the function
print_multiplication_table(8, 5)


def get_num_days(month):
    # Dictionary mapping month names to number of days
    days_in_month = {
        'January': 31,
        'February': 28,
        'March': 31,
        'April': 30,
        'May': 31,
        'June': 30,
        'July': 31,
        'August': 31,
        'September': 30,
        'October': 31,
        'November': 30,
        'December': 31
    }

    # Handling leap years
    def is_leap_year(year):
        if year % 4 != 0:
            return False
        elif year % 100 != 0:
            return True
        elif year % 400 != 0:
            return False
        else:
            return True

    # Handling different calendar systems
    def get_num_days_julian(month):
        days_in_month_julian = days_in_month.copy()
        days_in_month_julian['February'] = 29
        return days_in_month_julian[month]

    def get_num_days_islamic(month):
        days_in_month_islamic = {
            'Muharram': 30,
            'Safar': 29,
            'Rabi al-awwal': 30,
            'Rabi al-thani': 29,
            'Jumada al-awwal': 30,
            'Jumada al-thani': 29,
            'Rajab': 30,
            'Sha`ban': 29,
            'Ramadan': 30,
            'Shawwal': 29,
            'Dhu al-Qa`dah': 30,
            'Dhu al-Hijjah': 29
        }
        return days_in_month_islamic[month]

    # Handling different calendar systems based on user input
    calendar_system = input("Enter the calendar system (Gregorian, Julian, Islamic): ")
    if calendar_system == 'Gregorian':
        if month in days_in_month:
            return days_in_month[month]
        else:
            return "Invalid month name!"
    elif calendar_system == 'Julian':
        if month in days_in_month:
            return get_num_days_julian(month)
        else:
            return "Invalid month name!"
    elif calendar_system == 'Islamic':
        if month in days_in_month_islamic:
            return get_num_days_islamic(month)
        else:
            return "Invalid month name!"
    else:
        return "Invalid calendar system!"


def reverse_string(string):
    length = len(string)
    reversed_string = ""
    for i in range(length-1, -1, -1):
        reversed_string += string[i]
    return reversed_string


def compare_objects(obj1, obj2):
    # Check if the ages of both objects are prime numbers
    obj1_prime = is_prime(obj1["age"])
    obj2_prime = is_prime(obj2["age"])
    
    if obj1_prime and obj2_prime:
        # If both ages are prime numbers, compare their addresses
        return compare_addresses(obj1, obj2)
    elif obj1_prime:
        # If only obj1's age is prime, consider obj1 to be larger
        return 1
    elif obj2_prime:
        # If only obj2's age is prime, consider obj2 to be larger
        return -1
    
    # Compare ages
    if obj1["age"] > obj2["age"]:
        return 1
    elif obj1["age"] < obj2["age"]:
        return -1
    
    # If ages are the same, compare names
    if obj1["name"] > obj2["name"]:
        return 1
    elif obj1["name"] < obj2["name"]:
        return -1
    
    # If names are the same, compare addresses
    return compare_addresses(obj1, obj2)

def is_prime(n):
    # Check if a number is prime
    if n <= 1:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def compare_addresses(obj1, obj2):
    # Compare addresses
    if obj1["address"] > obj2["address"]:
        return 1
    elif obj1["address"] < obj2["address"]:
        return -1
    return 0

# Example objects
object1 = {
  "name": "John",
  "age": 25,
  "address": "123 Main St"
}

object2 = {
  "name": "Jane",
  "age": 30,
  "address": "456 Elm St"
}

object3 = {
  "name": "John",
  "age": 30,
  "address": "123 Main St"
}

object4 = {
  "name": "Jane",
  "age": 23,
  "address": "456 Elm St"
}

# Compare objects
print(compare_objects(object1, object2))  # -1
print(compare_objects(object2, object3))  # 5
print(compare_objects(object3, object4))  # -1
print(compare_objects(object4, object1))  # 7


def count_occurrences(string, character):
    count = 0
    for char in string:
        if char.lower() == character.lower():
            count += 1
    return count

# Test cases
print(count_occurrences("Hello World!", 'l'))  # Correct output: 3
print(count_occurrences("Hello World!", 'o'))  # Correct output: 2
print(count_occurrences("Hello World!", 'd'))  # Correct output: 1


def fibonacci(a, b, n):
    if n == 1:
        return a
    elif n == 2:
        return b
    else:
        return fibonacci(a, b, n-1) + fibonacci(a, b, n-2)


def wrap_bold_tag(string):
    index = string.index("bold")
    wrapped_string = string[:index] + "<strong>" + "bold" + "</strong>" + string[index+4:]
    return wrapped_string


def main():
    confirmed = False

    # Keep looping until user confirms or denies
    while not confirmed:
        # Prompt the user for confirmation
        confirm_input = input("Do you want to proceed? (yes/no): ")
        if confirm_input.lower() == "yes":
            # User confirmed, ask for additional information
            name = input("What is your name? ")
            age = input("What is your age? ")
            print(f"Thank you, {name} ({age} years old).")
            confirmed = True
        elif confirm_input.lower() == "no":
            # User denied, exit program
            print("Exiting program.")
            confirmed = True
        else:
            # Invalid input, prompt user again
            print("Invalid input. Please enter 'yes' or 'no'.")


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def add(self, item):
        # Add the item to the end of the list
        pass

    def remove(self, item):
        # Remove the first occurrence of the item from the list
        pass

    def contains(self, item):
        # Return a boolean value indicating whether the item is present in the list or not
        pass

    def size(self):
        # Return the current number of items in the list
        pass

    def is_empty(self):
        # Return a boolean value indicating whether the list is empty or not
        pass

    def get(self, index):
        # Return the item at the specified index in the list
        pass

    def clear(self):
        # Remove all items from the list
        pass

    def get_max_length(self):
        # Return the maximum length of the list
        pass


import sqlite3

def execute_sql_query(query):
    try:
        conn = sqlite3.connect('database.db')
        cursor = conn.cursor()
        
        # SELECT statement
        if query.lower().startswith('select'):
            cursor.execute(query)
            rows = cursor.fetchall()
            if rows:
                # Print column names
                print('\t'.join([description[0] for description in cursor.description]))
                # Print rows
                for row in rows:
                    print('\t'.join([str(value) for value in row]))
            else:
                print('No results found.')

        # INSERT statement
        elif query.lower().startswith('insert'):
            cursor.execute(query)
            conn.commit()
            print('Data inserted successfully.')

        # UPDATE statement
        elif query.lower().startswith('update'):
            cursor.execute(query)
            conn.commit()
            print('Data updated successfully.')

        # DELETE statement
        elif query.lower().startswith('delete'):
            cursor.execute(query)
            conn.commit()
            print('Data deleted successfully.')

        # CREATE TABLE statement
        elif query.lower().startswith('create table'):
            cursor.execute(query)
            conn.commit()
            print('Table created successfully.')

        # DROP TABLE statement
        elif query.lower().startswith('drop table'):
            cursor.execute(query)
            conn.commit()
            print('Table dropped successfully.')

        else:
            print('Unsupported SQL statement.')

        cursor.close()

    except sqlite3.Error as error:
        print('Error executing SQL query:', error)

    finally:
        if conn:
            conn.close()


import random
import math

# Function to generate all prime numbers up to the maximum value
def generate_primes(max_value):
    primes = [True] * (max_value + 1)
    primes[0] = primes[1] = False

    for i in range(2, int(math.sqrt(max_value)) + 1):
        if primes[i]:
            for j in range(i * i, max_value + 1, i):
                primes[j] = False

    return [num for num, is_prime in enumerate(primes) if is_prime]

# Function to check if a number is prime using Miller-Rabin primality test
def is_prime(number):
    # Check for small primes
    if number < 2:
        return False
    if number in (2, 3):
        return True

    # Check if number is divisible by small primes
    if number % 2 == 0 or number % 3 == 0:
        return False

    # Apply Miller-Rabin primality test
    d = number - 1
    r = 0
    while d % 2 == 0:
        d //= 2
        r += 1

    def witness(a):
        x = pow(a, d, number)
        if x == 1 or x == number - 1:
            return True
        for _ in range(r - 1):
            x = pow(x, 2, number)
            if x == number - 1:
                return True
        return False

    for _ in range(20):  # Perform 20 rounds of testing
        a = random.randint(2, number - 2)
        if not witness(a):
            return False

    return True

# Function to print prime numbers between two given values
def print_prime_numbers(start, end):
    if start >= end:
        return

    max_value = max(start, end) - 1
    primes = generate_primes(max_value)

    if is_prime(start):
        start += 1
    if is_prime(end):
        end -= 1

    for prime in primes:
        if start < prime < end:
            print(prime)

# Test case generator
def generate_test_case():
    start = random.randint(1, 1000)
    end = random.randint(start + 1, start + 1000)
    return start, end

# Generate and print a random test case
start, end = generate_test_case()
print("Start:", start)
print("End:", end)
print("Prime numbers between start and end:")
print_prime_numbers(start, end)


def merge(left, right):
    merged = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] >= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged

def reorderArray(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = reorderArray(arr[:mid])
    right = reorderArray(arr[mid:])
    return merge(left, right)


def check_even_numbers(array):
    if len(array) == 0:
        print("Empty array")
    else:
        found_even = False
        for i in range(len(array)):
            for j in range(len(array[i])):
                if array[i][j] % 2 == 0:
                    found_even = True
                    print("Even number found at index", (i, j))
                    break
            if found_even:
                break
        if not found_even:
            print("No even number found")

# Example usage:
array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
check_even_numbers(array)


import requests
from bs4 import BeautifulSoup

# Function to scrape the website and retrieve the population data
def scrape_population():
    url = "https://www.census.gov/costa-rica/population.html"
    try:
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        population = soup.find('div', {'id': 'population'}).find('span', {'class': 'value'}).text
        return int(population.replace(',', ''))
    except:
        return None

# Function to validate the retrieved data by comparing with other trusted sources
def validate_population(population):
    # Additional sources to compare population data
    source1_population = 5100000
    source2_population = 5030000
    
    if population is None:
        return False
    elif population == source1_population or population == source2_population:
        return True
    else:
        return False

# Function to calculate population density
def calculate_population_density(population, land_area):
    return population / land_area

# Main program
def main():
    # Retrieve population from web scraping
    population = scrape_population()

    # Validate the retrieved population
    if validate_population(population):
        print("The population of Costa Rica according to the latest census data is:", population)

        # Retrieve land area from another trusted source or use a predetermined value
        land_area = 51100 # Assuming 51,100 square kilometers as land area of Costa Rica

        # Calculate population density
        population_density = calculate_population_density(population, land_area)
        print("The population density of Costa Rica is:", population_density, "people per square kilometer.")
    else:
        print("Failed to retrieve accurate population data.")

if __name__ == "__main__":
    main()


from collections import deque

def shortestDistance(grid: list[list[int]]) -> int:
    m, n = len(grid), len(grid[0])

    total_count = [[0] * n for _ in range(m)]
    dist_sum = [[0] * n for _ in range(m)]
    house_count = 0

    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for i in range(m):
        for j in range(n):
            if grid[i][j] == 1:
                house_count += 1
                q = deque([(i, j)])
                visited = [[False] * n for _ in range(m)]
                level = 1
                while q:
                    for _ in range(len(q)):
                        x, y = q.popleft()
                        for dx, dy in dirs:
                            x_new, y_new = x + dx, y + dy
                            if 0 <= x_new < m and 0 <= y_new < n and not visited[x_new][y_new] and grid[x_new][y_new] == 0:
                                visited[x_new][y_new] = True
                                q.append((x_new, y_new))
                                dist_sum[x_new][y_new] += level
                                total_count[x_new][y_new] += 1
                    level += 1

    min_dist = float("inf")
    for i in range(m):
        for j in range(n):
            if total_count[i][j] == house_count:
                min_dist = min(min_dist, dist_sum[i][j])

    return -1 if min_dist == float("inf") else min_dist


import random
# lists of adjectives for the feline and the table
feline_adjectives = ['sleek', 'graceful', 'ferocious', 'curious', 'sly']
table_adjectives = ['polished wooden', 'marble', 'glass', 'metal', 'rustic']
# random choice of adjectives for the feline and the table
feline_adj = random.choice(feline_adjectives)
table_adj = random.choice(table_adjectives)
# generate the sentence
sentence = f"The {feline_adj} black feline [hopped] {random.choice(['onto', 'into'])} the {table_adj} table, its {random.choice(['tail', 'whiskers'])} {random.choice(['swishing', 'twitching'])} behind it."
print(sentence)


import re

string = "The quick brown fox jumps over the quick lazy dog"
pattern = r'(?<=quick )fox(?=\s)'

occurrences = re.findall(pattern, string)
print(occurrences)  # Output: ['fox']


def sort_tasks(tasks):
    priority_1 = []
    priority_2_9 = []
    priority_10 = []
    
    for task in tasks:
        if task["priority"] == 1:
            priority_1.append(task)
        elif task["priority"] == 10:
            priority_10.append(task)
        else:
            priority_2_9.append(task)
    
    priority_2_9.sort(key=lambda x: (x["name"], x["id"]))
    
    return priority_1 + priority_2_9 + priority_10


def binary_search(lst, target):
    start = 0
    end = len(lst) - 1
    
    while start <= end:
        middle = (start + end) // 2
        if lst[middle] == target:
            return middle
        elif lst[middle] > target:
            end = middle - 1
        else:
            start = middle + 1
    
    return -1


import random
import string

generated_ids = set()

def generate_unique_id():
    while True:
        id = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
        if id[0].isupper() and sum(1 for c in id if c.islower()) >= 2 and sum(1 for c in id if c.isupper()) >= 2 and sum(1 for c in id if c.isdigit()) >= 2 and id not in generated_ids:
            generated_ids.add(id)
            return id


def custom_sort_string(order, s):
    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))


def validate_string(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    if len(string) < 10 or len(string) > 30:
        return False
    if any(char.isdigit() or not char.isalnum() for char in string):
        return False
    if string[0].lower() in vowels:
        return False
    for i in range(len(string) - 3):
        substring = string[i:i+4]
        if string.count(substring) > 1:
            return False
    return True

def get_lengths(strings):
    lengths = []
    for string in strings:
        if validate_string(string):
            lengths.append(len(string))
    return lengths


def find_substring(string, substring):
    occurrences = 0
    positions = []

    len_string = len(string)
    len_substring = len(substring)

    if len_substring > len_string:
        return occurrences, positions

    for i in range(len_string - len_substring + 1):
        if string[i:i + len_substring] == substring:
            occurrences += 1
            positions.append(i)

    return occurrences, positions


def main():
    string = input("Enter the string: ")
    substring = input("Enter the substring: ")

    occurrences, positions = find_substring(string, substring)

    print(f"The substring '{substring}' occurs {occurrences} times.")
    print(f"It occurs at positions: {', '.join(map(str, positions))}")


if __name__ == "__main__":
    main()


import math
def wind_power(density, area, velocity):
 power = 0.5 * density * area * math.pow(velocity, 3)
 return power
density = 1.225 # kg/m^3
area = 100 # m^2
velocity = 10 # m/s
power = wind_power(density, area, velocity)
print("Wind power generated:", power, "Watts")
